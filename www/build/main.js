webpackJsonp([0],{

/***/ 10:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfigProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




const configDefault = {
    // wallet limits
    limits: {
        totalCopayers: 6,
        mPlusN: 100
    },
    // wallet default config
    wallet: {
        useLegacyAddress: false,
        requiredCopayers: 2,
        totalCopayers: 3,
        spendUnconfirmed: false,
        reconnectDelay: 5000,
        idleDurationMin: 4,
        settings: {
            unitName: 'BTJ',
            unitToSatoshi: 100000000,
            unitDecimals: 8,
            unitCode: 'btc',
            alternativeName: 'US Dollar',
            alternativeIsoCode: 'USD',
            defaultLanguage: '',
            feeLevel: 'normal'
        }
    },
    // Bitcore wallet service URL
    bws: {
        url: 'https://bws.bitpay.com/bws/api'
    },
    download: {
        bitpay: {
            url: 'https://bitpay.com/wallet'
        },
        copay: {
            url: 'https://copay.io/#download'
        }
    },
    rateApp: {
        bitpay: {
            ios: 'https://itunes.apple.com/app/bitpay-secure-bastoji-wallet/id1149581638',
            android: 'https://play.google.com/store/apps/details?id=com.bitpay.wallet',
            wp: ''
        },
        copay: {
            ios: 'https://itunes.apple.com/app/copay-bastoji-wallet/id951330296',
            android: 'https://play.google.com/store/apps/details?id=com.bitpay.copay',
            wp: ''
        }
    },
    lock: {
        method: null,
        value: null,
        bannedUntil: null
    },
    // External services
    recentTransactions: {
        enabled: true
    },
    showIntegration: {
        coinbase: true,
        glidera: true,
        debitcard: true,
        amazon: true,
        mercadolibre: true,
        shapeshift: true
    },
    rates: {
        url: 'https://insight.bitpay.com:443/api/rates'
    },
    release: {
        url: 'https://api.github.com/repos/bitpay/copay/releases/latest'
    },
    pushNotificationsEnabled: true,
    confirmedTxsNotifications: {
        enabled: true
    },
    emailNotifications: {
        enabled: false,
        email: ''
    },
    log: {
        weight: 3
    },
    blockExplorerUrl: {
        btc: 'insight.bitpay.com',
        bch: 'bch-insight.bitpay.com/#'
    }
};
let ConfigProvider = class ConfigProvider {
    constructor(logger, persistence) {
        this.logger = logger;
        this.persistence = persistence;
        this.logger.info('ConfigProvider initialized.');
    }
    load() {
        return new Promise((resolve, reject) => {
            this.persistence
                .getConfig()
                .then((config) => {
                if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](config)) {
                    this.configCache = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](config);
                    this.backwardCompatibility();
                }
                else {
                    this.configCache = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](configDefault);
                }
                resolve();
            })
                .catch(err => {
                this.logger.error('Error Loading Config');
                reject(err);
            });
        });
    }
    /**
     * @param newOpts object or string (JSON)
     */
    set(newOpts) {
        let config = __WEBPACK_IMPORTED_MODULE_3_lodash__["cloneDeep"](configDefault);
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isString"](newOpts)) {
            newOpts = JSON.parse(newOpts);
        }
        __WEBPACK_IMPORTED_MODULE_3_lodash__["merge"](config, this.configCache, newOpts);
        this.configCache = config;
        this.persistence.storeConfig(this.configCache).then(() => {
            this.logger.info('Config saved');
        });
    }
    get() {
        return this.configCache;
    }
    getDefaults() {
        return configDefault;
    }
    backwardCompatibility() {
        // these ifs are to avoid migration problems
        if (this.configCache.bws) {
            this.configCache.bws = configDefault.bws;
        }
        if (!this.configCache.wallet) {
            this.configCache.wallet = configDefault.wallet;
        }
        if (!this.configCache.wallet.settings.unitCode) {
            this.configCache.wallet.settings.unitCode =
                configDefault.wallet.settings.unitCode;
        }
        if (!this.configCache.showIntegration) {
            this.configCache.showIntegration = configDefault.showIntegration;
        }
        if (!this.configCache.recentTransactions) {
            this.configCache.recentTransactions = configDefault.recentTransactions;
        }
        if (!this.configCache.pushNotificationsEnabled) {
            this.configCache.pushNotificationsEnabled =
                configDefault.pushNotificationsEnabled;
        }
        if (this.configCache.wallet.settings.unitCode == 'bit') {
            // Convert to BTJ. Bits will be disabled
            this.configCache.wallet.settings.unitName =
                configDefault.wallet.settings.unitName;
            this.configCache.wallet.settings.unitToSatoshi =
                configDefault.wallet.settings.unitToSatoshi;
            this.configCache.wallet.settings.unitDecimals =
                configDefault.wallet.settings.unitDecimals;
            this.configCache.wallet.settings.unitCode =
                configDefault.wallet.settings.unitCode;
        }
    }
};
ConfigProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__["a" /* PersistenceProvider */]])
], ConfigProvider);

//# sourceMappingURL=config.js.map

/***/ }),

/***/ 1000:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Environment: prod
 */
const env = {
    name: 'production',
    enableAnimations: true,
    ratesAPI: {
        btc: 'https://bitpay.com/api/rates',
        bch: 'https://bitpay.com/api/rates/bch'
    },
    activateScanner: true
};
/* harmony default export */ __webpack_exports__["a"] = (env);
//# sourceMappingURL=prod.js.map

/***/ }),

/***/ 1001:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopayApp; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_screen_orientation__ = __webpack_require__(638);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_splash_screen__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_incoming_data_incoming_data__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_shapeshift_shapeshift__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__pages_add_copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pages_add_import_wallet_import_wallet__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pages_add_join_wallet_join_wallet__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__pages_fingerprint_fingerprint__ = __webpack_require__(856);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__pages_integrations_coinbase_coinbase__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__pages_integrations_glidera_glidera__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pages_onboarding_onboarding__ = __webpack_require__(857);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pages_paper_wallet_paper_wallet__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pages_pin_pin_modal_pin_modal__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pages_send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pages_send_confirm_confirm__ = __webpack_require__(355);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__pages_settings_addressbook_add_add__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__pages_tabs_tabs__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__pages_wallet_details_wallet_details__ = __webpack_require__(146);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers















// pages
















// As the handleOpenURL handler kicks in before the App is started,
// declare the handler function at the top of app.component.ts (outside the class definition)
// to track the passed Url
window.handleOpenURL = (url) => {
    window.handleOpenURL_LastURL = url;
};
let CopayApp = class CopayApp {
    constructor(platform, statusBar, splashScreen, events, logger, appProvider, profile, configProvider, modalCtrl, glideraProvider, coinbaseProvider, amazonProvider, bitPayCardProvider, mercadoLibreProvider, shapeshiftProvider, emailNotificationsProvider, screenOrientation, popupProvider, pushNotificationsProvider, app, incomingDataProvider) {
        this.platform = platform;
        this.statusBar = statusBar;
        this.splashScreen = splashScreen;
        this.events = events;
        this.logger = logger;
        this.appProvider = appProvider;
        this.profile = profile;
        this.configProvider = configProvider;
        this.modalCtrl = modalCtrl;
        this.glideraProvider = glideraProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.amazonProvider = amazonProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.mercadoLibreProvider = mercadoLibreProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.screenOrientation = screenOrientation;
        this.popupProvider = popupProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.app = app;
        this.incomingDataProvider = incomingDataProvider;
        this.pageMap = {
            AddressbookAddPage: __WEBPACK_IMPORTED_MODULE_33__pages_settings_addressbook_add_add__["a" /* AddressbookAddPage */],
            AmountPage: __WEBPACK_IMPORTED_MODULE_31__pages_send_amount_amount__["a" /* AmountPage */],
            BitPayCardIntroPage: __WEBPACK_IMPORTED_MODULE_24__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
            CoinbasePage: __WEBPACK_IMPORTED_MODULE_25__pages_integrations_coinbase_coinbase__["a" /* CoinbasePage */],
            ConfirmPage: __WEBPACK_IMPORTED_MODULE_32__pages_send_confirm_confirm__["a" /* ConfirmPage */],
            CopayersPage: __WEBPACK_IMPORTED_MODULE_20__pages_add_copayers_copayers__["a" /* CopayersPage */],
            GlideraPage: __WEBPACK_IMPORTED_MODULE_26__pages_integrations_glidera_glidera__["a" /* GlideraPage */],
            ImportWalletPage: __WEBPACK_IMPORTED_MODULE_21__pages_add_import_wallet_import_wallet__["a" /* ImportWalletPage */],
            JoinWalletPage: __WEBPACK_IMPORTED_MODULE_22__pages_add_join_wallet_join_wallet__["a" /* JoinWalletPage */],
            PaperWalletPage: __WEBPACK_IMPORTED_MODULE_29__pages_paper_wallet_paper_wallet__["a" /* PaperWalletPage */],
            WalletDetailsPage: __WEBPACK_IMPORTED_MODULE_35__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */]
        };
        this.initializeApp();
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
    }
    initializeApp() {
        this.platform
            .ready()
            .then(readySource => {
            this.onPlatformReady(readySource);
        })
            .catch(e => {
            this.logger.error('Platform is not ready.', e);
        });
    }
    onPlatformReady(readySource) {
        this.appProvider
            .load()
            .then(() => {
            this.onAppLoad(readySource);
        })
            .catch(err => {
            let title = 'Could not initialize the app';
            let message = JSON.stringify(err);
            this.popupProvider.ionicAlert(title, message);
        });
    }
    onAppLoad(readySource) {
        this.logger.info('Platform ready (' +
            readySource +
            '): ' +
            this.appProvider.info.nameCase +
            ' - v' +
            this.appProvider.info.version +
            ' #' +
            this.appProvider.info.commitHash);
        if (this.platform.is('cordova')) {
            this.statusBar.show();
            // Set to portrait
            this.screenOrientation.lock(this.screenOrientation.ORIENTATIONS.PORTRAIT);
            // Only overlay for iOS
            if (this.platform.is('ios'))
                this.statusBar.overlaysWebView(true);
            this.statusBar.styleLightContent();
            this.splashScreen.hide();
            // Subscribe Resume
            this.onResumeSubscription = this.platform.resume.subscribe(() => {
                // Check PIN or Fingerprint on Resume
                this.openLockModal();
            });
            // Check PIN or Fingerprint
            this.openLockModal();
        }
        this.registerIntegrations();
        this.incomingDataRedirEvent();
        // Check Profile
        this.profile
            .loadAndBindProfile()
            .then(profile => {
            this.onProfileLoad(profile);
        })
            .catch((err) => {
            this.logger.warn('LoadAndBindProfile', err.message);
            this.rootPage =
                err.message == 'ONBOARDINGNONCOMPLETED: Onboarding non completed'
                    ? __WEBPACK_IMPORTED_MODULE_28__pages_onboarding_onboarding__["a" /* OnboardingPage */]
                    : __WEBPACK_IMPORTED_MODULE_27__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */];
        });
    }
    onProfileLoad(profile) {
        this.emailNotificationsProvider.init(); // Update email subscription if necessary
        this.initPushNotifications();
        if (profile) {
            this.logger.info('Profile exists.');
            this.rootPage = __WEBPACK_IMPORTED_MODULE_34__pages_tabs_tabs__["a" /* TabsPage */];
            if (this.platform.is('cordova')) {
                this.handleDeepLinks();
            }
            if (this.isNodeWebkit()) {
                this.handleDeepLinksNW();
            }
        }
        else {
            this.logger.info('No profile exists.');
            this.profile.createProfile();
            this.rootPage = __WEBPACK_IMPORTED_MODULE_28__pages_onboarding_onboarding__["a" /* OnboardingPage */];
        }
    }
    openLockModal() {
        if (this.isModalOpen)
            return;
        let config = this.configProvider.get();
        let lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod)
            return;
        if (lockMethod == 'pin')
            this.openPINModal('checkPin');
        if (lockMethod == 'fingerprint')
            this.openFingerprintModal();
    }
    openPINModal(action) {
        this.isModalOpen = true;
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_30__pages_pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present({ animate: false });
        modal.onDidDismiss(() => {
            this.isModalOpen = false;
        });
    }
    openFingerprintModal() {
        this.isModalOpen = true;
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_23__pages_fingerprint_fingerprint__["a" /* FingerprintModalPage */], {}, { cssClass: 'fullscreen-modal' });
        modal.present({ animate: false });
        modal.onDidDismiss(() => {
            this.isModalOpen = false;
        });
    }
    registerIntegrations() {
        // Mercado Libre
        if (this.appProvider.info._enabledExtensions.mercadolibre)
            this.mercadoLibreProvider.register();
        // Amazon Gift Cards
        if (this.appProvider.info._enabledExtensions.amazon)
            this.amazonProvider.register();
        // ShapeShift
        if (this.appProvider.info._enabledExtensions.shapeshift)
            this.shapeshiftProvider.register();
        // Glidera
        if (this.appProvider.info._enabledExtensions.glidera) {
            this.glideraProvider.setCredentials();
            this.glideraProvider.register();
        }
        // Coinbase
        if (this.appProvider.info._enabledExtensions.coinbase) {
            this.coinbaseProvider.setCredentials();
            this.coinbaseProvider.register();
        }
        // BitPay Card
        if (this.appProvider.info._enabledExtensions.debitcard)
            this.bitPayCardProvider.register();
    }
    incomingDataRedirEvent() {
        this.events.subscribe('IncomingDataRedir', nextView => {
            const tabNav = this.getSelectedTabNav();
            tabNav.push(this.pageMap[nextView.name], nextView.params);
        });
    }
    initPushNotifications() {
        this.events.subscribe('OpenWalletEvent', nextView => {
            this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_34__pages_tabs_tabs__["a" /* TabsPage */]);
            this.nav.push(this.pageMap[nextView.name], nextView.params);
        });
        this.pushNotificationsProvider.init();
    }
    handleDeepLinks() {
        // Check if app was resume by custom url scheme
        window.handleOpenURL = (url) => {
            this.logger.info('App was resumed by custom url scheme');
            this.handleOpenUrl(url);
        };
        // Check if app was opened by custom url scheme
        const lastUrl = window.handleOpenURL_LastURL || '';
        if (lastUrl && lastUrl !== '') {
            delete window.handleOpenURL_LastURL;
            setTimeout(() => {
                this.logger.info('App was opened by custom url scheme');
                this.handleOpenUrl(lastUrl);
            }, 0);
        }
    }
    handleOpenUrl(url) {
        if (!this.incomingDataProvider.redir(url)) {
            this.logger.warn('Unknown URL! : ' + url);
        }
    }
    handleDeepLinksNW() {
        var gui = window.require('nw.gui');
        // This event is sent to an existent instance of Copay (only for standalone apps)
        gui.App.on('open', this.onOpenNW.bind(this));
        // Used at the startup of Copay
        var argv = gui.App.argv;
        if (argv && argv[0] && !window._urlHandled) {
            window._urlHandled = true;
            this.handleOpenUrl(argv[0]);
        }
    }
    onOpenNW(pathData) {
        if (pathData.indexOf('bastojicash:/') != -1) {
            this.logger.debug('Bastoji Cash URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bastojicash:/')));
        }
        else if (pathData.indexOf('bastoji:/') != -1) {
            this.logger.debug('Bastoji URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf('bastoji:/')));
        }
        else if (pathData.indexOf(this.appProvider.info.name + '://') != -1) {
            this.logger.debug(this.appProvider.info.name + ' URL found');
            this.handleOpenUrl(pathData.substring(pathData.indexOf(this.appProvider.info.name + '://')));
        }
        else {
            this.logger.debug('URL found');
            this.handleOpenUrl(pathData);
        }
    }
    isNodeWebkit() {
        let isNode = typeof process !== 'undefined' && "function" !== 'undefined';
        if (isNode) {
            try {
                return typeof window.require('nw.gui') !== 'undefined';
            }
            catch (e) {
                return false;
            }
        }
        return false;
    }
    getSelectedTabNav() {
        return this.nav
            .getActiveChildNavs()[0]
            .viewCtrl.instance.tabs.getSelected();
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('appNav'),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["k" /* NavController */])
], CopayApp.prototype, "nav", void 0);
CopayApp = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/app/app.html"*/'<ion-nav #appNav [root]="rootPage"></ion-nav>\n<wallet-selector></wallet-selector>\n<incoming-data-menu></incoming-data-menu>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/app/app.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__["b" /* TouchIdProvider */]]
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4_ionic_angular__["n" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_13__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_11__providers_glidera_glidera__["a" /* GlideraProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_amazon_amazon__["a" /* AmazonProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_mercado_libre_mercado_libre__["a" /* MercadoLibreProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ionic_native_screen_orientation__["a" /* ScreenOrientation */],
        __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_12__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */]])
], CopayApp);

//# sourceMappingURL=app.component.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(34)))

/***/ }),

/***/ 1008:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FileStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__istorage__ = __webpack_require__(642);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





let FileStorage = class FileStorage {
    constructor(file, log) {
        this.file = file;
        this.log = log;
    }
    init() {
        return new Promise((resolve, reject) => {
            if (this.fs && this.dir)
                return resolve();
            let onSuccess = (fs) => {
                this.log.debug('File system started: ', fs.name, fs.root.name);
                this.fs = fs;
                return this.getDir().then(dir => {
                    if (!dir.nativeURL)
                        return reject();
                    this.dir = dir;
                    this.log.debug('Got main dir:', dir.nativeURL);
                    return resolve();
                });
            };
            let onFailure = (err) => {
                this.log.error('Could not init file system: ' + err.message);
                return Promise.reject(err);
            };
            window.requestFileSystem(1, 0, onSuccess, onFailure);
        });
    }
    // See https://github.com/apache/cordova-plugin-file/#where-to-store-files
    getDir() {
        if (!this.file) {
            return Promise.reject(new Error('Could not write on device storage'));
        }
        var url = this.file.dataDirectory;
        return this.file.resolveDirectoryUrl(url).catch(err => {
            let msg = 'Could not resolve filesystem ' + url;
            this.log.warn(msg, err);
            throw err || new Error(msg);
        });
    }
    parseResult(v) {
        if (!v)
            return null;
        if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    readFileEntry(fileEntry) {
        return new Promise((resolve, reject) => {
            fileEntry.file(file => {
                var reader = new FileReader();
                reader.onerror = () => {
                    reader.abort();
                    return reject();
                };
                reader.onloadend = () => {
                    return resolve(this.parseResult(reader.result));
                };
                reader.readAsText(file);
            });
        });
    }
    get(k) {
        return new Promise(resolve => {
            this.init()
                .then(() => {
                this.file
                    .getFile(this.dir, k, { create: false })
                    .then(fileEntry => {
                    if (!fileEntry)
                        return resolve();
                    this.readFileEntry(fileEntry)
                        .then(result => {
                        return resolve(result);
                    })
                        .catch(() => {
                        this.log.error('Problem parsing input file.');
                    });
                })
                    .catch(err => {
                    // Not found
                    if (err.code == 1)
                        return resolve();
                    else
                        throw err;
                });
            })
                .catch(err => {
                this.log.error(err);
            });
        });
    }
    set(k, v) {
        return Promise.resolve(this.init().then(() => {
            this.file.getFile(this.dir, k, { create: true }).then(fileEntry => {
                // Create a FileWriter object for our FileEntry (log.txt).
                return new Promise((resolve, reject) => {
                    fileEntry.createWriter(fileWriter => {
                        fileWriter.onwriteend = () => {
                            this.log.info('Write completed:' + k);
                            return resolve();
                        };
                        fileWriter.onerror = e => {
                            this.log.error('Write failed', e);
                            return reject();
                        };
                        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](v))
                            v = JSON.stringify(v);
                        if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](v))
                            v = v.toString();
                        fileWriter.write(v);
                    });
                });
            });
        }));
    }
    remove(k) {
        return new Promise((resolve, reject) => {
            this.file
                .removeFile(this.dir.nativeURL, k)
                .then(() => {
                this.log.debug('File removed: ' + k);
                resolve();
            })
                .catch(e => {
                this.log.error('Error removing file', e);
                reject(e);
            });
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new __WEBPACK_IMPORTED_MODULE_4__istorage__["a" /* KeyAlreadyExistsError */]();
            this.set(k, v);
        });
    }
};
FileStorage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["a" /* File */], __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */]])
], FileStorage);

//# sourceMappingURL=file-storage.js.map

/***/ }),

/***/ 1009:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LocalStorage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__istorage__ = __webpack_require__(642);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers


let LocalStorage = class LocalStorage {
    constructor(platformProvider, logger) {
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.ls =
            typeof window.localStorage !== 'undefined' ? window.localStorage : null;
        if (!this.ls)
            throw new Error('localstorage not available');
        if (this.platformProvider.isNW) {
            this.logger.info('Overwritting localstorage with chrome storage for NW.JS');
            let ts = this.ls.getItem('migrationToChromeStorage');
            let p = this.ls.getItem('profile');
            // Need migration?
            if (!ts && p) {
                this.logger.info('### MIGRATING DATA! TO CHROME STORAGE');
                let j = 0;
                for (let i = 0; i < localStorage.length; i++) {
                    let k = this.ls.key(i);
                    let v = this.ls.getItem(k);
                    this.logger.debug('   Key: ' + k);
                    this.set(k, v).then(() => {
                        j++;
                        if (j == localStorage.length) {
                            this.logger.info('### MIGRATION DONE');
                            this.ls.setItem('migrationToChromeStorage', Date.now().toString());
                            this.ls = chrome.storage.local;
                        }
                    });
                }
            }
            else if (p) {
                this.logger.info('# Data already migrated to Chrome storage on ' + ts);
            }
        }
    }
    processingData(v) {
        if (!v)
            return null;
        if (!__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](v))
            return v;
        let parsed;
        try {
            parsed = JSON.parse(v);
        }
        catch (e) {
            // TODO parse is not necessary
        }
        return parsed || v;
    }
    get(k) {
        return new Promise(resolve => {
            if (this.platformProvider.isNW) {
                chrome.storage.local.get(k, data => {
                    let v = data[k];
                    return resolve(this.processingData(v));
                });
            }
            else {
                let v = this.ls.getItem(k);
                return resolve(this.processingData(v));
            }
        });
    }
    set(k, v) {
        return new Promise(resolve => {
            if (__WEBPACK_IMPORTED_MODULE_1_lodash__["isObject"](v))
                v = JSON.stringify(v);
            if (!__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](v))
                v = v.toString();
            if (this.platformProvider.isNW) {
                let obj = {};
                obj[k] = v;
                chrome.storage.local.set(obj);
            }
            else {
                this.ls.setItem(k, v);
            }
            resolve();
        });
    }
    remove(k) {
        return new Promise(resolve => {
            if (this.platformProvider.isNW) {
                chrome.storage.local.remove(k);
            }
            else {
                this.ls.removeItem(k);
            }
            resolve();
        });
    }
    create(k, v) {
        return this.get(k).then(data => {
            if (data)
                throw new __WEBPACK_IMPORTED_MODULE_2__istorage__["a" /* KeyAlreadyExistsError */]();
            this.set(k, v);
        });
    }
};
LocalStorage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__logger_logger__["a" /* Logger */]])
], LocalStorage);

//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ 1013:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1014:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 103:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__app_identity_app_identity__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__bitpay_bitpay__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_moment__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers








let BitPayCardProvider = class BitPayCardProvider {
    constructor(logger, bitPayProvider, appIdentityProvider, onGoingProcessProvider, persistenceProvider, configProvider, homeIntegrationsProvider) {
        this.logger = logger;
        this.bitPayProvider = bitPayProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger.info('BitPayCardProvider initialized');
    }
    isActive(cb) {
        this.getCards(cards => {
            return cb(!__WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](cards));
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        var error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
    _buildDate(date, time) {
        date = date.match(/(\d{2})\/(\d{2})\/(\d{4})/);
        time = time.match(/(\d{2})(\d{2})(\d{2})/);
        var newDate = new Date(date[1] + '/' + date[2] + '/' + date[3]);
        newDate.setHours(time[1], time[2], time[3]);
        return newDate;
    }
    _lowercaseMerchant(merchant) {
        if (merchant.name && merchant.name.toLowerCase) {
            merchant.name = merchant.name.toLowerCase();
        }
        if (merchant.city && merchant.city.toLowerCase) {
            merchant.city = merchant.city.toLowerCase();
        }
        return merchant;
    }
    _getMerchantInfo(tx) {
        var bpTranCodesTemp = bpTranCodes;
        __WEBPACK_IMPORTED_MODULE_8_lodash__["keys"](bpTranCodesTemp).forEach(code => {
            if (tx.type.indexOf(code) === 0) {
                __WEBPACK_IMPORTED_MODULE_8_lodash__["assign"](tx, bpTranCodesTemp[code]);
            }
        });
        return tx;
    }
    _getIconName(tx) {
        var icon = tx.mcc || tx.category || null;
        if (!icon || iconMap[icon] == undefined)
            return 'default';
        return iconMap[icon];
    }
    _processDescription(tx) {
        if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isArray"](tx.description)) {
            return tx.description[0];
        }
        return tx.description;
    }
    _processLocation(tx) {
        if (tx.merchant.city && tx.merchant.state) {
            return tx.merchant.city + ', ' + tx.merchant.state;
        }
        else {
            return tx.merchant.city || tx.merchant.state || '';
        }
    }
    _fromTransaction(txn, runningBalance) {
        var dateTime = this._buildDate(txn.date, txn.time);
        var merchant = this._lowercaseMerchant(txn.merchant);
        return this._getMerchantInfo({
            date: txn.timestamp || dateTime,
            category: txn.mcc,
            merchant,
            description: txn.description[0],
            price: parseFloat(txn.amount) + parseFloat(txn.fee),
            type: txn.type,
            runningBalance
        });
    }
    _processTransactions(invoices, history) {
        var balance = history.endingBalance || history.currentCardBalance;
        var runningBalance = parseFloat(balance);
        var activityList = [];
        if (history && history.transactionList) {
            for (let j = 0; j < history.transactionList.length; j++) {
                runningBalance -= parseFloat(history.transactionList[j].amount);
                activityList.push(this._fromTransaction(history.transactionList[j], runningBalance));
            }
        }
        if (activityList.length > 0) {
            invoices = invoices || [];
            for (let i = 0; i < invoices.length; i++) {
                var matched = false;
                for (let j = 0; j < history.transactionList.length; j++) {
                    var description = history.transactionList[j].description;
                    for (let k = 0; k < description.length; k++) {
                        if (description[k] && description[k].indexOf(invoices[i].id) > -1) {
                            matched = true;
                        }
                    }
                }
                var isInvoiceLessThanOneDayOld = __WEBPACK_IMPORTED_MODULE_9_moment__() < __WEBPACK_IMPORTED_MODULE_9_moment__(new Date(invoices[i].invoiceTime)).add(1, 'day');
                if (!matched && isInvoiceLessThanOneDayOld) {
                    var isInvoiceUnderpaid = invoices[i].exceptionStatus === 'paidPartial';
                    if (['paid', 'confirmed', 'complete'].indexOf(invoices[i].status) >=
                        0 ||
                        (invoices[i].status === 'invalid' || isInvoiceUnderpaid)) {
                        activityList.unshift(this._getMerchantInfo({
                            date: new Date(invoices[i].invoiceTime),
                            category: '',
                            merchant: '',
                            description: invoices[i].itemDesc,
                            price: invoices[i].price,
                            type: '00611 = Client Funded Deposit',
                            runningBalance: null,
                            pending: true,
                            transactionId: invoices[i].transactions && invoices[i].transactions[0]
                                ? invoices[i].transactions[0].txid
                                : ''
                        }));
                    }
                }
            }
        }
        for (let i = 0; i < activityList.length; i++) {
            activityList[i].icon = this._getIconName(activityList[i]);
            activityList[i].desc = this._processDescription(activityList[i]);
            activityList[i].merchant['location'] = this._processLocation(activityList[i]);
        }
        return activityList;
    }
    filterTransactions(type, txns) {
        var list, getPreAuth = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](txns, txn => {
            return txn.type.indexOf('93') > -1;
        }), getPending = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](txns, txn => {
            return txn.pending;
        }), getCompleted = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](txns, txn => {
            return !txn.pending && txn.type.indexOf('93') == -1;
        });
        switch (type) {
            case 'preAuth':
                list = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](getPreAuth);
                break;
            case 'confirming':
                list = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](getPending);
                break;
            case 'completed':
                list = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](getCompleted);
                break;
            default:
                // code...
                break;
        }
        return list;
    }
    sync(apiContext, cb) {
        var json = {
            method: 'getDebitCards'
        };
        this.onGoingProcessProvider.set('fetchingBitPayCards');
        // Get Debit Cards
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error) {
                this.onGoingProcessProvider.clear();
                return cb(data.error);
            }
            this.logger.info('BitPay Get Debit Cards: SUCCESS');
            var cards = [];
            __WEBPACK_IMPORTED_MODULE_8_lodash__["each"](data.data, x => {
                var n = {};
                if (!x.eid || !x.id || !x.lastFourDigits || !x.token) {
                    this.logger.warn('BAD data from BitPay card' + JSON.stringify(x));
                    return;
                }
                n.eid = x.eid;
                n.id = x.id;
                n.lastFourDigits = x.lastFourDigits;
                n.token = x.token;
                n.currency = x.currency;
                n.country = x.country;
                cards.push(n);
            });
            this.persistenceProvider
                .setBitpayDebitCards(this.bitPayProvider.getEnvironment().network, apiContext.pairData.email, cards)
                .then(() => {
                this.onGoingProcessProvider.clear();
                return cb(null, cards);
            });
        }, data => {
            this.onGoingProcessProvider.clear();
            return cb(this._setError('BitPay Card Error: Get Debit Cards', data));
        });
    }
    setCurrencySymbol(card) {
        // Sets a currency symbol.
        // Uses the currency code if no symbol is mapped (should never happen).
        // Backwards compatibility for FirstView cards (all USD).
        // This avoids users having to re-pair their account.
        if (!card.currency) {
            card.currency = 'USD';
        }
        card.currencySymbol = currencySymbols[card.currency] || card.currency + ' ';
    }
    // opts: range
    getHistory(cardId, opts, cb) {
        var invoices, history;
        opts = opts || {};
        var json = {
            method: 'getInvoiceHistory'
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_8_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                // Get invoices
                this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                    this.logger.info('BitPay Get Invoices: SUCCESS');
                    invoices = data.data || [];
                    if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](invoices))
                        this.logger.info('No invoices');
                    json = {
                        method: 'getTransactionHistory',
                        params: JSON.stringify(opts)
                    };
                    // Get transactions History list
                    this.bitPayProvider.post('/api/v2/' + card.token, json, data => {
                        this.logger.info('BitPay Get History: SUCCESS');
                        history = data.data || {};
                        history['txs'] = this._processTransactions(invoices, history);
                        this.setLastKnownBalance(cardId, history.currentCardBalance);
                        return cb(data.error, history);
                    }, data => {
                        return cb(this._setError('BitPay Card Error: Get History', data));
                    });
                }, data => {
                    return cb(this._setError('BitPay Card Error: Get Invoices', data));
                });
            });
        });
    }
    topUp(cardId, opts, cb) {
        opts = opts || {};
        var json = {
            method: 'generateTopUpInvoice',
            params: JSON.stringify(opts)
        };
        this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, err => {
            if (err)
                return cb(err);
            this.getCards(data => {
                var card = __WEBPACK_IMPORTED_MODULE_8_lodash__["find"](data, {
                    id: cardId
                });
                if (!card)
                    return cb(this._setError('Card not found'));
                this.bitPayProvider.post('/api/v2/' + card.token, json, res => {
                    if (res.error) {
                        this.logger.error('BitPay TopUp: With Errors');
                        return cb(res.error);
                    }
                    else {
                        this.logger.info('BitPay TopUp: SUCCESS');
                        return cb(null, res.data.invoice);
                    }
                }, res => {
                    return cb(this._setError('BitPay Card Error: TopUp', res));
                });
            });
        });
    }
    getInvoice(id, cb) {
        this.bitPayProvider.get('/invoices/' + id, res => {
            this.logger.info('BitPay Get Invoice: SUCCESS');
            return cb(res.error, res.data);
        }, res => {
            return cb(this._setError('BitPay Card Error: Get Invoice', res));
        });
    }
    // get all cards, for all accounts.
    getCards(cb) {
        this.persistenceProvider
            .getBitpayDebitCards(this.bitPayProvider.getEnvironment().network)
            .then(val => {
            return cb(val);
        });
    }
    getLastKnownBalance(cardId, cb) {
        this.persistenceProvider.getBalanceCache(cardId).then(val => {
            return cb(val);
        });
    }
    addLastKnownBalance(card, cb) {
        var now = Math.floor(Date.now() / 1000);
        var showRange = 600; // 10min;
        this.getLastKnownBalance(card.eid, data => {
            if (data) {
                card.balance = Number(data.balance);
                card.updatedOn =
                    data.updatedOn < now - showRange ? data.updatedOn : null;
            }
            return cb();
        });
    }
    setLastKnownBalance(cardId, balance) {
        this.persistenceProvider.setBalanceCache(cardId, {
            balance,
            updatedOn: Math.floor(Date.now() / 1000)
        });
    }
    remove(cardId, cb) {
        this.persistenceProvider
            .removeBitpayDebitCard(this.bitPayProvider.getEnvironment().network, cardId)
            .then(() => {
            this.persistenceProvider.removeBalanceCache(cardId);
            return cb();
        })
            .catch(err => {
            this.logger.error('Error removing BitPay debit card: ' + err);
            return cb(err);
        });
    }
    getRates(currency, cb) {
        this.bitPayProvider.get('/rates/' + currency, data => {
            this.logger.info('BitPay Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('BitPay Error: Get Rates', data));
        });
    }
    getRatesFromCoin(coin, currency, cb) {
        this.bitPayProvider.get('/rates/' + coin + '/' + currency, data => {
            this.logger.info('BitPay Get Rates: SUCCESS');
            return cb(data.error, data.data);
        }, data => {
            return cb(this._setError('BitPay Error: Get Rates', data));
        });
    }
    get(opts, cb) {
        this.getCards(cards => {
            if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](cards)) {
                this.homeIntegrationsProvider.updateLink('debitcard', null); // Name, linked
                return cb();
            }
            this.homeIntegrationsProvider.updateLink('debitcard', true); // Name, linked
            if (opts.cardId) {
                cards = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](cards, x => {
                    return opts.cardId == x.eid;
                });
            }
            // Async, no problem
            __WEBPACK_IMPORTED_MODULE_8_lodash__["each"](cards, x => {
                this.setCurrencySymbol(x);
                this.addLastKnownBalance(x, () => { });
                // async refresh
                if (!opts.noRefresh) {
                    this.getHistory(x.id, {}, err => {
                        if (err)
                            return;
                        this.addLastKnownBalance(x, () => { });
                    });
                }
            });
            return cb(null, cards);
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'debitcard',
                title: 'BitPay Visa Card',
                icon: 'assets/img/bitpay-card/icon-bitpay.svg',
                page: 'BitPayCardIntroPage',
                show: !!this.configProvider.get().showIntegration['debitcard'],
                linked: !!isActive
            });
        });
    }
};
BitPayCardProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_2__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_6__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], BitPayCardProvider);

/*
 * CONSTANTS
 */
const currencySymbols = {
    EUR: '',
    GBP: '',
    USD: '$'
};
const bpTranCodes = {
    '00611': {
        merchant: {
            name: 'BitPay',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    '602': {
        merchant: {
            name: 'ATM Withdrawal Fee'
        },
        category: 'bp002',
        description: ''
    },
    '604': {
        merchant: {
            name: 'Foreign Transaction Fee'
        },
        category: 'bp002',
        description: ''
    },
    '606': {
        merchant: {
            name: 'International ATM Fee'
        },
        category: 'bp002',
        description: ''
    },
    '00240': {
        merchant: {
            name: 'ACH Debit Fee'
        },
        category: 'bp002',
        description: ''
    },
    '5032': {
        merchant: {
            name: 'ACH Debit'
        },
        category: 'bp002',
        description: ''
    },
    '37': {
        merchant: {
            name: 'ACH / Payroll Deposit'
        },
        category: 'bp002',
        description: ''
    },
    '10036': {
        merchant: {
            name: 'Inactivity Fee (90 days)'
        },
        category: 'bp002',
        description: ''
    },
    load: {
        merchant: {
            name: 'BitPay',
            city: 'Atlanta',
            state: 'GA'
        },
        category: 'bp001',
        description: 'Top-Up'
    },
    'unload | pos': {
        description: 'Purchase'
    },
    'unload | epos': {
        description: 'Online Purchase'
    },
    transactionfee: {
        merchant: {
            name: 'Transaction Fee'
        },
        category: 'bp002',
        description: ''
    }
};
const iconMap = {
    742: 'medical',
    763: 'plant',
    780: 'plant',
    1520: 'repair',
    1711: 'repair',
    1731: 'repair',
    1740: 'repair',
    1750: 'repair',
    1761: 'repair',
    1771: 'repair',
    1799: 'repair',
    2741: 'books',
    2791: 'books',
    2842: 'clean',
    3000: 'airplane',
    3001: 'airplane',
    3002: 'airplane',
    3003: 'airplane',
    3004: 'airplane',
    3005: 'airplane',
    3006: 'airplane',
    3007: 'airplane',
    3008: 'airplane',
    3009: 'airplane',
    3010: 'airplane',
    3011: 'airplane',
    3012: 'airplane',
    3013: 'airplane',
    3014: 'airplane',
    3015: 'airplane',
    3016: 'airplane',
    3017: 'airplane',
    3018: 'airplane',
    3019: 'airplane',
    3020: 'airplane',
    3021: 'airplane',
    3022: 'airplane',
    3023: 'airplane',
    3024: 'airplane',
    3025: 'airplane',
    3026: 'airplane',
    3027: 'airplane',
    3028: 'airplane',
    3029: 'airplane',
    3030: 'airplane',
    3031: 'airplane',
    3032: 'airplane',
    3033: 'airplane',
    3034: 'airplane',
    3035: 'airplane',
    3036: 'airplane',
    3037: 'airplane',
    3038: 'airplane',
    3039: 'airplane',
    3040: 'airplane',
    3041: 'airplane',
    3042: 'airplane',
    3043: 'airplane',
    3044: 'airplane',
    3045: 'airplane',
    3046: 'airplane',
    3047: 'airplane',
    3048: 'airplane',
    3049: 'airplane',
    3050: 'airplane',
    3051: 'airplane',
    3052: 'airplane',
    3053: 'airplane',
    3054: 'airplane',
    3055: 'airplane',
    3056: 'airplane',
    3057: 'airplane',
    3058: 'airplane',
    3059: 'airplane',
    3060: 'airplane',
    3061: 'airplane',
    3062: 'airplane',
    3063: 'airplane',
    3064: 'airplane',
    3065: 'airplane',
    3066: 'airplane',
    3067: 'airplane',
    3068: 'airplane',
    3069: 'airplane',
    3070: 'airplane',
    3071: 'airplane',
    3072: 'airplane',
    3073: 'airplane',
    3074: 'airplane',
    3075: 'airplane',
    3076: 'airplane',
    3077: 'airplane',
    3078: 'airplane',
    3079: 'airplane',
    3080: 'airplane',
    3081: 'airplane',
    3082: 'airplane',
    3083: 'airplane',
    3084: 'airplane',
    3085: 'airplane',
    3086: 'airplane',
    3087: 'airplane',
    3088: 'airplane',
    3089: 'airplane',
    3090: 'airplane',
    3091: 'airplane',
    3092: 'airplane',
    3093: 'airplane',
    3094: 'airplane',
    3095: 'airplane',
    3096: 'airplane',
    3097: 'airplane',
    3098: 'airplane',
    3099: 'airplane',
    3100: 'airplane',
    3101: 'airplane',
    3102: 'airplane',
    3103: 'airplane',
    3104: 'airplane',
    3105: 'airplane',
    3106: 'airplane',
    3107: 'airplane',
    3108: 'airplane',
    3109: 'airplane',
    3110: 'airplane',
    3111: 'airplane',
    3112: 'airplane',
    3113: 'airplane',
    3114: 'airplane',
    3115: 'airplane',
    3116: 'airplane',
    3117: 'airplane',
    3118: 'airplane',
    3119: 'airplane',
    3120: 'airplane',
    3121: 'airplane',
    3122: 'airplane',
    3123: 'airplane',
    3124: 'airplane',
    3125: 'airplane',
    3126: 'airplane',
    3127: 'airplane',
    3128: 'airplane',
    3129: 'airplane',
    3130: 'airplane',
    3131: 'airplane',
    3132: 'airplane',
    3133: 'airplane',
    3134: 'airplane',
    3135: 'airplane',
    3136: 'airplane',
    3137: 'airplane',
    3138: 'airplane',
    3139: 'airplane',
    3140: 'airplane',
    3141: 'airplane',
    3142: 'airplane',
    3143: 'airplane',
    3144: 'airplane',
    3145: 'airplane',
    3146: 'airplane',
    3147: 'airplane',
    3148: 'airplane',
    3149: 'airplane',
    3150: 'airplane',
    3151: 'airplane',
    3152: 'airplane',
    3153: 'airplane',
    3154: 'airplane',
    3155: 'airplane',
    3156: 'airplane',
    3157: 'airplane',
    3158: 'airplane',
    3159: 'airplane',
    3160: 'airplane',
    3161: 'airplane',
    3162: 'airplane',
    3163: 'airplane',
    3164: 'airplane',
    3165: 'airplane',
    3166: 'airplane',
    3167: 'airplane',
    3168: 'airplane',
    3169: 'airplane',
    3170: 'airplane',
    3171: 'airplane',
    3172: 'airplane',
    3173: 'airplane',
    3174: 'airplane',
    3175: 'airplane',
    3176: 'airplane',
    3177: 'airplane',
    3178: 'airplane',
    3179: 'airplane',
    3180: 'airplane',
    3181: 'airplane',
    3182: 'airplane',
    3183: 'airplane',
    3184: 'airplane',
    3185: 'airplane',
    3186: 'airplane',
    3187: 'airplane',
    3188: 'airplane',
    3189: 'airplane',
    3190: 'airplane',
    3191: 'airplane',
    3192: 'airplane',
    3193: 'airplane',
    3194: 'airplane',
    3195: 'airplane',
    3196: 'airplane',
    3197: 'airplane',
    3198: 'airplane',
    3199: 'airplane',
    3200: 'airplane',
    3201: 'airplane',
    3202: 'airplane',
    3203: 'airplane',
    3204: 'airplane',
    3205: 'airplane',
    3206: 'airplane',
    3207: 'airplane',
    3208: 'airplane',
    3209: 'airplane',
    3210: 'airplane',
    3211: 'airplane',
    3212: 'airplane',
    3213: 'airplane',
    3214: 'airplane',
    3215: 'airplane',
    3216: 'airplane',
    3217: 'airplane',
    3218: 'airplane',
    3219: 'airplane',
    3220: 'airplane',
    3221: 'airplane',
    3222: 'airplane',
    3223: 'airplane',
    3224: 'airplane',
    3225: 'airplane',
    3226: 'airplane',
    3227: 'airplane',
    3228: 'airplane',
    3229: 'airplane',
    3230: 'airplane',
    3231: 'airplane',
    3232: 'airplane',
    3233: 'airplane',
    3234: 'airplane',
    3235: 'airplane',
    3236: 'airplane',
    3237: 'airplane',
    3238: 'airplane',
    3239: 'airplane',
    3240: 'airplane',
    3241: 'airplane',
    3242: 'airplane',
    3243: 'airplane',
    3244: 'airplane',
    3245: 'airplane',
    3246: 'airplane',
    3247: 'airplane',
    3248: 'airplane',
    3249: 'airplane',
    3250: 'airplane',
    3251: 'airplane',
    3252: 'airplane',
    3253: 'airplane',
    3254: 'airplane',
    3255: 'airplane',
    3256: 'airplane',
    3257: 'airplane',
    3258: 'airplane',
    3259: 'airplane',
    3260: 'airplane',
    3261: 'airplane',
    3262: 'airplane',
    3263: 'airplane',
    3264: 'airplane',
    3265: 'airplane',
    3266: 'airplane',
    3267: 'airplane',
    3268: 'airplane',
    3269: 'airplane',
    3270: 'airplane',
    3271: 'airplane',
    3272: 'airplane',
    3273: 'airplane',
    3274: 'airplane',
    3275: 'airplane',
    3276: 'airplane',
    3277: 'airplane',
    3278: 'airplane',
    3279: 'airplane',
    3280: 'airplane',
    3281: 'airplane',
    3282: 'airplane',
    3283: 'airplane',
    3284: 'airplane',
    3285: 'airplane',
    3286: 'airplane',
    3287: 'airplane',
    3288: 'airplane',
    3289: 'airplane',
    3290: 'airplane',
    3291: 'airplane',
    3292: 'airplane',
    3293: 'airplane',
    3294: 'airplane',
    3295: 'airplane',
    3296: 'airplane',
    3297: 'airplane',
    3298: 'airplane',
    3299: 'airplane',
    3351: 'car',
    3352: 'car',
    3353: 'car',
    3354: 'car',
    3355: 'car',
    3356: 'car',
    3357: 'car',
    3358: 'car',
    3359: 'car',
    3360: 'car',
    3361: 'car',
    3362: 'car',
    3363: 'car',
    3364: 'car',
    3365: 'car',
    3366: 'car',
    3367: 'car',
    3368: 'car',
    3369: 'car',
    3370: 'car',
    3371: 'car',
    3372: 'car',
    3373: 'car',
    3374: 'car',
    3375: 'car',
    3376: 'car',
    3377: 'car',
    3378: 'car',
    3379: 'car',
    3380: 'car',
    3381: 'car',
    3382: 'car',
    3383: 'car',
    3384: 'car',
    3385: 'car',
    3386: 'car',
    3387: 'car',
    3388: 'car',
    3389: 'car',
    3390: 'car',
    3391: 'car',
    3392: 'car',
    3393: 'car',
    3394: 'car',
    3395: 'car',
    3396: 'car',
    3397: 'car',
    3398: 'car',
    3399: 'car',
    3400: 'car',
    3401: 'car',
    3402: 'car',
    3403: 'car',
    3404: 'car',
    3405: 'car',
    3406: 'car',
    3407: 'car',
    3408: 'car',
    3409: 'car',
    3410: 'car',
    3411: 'car',
    3412: 'car',
    3413: 'car',
    3414: 'car',
    3415: 'car',
    3416: 'car',
    3417: 'car',
    3418: 'car',
    3419: 'car',
    3420: 'car',
    3421: 'car',
    3422: 'car',
    3423: 'car',
    3424: 'car',
    3425: 'car',
    3426: 'car',
    3427: 'car',
    3428: 'car',
    3429: 'car',
    3430: 'car',
    3431: 'car',
    3432: 'car',
    3433: 'car',
    3434: 'car',
    3435: 'car',
    3436: 'car',
    3437: 'car',
    3438: 'car',
    3439: 'car',
    3440: 'car',
    3441: 'car',
    3501: 'hotel',
    3502: 'hotel',
    3503: 'hotel',
    3504: 'hotel',
    3505: 'hotel',
    3506: 'hotel',
    3507: 'hotel',
    3508: 'hotel',
    3509: 'hotel',
    3510: 'hotel',
    3511: 'hotel',
    3512: 'hotel',
    3513: 'hotel',
    3514: 'hotel',
    3515: 'hotel',
    3516: 'hotel',
    3517: 'hotel',
    3518: 'hotel',
    3519: 'hotel',
    3520: 'hotel',
    3521: 'hotel',
    3522: 'hotel',
    3523: 'hotel',
    3524: 'hotel',
    3525: 'hotel',
    3526: 'hotel',
    3527: 'hotel',
    3528: 'hotel',
    3529: 'hotel',
    3530: 'hotel',
    3531: 'hotel',
    3532: 'hotel',
    3533: 'hotel',
    3534: 'hotel',
    3535: 'hotel',
    3536: 'hotel',
    3537: 'hotel',
    3538: 'hotel',
    3539: 'hotel',
    3540: 'hotel',
    3541: 'hotel',
    3542: 'hotel',
    3543: 'hotel',
    3544: 'hotel',
    3545: 'hotel',
    3546: 'hotel',
    3547: 'hotel',
    3548: 'hotel',
    3549: 'hotel',
    3550: 'hotel',
    3551: 'hotel',
    3552: 'hotel',
    3553: 'hotel',
    3554: 'hotel',
    3555: 'hotel',
    3556: 'hotel',
    3557: 'hotel',
    3558: 'hotel',
    3559: 'hotel',
    3560: 'hotel',
    3561: 'hotel',
    3562: 'hotel',
    3563: 'hotel',
    3564: 'hotel',
    3565: 'hotel',
    3566: 'hotel',
    3567: 'hotel',
    3568: 'hotel',
    3569: 'hotel',
    3570: 'hotel',
    3571: 'hotel',
    3572: 'hotel',
    3573: 'hotel',
    3574: 'hotel',
    3575: 'hotel',
    3576: 'hotel',
    3577: 'hotel',
    3578: 'hotel',
    3579: 'hotel',
    3580: 'hotel',
    3581: 'hotel',
    3582: 'hotel',
    3583: 'hotel',
    3584: 'hotel',
    3585: 'hotel',
    3586: 'hotel',
    3587: 'hotel',
    3588: 'hotel',
    3589: 'hotel',
    3590: 'hotel',
    3591: 'hotel',
    3592: 'hotel',
    3593: 'hotel',
    3594: 'hotel',
    3595: 'hotel',
    3596: 'hotel',
    3597: 'hotel',
    3598: 'hotel',
    3599: 'hotel',
    3600: 'hotel',
    3601: 'hotel',
    3602: 'hotel',
    3603: 'hotel',
    3604: 'hotel',
    3605: 'hotel',
    3606: 'hotel',
    3607: 'hotel',
    3608: 'hotel',
    3609: 'hotel',
    3610: 'hotel',
    3611: 'hotel',
    3612: 'hotel',
    3613: 'hotel',
    3614: 'hotel',
    3615: 'hotel',
    3616: 'hotel',
    3617: 'hotel',
    3618: 'hotel',
    3619: 'hotel',
    3620: 'hotel',
    3621: 'hotel',
    3622: 'hotel',
    3623: 'hotel',
    3624: 'hotel',
    3625: 'hotel',
    3626: 'hotel',
    3627: 'hotel',
    3628: 'hotel',
    3629: 'hotel',
    3630: 'hotel',
    3631: 'hotel',
    3632: 'hotel',
    3633: 'hotel',
    3634: 'hotel',
    3635: 'hotel',
    3636: 'hotel',
    3637: 'hotel',
    3638: 'hotel',
    3639: 'hotel',
    3640: 'hotel',
    3641: 'hotel',
    3642: 'hotel',
    3643: 'hotel',
    3644: 'hotel',
    3645: 'hotel',
    3646: 'hotel',
    3647: 'hotel',
    3648: 'hotel',
    3649: 'hotel',
    3650: 'hotel',
    3651: 'hotel',
    3652: 'hotel',
    3653: 'hotel',
    3654: 'hotel',
    3655: 'hotel',
    3656: 'hotel',
    3657: 'hotel',
    3658: 'hotel',
    3659: 'hotel',
    3660: 'hotel',
    3661: 'hotel',
    3662: 'hotel',
    3663: 'hotel',
    3664: 'hotel',
    3665: 'hotel',
    3666: 'hotel',
    3667: 'hotel',
    3668: 'hotel',
    3669: 'hotel',
    3670: 'hotel',
    3671: 'hotel',
    3672: 'hotel',
    3673: 'hotel',
    3674: 'hotel',
    3675: 'hotel',
    3676: 'hotel',
    3677: 'hotel',
    3678: 'hotel',
    3679: 'hotel',
    3680: 'hotel',
    3681: 'hotel',
    3682: 'hotel',
    3683: 'hotel',
    3684: 'hotel',
    3685: 'hotel',
    3686: 'hotel',
    3687: 'hotel',
    3688: 'hotel',
    3689: 'hotel',
    3690: 'hotel',
    3691: 'hotel',
    3692: 'hotel',
    3693: 'hotel',
    3694: 'hotel',
    3695: 'hotel',
    3696: 'hotel',
    3697: 'hotel',
    3698: 'hotel',
    3699: 'hotel',
    3700: 'hotel',
    3701: 'hotel',
    3702: 'hotel',
    3703: 'hotel',
    3704: 'hotel',
    3705: 'hotel',
    3706: 'hotel',
    3707: 'hotel',
    3708: 'hotel',
    3709: 'hotel',
    3710: 'hotel',
    3711: 'hotel',
    3712: 'hotel',
    3713: 'hotel',
    3714: 'hotel',
    3715: 'hotel',
    3716: 'hotel',
    3717: 'hotel',
    3718: 'hotel',
    3719: 'hotel',
    3720: 'hotel',
    3721: 'hotel',
    3722: 'hotel',
    3723: 'hotel',
    3724: 'hotel',
    3725: 'hotel',
    3726: 'hotel',
    3727: 'hotel',
    3728: 'hotel',
    3729: 'hotel',
    3730: 'hotel',
    3731: 'hotel',
    3732: 'hotel',
    3733: 'hotel',
    3734: 'hotel',
    3735: 'hotel',
    3736: 'hotel',
    3737: 'hotel',
    3738: 'hotel',
    3739: 'hotel',
    3740: 'hotel',
    3741: 'hotel',
    3742: 'hotel',
    3743: 'hotel',
    3744: 'hotel',
    3745: 'hotel',
    3746: 'hotel',
    3747: 'hotel',
    3748: 'hotel',
    3749: 'hotel',
    3750: 'hotel',
    3751: 'hotel',
    3752: 'hotel',
    3753: 'hotel',
    3754: 'hotel',
    3755: 'hotel',
    3756: 'hotel',
    3757: 'hotel',
    3758: 'hotel',
    3759: 'hotel',
    3760: 'hotel',
    3761: 'hotel',
    3762: 'hotel',
    3763: 'hotel',
    3764: 'hotel',
    3765: 'hotel',
    3766: 'hotel',
    3767: 'hotel',
    3768: 'hotel',
    3769: 'hotel',
    3770: 'hotel',
    3771: 'hotel',
    3772: 'hotel',
    3773: 'hotel',
    3774: 'hotel',
    3775: 'hotel',
    3776: 'hotel',
    3777: 'hotel',
    3778: 'hotel',
    3779: 'hotel',
    3780: 'hotel',
    3781: 'hotel',
    3782: 'hotel',
    3783: 'hotel',
    3784: 'hotel',
    3785: 'hotel',
    3786: 'hotel',
    3787: 'hotel',
    3788: 'hotel',
    3789: 'hotel',
    3790: 'hotel',
    3816: 'hotel',
    3835: 'hotel',
    4011: 'car',
    4111: 'car',
    4112: 'car',
    4119: 'car',
    4121: 'car',
    4131: 'car',
    4214: 'car',
    4215: 'bus',
    4225: 'default',
    4411: 'boat',
    4457: 'boat',
    4468: 'boat',
    4511: 'airplane',
    4582: 'airplane',
    4722: 'airplane',
    4723: 'airplane',
    4784: 'car',
    4789: 'car',
    4812: 'car',
    4814: 'telephone',
    4815: 'telephone',
    4816: 'computer',
    4821: 'money',
    4829: 'money',
    4899: 'television',
    4900: 'gas',
    5013: 'car',
    5021: 'default',
    5039: 'repair',
    5044: 'computer',
    5045: 'computer',
    5046: 'default',
    5047: 'medical',
    5051: 'default',
    5065: 'default',
    5072: 'default',
    5074: 'default',
    5085: 'default',
    5094: 'diamond-ring',
    5099: 'default',
    5111: 'default',
    5122: 'medical',
    5131: 'default',
    5137: 'shirt',
    5139: 'shoes',
    5169: 'gas',
    5172: 'gas',
    5192: 'books',
    5193: 'plant',
    5198: 'repair',
    5199: 'repair',
    5200: 'repair',
    5211: 'repair',
    5231: 'repair',
    5251: 'default',
    5261: 'plant',
    5271: 'bus',
    5300: 'purchase',
    5309: 'purchase',
    5310: 'purchase',
    5311: 'purchase',
    5331: 'purchase',
    5399: 'purchase',
    5411: 'food',
    5422: 'food',
    5441: 'food',
    5451: 'food',
    5462: 'food',
    5499: 'food',
    5511: 'car',
    5521: 'car',
    5531: 'car',
    5532: 'car',
    5533: 'car',
    5541: 'gas',
    5542: 'gas',
    5551: 'boat',
    5561: 'motorcycle',
    5571: 'motorcycle',
    5592: 'default',
    5598: 'default',
    5599: 'car',
    5611: 'shirt',
    5621: 'shirt',
    5631: 'shirt',
    5641: 'shirt',
    5651: 'shirt',
    5655: 'shirt',
    5661: 'shoes',
    5681: 'default',
    5691: 'shirt',
    5697: 'default',
    5698: 'default',
    5699: 'default',
    5712: 'default',
    5713: 'default',
    5714: 'default',
    5718: 'default',
    5719: 'default',
    5722: 'default',
    5732: 'computer',
    5733: 'music',
    5734: 'computer',
    5735: 'music',
    5811: 'food',
    5812: 'food',
    5813: 'cocktail',
    5814: 'food',
    5815: 'books',
    5816: 'computer',
    5817: 'default',
    5818: 'default',
    5832: 'default',
    5912: 'medical',
    5921: 'cocktail',
    5931: 'default',
    5932: 'default',
    5933: 'default',
    5935: 'default',
    5937: 'default',
    5940: 'bicycle',
    5941: 'bicycle',
    5942: 'books',
    5943: 'default',
    5944: 'clock',
    5945: 'toy',
    5946: 'camera',
    5947: 'default',
    5948: 'default',
    5949: 'default',
    5950: 'default',
    5960: 'default',
    5961: 'mail',
    5962: 'telephone',
    5963: 'default',
    5964: 'telephone',
    5965: 'telephone',
    5966: 'telephone',
    5967: 'telephone',
    5968: 'telephone',
    5969: 'telephone',
    5970: 'art',
    5971: 'art',
    5972: 'coins',
    5973: 'default',
    5975: 'default',
    5976: 'default',
    5977: 'default',
    5978: 'default',
    5983: 'gas',
    5992: 'plant',
    5993: 'default',
    5994: 'newspaper',
    5995: 'pet',
    5996: 'cocktail',
    5997: 'purchase',
    5998: 'tent',
    5999: 'money',
    6010: 'money',
    6011: 'money',
    6012: 'money',
    6051: 'money',
    6211: 'money',
    6300: 'money',
    6381: 'money',
    6399: 'repair',
    6513: 'repair',
    7011: 'hotel',
    7012: 'hotel',
    7032: 'park',
    7033: 'park',
    7210: 'shirt',
    7211: 'shirt',
    7216: 'shirt',
    7217: 'default',
    7221: 'camera',
    7230: 'scissors',
    7251: 'shoe',
    7261: 'sadface',
    7273: 'smiley-face',
    7276: 'money',
    7277: 'people',
    7278: 'people',
    7296: 'shirt',
    7297: 'smiley-face',
    7298: 'smiley-face',
    7299: 'default',
    7311: 'default',
    7321: 'default',
    7332: 'computer',
    7333: 'camera',
    7338: 'computer',
    7339: 'people',
    7342: 'bug',
    7349: 'default',
    7361: 'people',
    7372: 'computer',
    7375: 'computer',
    7379: 'computer',
    7392: 'people',
    7393: 'search',
    7394: 'default',
    7395: 'car',
    7399: 'car',
    7511: 'truck',
    7512: 'car',
    7513: 'truck',
    7519: 'truck',
    7523: 'car',
    7531: 'car',
    7534: 'car',
    7535: 'car',
    7538: 'car',
    7542: 'car',
    7549: 'truck',
    7622: 'television',
    7623: 'default',
    7629: 'default',
    7631: 'watch',
    7641: 'furniture',
    7692: 'default',
    7699: 'default',
    7800: 'money',
    7801: 'money',
    7802: 'money',
    7829: 'money',
    7832: 'film',
    7841: 'film',
    7911: 'music',
    7922: 'ticket',
    7929: 'ticket',
    7932: 'music',
    7933: 'bowling',
    7941: 'football',
    7991: 'people',
    7992: 'golf',
    7993: 'game',
    7994: 'game',
    7995: 'coins',
    7996: 'ticket',
    7997: 'money',
    7998: 'ticket',
    7999: 'people',
    8011: 'medical',
    8021: 'medical',
    8031: 'medical',
    8041: 'medical',
    8042: 'medical',
    8043: 'medical',
    8044: 'medical',
    8049: 'medical',
    8050: 'medical',
    8062: 'medical',
    8071: 'medical',
    8099: 'medical',
    8111: 'law',
    8211: 'books',
    8220: 'books',
    8241: 'books',
    8244: 'books',
    8249: 'books',
    8299: 'people',
    8351: 'people',
    8398: 'people',
    8641: 'people',
    8651: 'people',
    8661: 'people',
    8675: 'car',
    8699: 'people',
    8734: 'medical',
    8911: 'tree',
    8931: 'books',
    8999: 'suitcase',
    9211: 'law',
    9222: 'law',
    9223: 'law',
    9311: 'law',
    9399: 'default',
    9402: 'mail',
    9405: 'default',
    9700: 'default',
    9701: 'default',
    9702: 'default',
    9950: 'default',
    bp001: 'bastoji-topup',
    bp002: 'default'
};
//# sourceMappingURL=bitpay-card.js.map

/***/ }),

/***/ 11:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PopupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__components_mini_modal_mini_modal__ = __webpack_require__(713);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





let PopupProvider = class PopupProvider {
    constructor(alertCtrl, logger, modalCtrl, translate) {
        this.alertCtrl = alertCtrl;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
    }
    ionicAlert(title, subTitle, okText) {
        return new Promise(resolve => {
            let alert = this.alertCtrl.create({
                title,
                subTitle,
                enableBackdropDismiss: false,
                buttons: [
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Ok clicked');
                            resolve();
                        }
                    }
                ]
            });
            alert.present();
        });
    }
    ionicConfirm(title, message, okText, cancelText) {
        return new Promise(resolve => {
            let confirm = this.alertCtrl.create({
                title,
                message,
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Disagree clicked');
                            resolve(false);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: () => {
                            this.logger.info('Agree clicked');
                            resolve(true);
                        }
                    }
                ],
                enableBackdropDismiss: false
            });
            confirm.present();
        });
    }
    ionicPrompt(title, message, opts, okText, cancelText) {
        return new Promise(resolve => {
            let defaultText = opts && opts.defaultText ? opts.defaultText : null;
            let placeholder = opts && opts.placeholder ? opts.placeholder : null;
            let inputType = opts && opts.type ? opts.type : 'text';
            let cssClass = opts && opts.useDanger ? 'alertDanger' : null;
            let enableBackdropDismiss = !!(opts && opts.enableBackdropDismiss);
            let prompt = this.alertCtrl.create({
                title,
                message,
                cssClass,
                enableBackdropDismiss,
                inputs: [
                    {
                        value: defaultText,
                        placeholder,
                        type: inputType
                    }
                ],
                buttons: [
                    {
                        text: cancelText ? cancelText : this.translate.instant('Cancel'),
                        handler: () => {
                            this.logger.info('Cancel clicked');
                            resolve(null);
                        }
                    },
                    {
                        text: okText ? okText : this.translate.instant('Ok'),
                        handler: data => {
                            this.logger.info('Saved clicked');
                            resolve(data[0]);
                        }
                    }
                ]
            });
            prompt.present();
        });
    }
    createMiniModal(modalTitle) {
        return this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__components_mini_modal_mini_modal__["b" /* MiniModalComponent */], { modalTitle }, { cssClass: 'fullscreen-modal' });
    }
};
PopupProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], PopupProvider);

//# sourceMappingURL=popup.js.map

/***/ }),

/***/ 112:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EmailNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers




let EmailNotificationsProvider = class EmailNotificationsProvider {
    constructor(configProvider, profileProvider, walletProvider, logger) {
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.logger.info('EmailNotificationsProvider initialized');
    }
    updateEmail(opts) {
        opts = opts || {};
        if (!opts.email)
            return;
        this.configProvider.set({
            emailFor: null,
            emailNotifications: {
                enabled: opts.enabled,
                email: opts.enabled ? opts.email : null
            }
        });
        setTimeout(() => {
            let wallets = this.profileProvider.getWallets();
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
    getEmailIfEnabled(config) {
        config = config ? config : this.configProvider.get();
        if (config.emailNotifications) {
            if (!config.emailNotifications.enabled)
                return;
            if (config.emailNotifications.email)
                return config.emailNotifications.email;
        }
        if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](config.emailFor))
            return;
        // Backward compatibility
        let emails = __WEBPACK_IMPORTED_MODULE_5_lodash__["values"](config.emailFor);
        for (var i = 0; i < emails.length; i++) {
            if (emails[i] !== null && typeof emails[i] !== 'undefined') {
                return emails[i];
            }
        }
    }
    init() {
        let config = this.configProvider.get();
        if (config.emailNotifications && config.emailNotifications.enabled) {
            // If email already set
            if (config.emailNotifications.email)
                return;
            var currentEmail = this.getEmailIfEnabled(config);
            this.updateEmail({
                enabled: currentEmail ? true : false,
                email: currentEmail
            });
        }
    }
};
EmailNotificationsProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */]])
], EmailNotificationsProvider);

//# sourceMappingURL=email-notifications.js.map

/***/ }),

/***/ 113:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return RateProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__environments__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





let RateProvider = class RateProvider {
    constructor(http, logger) {
        this.http = http;
        this.logger = logger;
        this.rateServiceUrl = __WEBPACK_IMPORTED_MODULE_3__environments__["a" /* default */].ratesAPI.btc;
        this.bchRateServiceUrl = __WEBPACK_IMPORTED_MODULE_3__environments__["a" /* default */].ratesAPI.bch;
        this.logger.info('RateProvider initialized.');
        this.rates = {};
        this.alternatives = [];
        this.ratesBCH = {};
        this.SAT_TO_BTJ = 1 / 1e8;
        this.BTJ_TO_SAT = 1e8;
        this.ratesBtcAvailable = false;
        this.ratesBchAvailable = false;
        this.updateRatesBtc();
        this.updateRatesBch();
    }
    updateRatesBtc() {
        return new Promise((resolve, reject) => {
            this.getBTJ()
                .then(dataBTJ => {
                __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](dataBTJ, currency => {
                    this.rates[currency.code] = currency.rate;
                    this.alternatives.push({
                        name: currency.name,
                        isoCode: currency.code,
                        rate: currency.rate
                    });
                });
                this.ratesBtcAvailable = true;
                resolve();
            })
                .catch(errorBTJ => {
                this.logger.error(errorBTJ);
                reject(errorBTJ);
            });
        });
    }
    updateRatesBch() {
        return new Promise((resolve, reject) => {
            this.getBCH()
                .then(dataBCH => {
                __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](dataBCH, currency => {
                    this.ratesBCH[currency.code] = currency.rate;
                });
                this.ratesBchAvailable = true;
                resolve();
            })
                .catch(errorBCH => {
                this.logger.error(errorBCH);
                reject(errorBCH);
            });
        });
    }
    getBTJ() {
        return new Promise(resolve => {
            this.http.get(this.rateServiceUrl).subscribe(data => {
                resolve(data);
            });
        });
    }
    getBCH() {
        return new Promise(resolve => {
            this.http.get(this.bchRateServiceUrl).subscribe(data => {
                resolve(data);
            });
        });
    }
    getRate(code, chain) {
        if (chain == 'bch')
            return this.ratesBCH[code];
        else
            return this.rates[code];
    }
    getAlternatives() {
        return this.alternatives;
    }
    isBtcAvailable() {
        return this.ratesBtcAvailable;
    }
    isBchAvailable() {
        return this.ratesBchAvailable;
    }
    toFiat(satoshis, code, chain) {
        if ((!this.isBtcAvailable() && chain == 'btc') ||
            (!this.isBchAvailable() && chain == 'bch')) {
            return null;
        }
        return satoshis * this.SAT_TO_BTJ * this.getRate(code, chain);
    }
    fromFiat(amount, code, chain) {
        if ((!this.isBtcAvailable() && chain == 'btc') ||
            (!this.isBchAvailable() && chain == 'bch')) {
            return null;
        }
        return (amount / this.getRate(code, chain)) * this.BTJ_TO_SAT;
    }
    listAlternatives(sort) {
        let alternatives = __WEBPACK_IMPORTED_MODULE_2_lodash__["map"](this.getAlternatives(), (item) => {
            return {
                name: item.name,
                isoCode: item.isoCode
            };
        });
        if (sort) {
            alternatives.sort((a, b) => {
                return a.name.toLowerCase() > b.name.toLowerCase() ? 1 : -1;
            });
        }
        return __WEBPACK_IMPORTED_MODULE_2_lodash__["uniqBy"](alternatives, 'isoCode');
    }
    whenRatesAvailable(chain) {
        return new Promise(resolve => {
            if ((this.ratesBtcAvailable && chain == 'btc') ||
                (this.ratesBchAvailable && chain == 'bch'))
                resolve();
            else {
                if (chain == 'btc') {
                    this.updateRatesBtc().then(() => {
                        resolve();
                    });
                }
                if (chain == 'bch') {
                    this.updateRatesBch().then(() => {
                        resolve();
                    });
                }
            }
        });
    }
};
RateProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */]])
], RateProvider);

//# sourceMappingURL=rate.js.map

/***/ }),

/***/ 114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TouchIdErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return TouchIdProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_android_fingerprint_auth__ = __webpack_require__(714);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_touch_id__ = __webpack_require__(715);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers




var TouchIdErrors;
(function (TouchIdErrors) {
    TouchIdErrors["fingerprintCancelled"] = "FINGERPRINT_CANCELLED";
})(TouchIdErrors || (TouchIdErrors = {}));
let TouchIdProvider = class TouchIdProvider {
    constructor(app, touchId, androidFingerprintAuth, platform, config, logger) {
        this.app = app;
        this.touchId = touchId;
        this.androidFingerprintAuth = androidFingerprintAuth;
        this.platform = platform;
        this.config = config;
        this.logger = logger;
    }
    isAvailable() {
        return new Promise(resolve => {
            if (this.platform.isCordova && this.platform.isAndroid) {
                this.checkAndroid().then(isAvailable => {
                    return resolve(isAvailable);
                });
            }
            else if (this.platform.isCordova && this.platform.isIOS) {
                this.checkIOS().then(isAvailable => {
                    return resolve(isAvailable);
                });
            }
            else {
                return resolve(false);
            }
        });
    }
    checkIOS() {
        return new Promise(resolve => {
            this.touchId.isAvailable().then(() => {
                return resolve(true);
            }, () => {
                this.logger.debug('Fingerprint is not available');
                return resolve(false);
            });
        });
    }
    checkAndroid() {
        return new Promise(resolve => {
            this.androidFingerprintAuth
                .isAvailable()
                .then(res => {
                if (res.isAvailable)
                    return resolve(true);
                else {
                    this.logger.debug('Fingerprint is not available');
                    return resolve(false);
                }
            })
                .catch(() => {
                this.logger.warn('Touch ID (Android) is not available for this device');
                return resolve(false);
            });
        });
    }
    verifyIOSFingerprint() {
        return this.touchId
            .verifyFingerprint('Scan your fingerprint please')
            .catch(err => {
            if (err && (err.code == -2 || err.code == -128))
                err.message = TouchIdErrors.fingerprintCancelled;
            throw err;
        });
    }
    verifyAndroidFingerprint() {
        return this.androidFingerprintAuth
            .encrypt({ clientId: this.app.info.nameCase })
            .then(result => {
            if (result.withFingerprint) {
                this.logger.debug('Successfully authenticated with fingerprint.');
            }
            else if (result.withBackup) {
                this.logger.debug('Successfully authenticated with backup password!');
            }
            else
                this.logger.debug("Didn't authenticate!");
        })
            .catch(error => {
            const err = new Error(error);
            if (error === TouchIdErrors.fingerprintCancelled) {
                this.logger.debug('Fingerprint authentication cancelled');
                err.message = TouchIdErrors.fingerprintCancelled;
            }
            else {
                this.logger.warn('Could not get Fingerprint Authenticated', error);
            }
            throw err;
        });
    }
    check() {
        if (this.platform.isIOS)
            return this.verifyIOSFingerprint();
        if (this.platform.isAndroid)
            return this.verifyAndroidFingerprint();
        return undefined;
    }
    isNeeded(wallet) {
        let config = this.config.get();
        config.touchIdFor = config.touchIdFor || {};
        return config.touchIdFor[wallet.credentials.walletId];
    }
    checkWallet(wallet) {
        return this.isAvailable().then((isAvailable) => {
            if (!isAvailable)
                return undefined;
            if (this.isNeeded(wallet))
                return this.check();
            return undefined;
        });
    }
};
TouchIdProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_touch_id__["a" /* TouchID */],
        __WEBPACK_IMPORTED_MODULE_1__ionic_native_android_fingerprint_auth__["a" /* AndroidFingerprintAuth */],
        __WEBPACK_IMPORTED_MODULE_6__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */]])
], TouchIdProvider);

//# sourceMappingURL=touchid.js.map

/***/ }),

/***/ 1155:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1173:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ModalCancelText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MiniModalContent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ModalCancelText = class ModalCancelText {
};
ModalCancelText = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'modal-cancel-text',
        template: `<ng-content></ng-content>`
    })
], ModalCancelText);

let MiniModalContent = class MiniModalContent {
    constructor(renderer) {
        this.renderer = renderer;
        this.type = 'warning';
        this.actionSubject = new __WEBPACK_IMPORTED_MODULE_1_rxjs_Subject__["Subject"]();
        this.action = this.actionSubject.asObservable();
    }
    ngAfterViewInit() {
        this.renderer.setElementClass(this.imageContainer.nativeElement, this.getImageBackgroundClass(this.type), true);
    }
    getImageBackgroundClass(type) {
        return `background-color-${type}`;
    }
    close(confirm) {
        this.actionSubject.next(confirm);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], MiniModalContent.prototype, "type", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ContentChild"])(ModalCancelText),
    __metadata("design:type", ModalCancelText)
], MiniModalContent.prototype, "modalCancelText", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('imageContainer'),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
], MiniModalContent.prototype, "imageContainer", void 0);
MiniModalContent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'mini-modal-content',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/components/mini-modal/mini-modal-content.html"*/'<div class="modal-img" #imageContainer>\n  <ng-content select="[modal-icon]"></ng-content>\n</div>\n<div class="modal-content">\n  <ng-content select=".modal-heading"></ng-content>\n  <ng-content select=".modal-message"></ng-content>\n  <div class="buttons">\n    <div class="button-wrapper" *ngIf="modalCancelText">\n      <button ion-button clear [color]="type" (click)="close(false)">\n        <ng-content select="modal-cancel-text"></ng-content>\n      </button>\n    </div>\n    <div class="button-wrapper">\n      <button ion-button clear [color]="type" (click)="close(true)">\n        <ng-content select="[modal-confirm-text]"></ng-content>\n      </button>\n    </div>\n  </div>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/components/mini-modal/mini-modal-content.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"]])
], MiniModalContent);

//# sourceMappingURL=mini-modal-content.js.map

/***/ }),

/***/ 1174:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Profile {
    constructor() {
        this.version = '1.0.0';
    }
    create(opts) {
        opts = opts ? opts : {};
        let x = new Profile();
        x.createdOn = Date.now();
        x.credentials = opts.credentials || [];
        x.disclaimerAccepted = false;
        x.onboardingCompleted = false;
        x.checked = {};
        return x;
    }
    fromObj(obj) {
        let x = new Profile();
        x.createdOn = obj.createdOn;
        x.credentials = obj.credentials;
        x.disclaimerAccepted = obj.disclaimerAccepted;
        x.onboardingCompleted = obj.onboardingCompleted;
        x.checked = obj.checked || {};
        x.checkedUA = obj.checkedUA || {};
        if (x.credentials[0] && typeof x.credentials[0] != 'object')
            throw new Error('credentials should be an object');
        return x;
    }
    fromString(str) {
        return this.fromObj(JSON.parse(str));
    }
    toObj() {
        delete this.dirty;
        return JSON.stringify(this);
    }
    hasWallet(walletId) {
        for (let i in this.credentials) {
            let c = this.credentials[i];
            if (c.walletId == walletId)
                return true;
        }
        return false;
    }
    isChecked(ua, walletId) {
        return !!(this.checkedUA == ua && this.checked[walletId]);
    }
    isDeviceChecked(ua) {
        return this.checkedUA == ua;
    }
    setChecked(ua, walletId) {
        if (this.checkedUA != ua) {
            this.checkedUA = ua;
            this.checked = {};
        }
        this.checked[walletId] = true;
        this.dirty = true;
    }
    addWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (this.hasWallet(credentials.walletId))
            return false;
        this.credentials.push(credentials);
        this.dirty = true;
        return true;
    }
    updateWallet(credentials) {
        if (!credentials.walletId)
            throw new Error('credentials must have .walletId');
        if (!this.hasWallet(credentials.walletId))
            return false;
        this.credentials = this.credentials.map(c => {
            if (c.walletId != credentials.walletId) {
                return c;
            }
            else {
                return credentials;
            }
        });
        this.dirty = true;
        return true;
    }
    deleteWallet(walletId) {
        if (!this.hasWallet(walletId))
            return false;
        this.credentials = this.credentials.filter(c => {
            return c.walletId != walletId;
        });
        this.dirty = true;
        return true;
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Profile;

//# sourceMappingURL=profile.model.js.map

/***/ }),

/***/ 1188:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class AddressValidator {
    constructor(bwc) {
        AddressValidator.bitcore = bwc;
    }
    isValid(control) {
        let b = AddressValidator.bitcore.getBitcore();
        let c = AddressValidator.bitcore.getBitcoreCash();
        let URI = b.URI;
        let Address = b.Address;
        let URICash = c.URI;
        let AddressCash = c.Address;
        // Regular url
        if (/^https?:\/\//.test(control.value)) {
            return null;
        }
        // Bip21 uri
        let uri, isAddressValidLivenet, isAddressValidTestnet;
        if (/^bastoji:/.test(control.value)) {
            let isUriValid = URI.isValid(control.value);
            if (isUriValid) {
                uri = new URI(control.value);
                isAddressValidLivenet = Address.isValid(uri.address.toString(), 'livenet');
                isAddressValidTestnet = Address.isValid(uri.address.toString(), 'testnet');
            }
            if (isUriValid && (isAddressValidLivenet || isAddressValidTestnet)) {
                return null;
            }
        }
        else if (/^bastojicash:/.test(control.value)) {
            let isUriValid = URICash.isValid(control.value);
            if (isUriValid) {
                uri = new URICash(control.value);
                isAddressValidLivenet = AddressCash.isValid(uri.address.toString(), 'livenet');
            }
            if (isUriValid && isAddressValidLivenet) {
                return null;
            }
        }
        // Regular Address: try Bastoji and Bastoji Cash
        let regularAddressLivenet = Address.isValid(control.value, 'livenet');
        let regularAddressTestnet = Address.isValid(control.value, 'testnet');
        let regularAddressCashLivenet = AddressCash.isValid(control.value, 'livenet');
        if (regularAddressLivenet ||
            regularAddressTestnet ||
            regularAddressCashLivenet) {
            return null;
        }
        return {
            'Invalid Address': true
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = AddressValidator;

//# sourceMappingURL=address.js.map

/***/ }),

/***/ 1189:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class EmailValidator {
    constructor(cnf, eml) {
        EmailValidator.cnf = cnf;
        EmailValidator.eml = eml;
    }
    isValid(control) {
        let config = EmailValidator.cnf.get();
        let latestEmail = EmailValidator.eml.getEmailIfEnabled(config);
        let validEmail = /^[a-zA-Z0-9.!#$%&*+=?^_{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/.test(control.value);
        if (validEmail && control.value != latestEmail) {
            return null;
        }
        return {
            'Invalid Email': true
        };
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = EmailValidator;

//# sourceMappingURL=email.js.map

/***/ }),

/***/ 1191:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pages_add_add__ = __webpack_require__(719);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pages_add_copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pages_add_create_wallet_create_wallet__ = __webpack_require__(720);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pages_add_import_wallet_import_wallet__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__pages_add_join_wallet_join_wallet__ = __webpack_require__(350);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__pages_backup_backup_game_backup_game__ = __webpack_require__(717);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__pages_backup_backup_warning_backup_warning__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__pages_feedback_feedback_complete_feedback_complete__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pages_feedback_feedback_feedback__ = __webpack_require__(861);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pages_finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__pages_onboarding_backup_request_backup_request__ = __webpack_require__(860);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pages_onboarding_collect_email_collect_email__ = __webpack_require__(859);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__pages_onboarding_disclaimer_disclaimer__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__pages_onboarding_onboarding__ = __webpack_require__(857);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pages_onboarding_tour_tour__ = __webpack_require__(858);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pages_paper_wallet_paper_wallet__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__pages_paypro_paypro__ = __webpack_require__(735);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__pages_slide_to_accept_slide_to_accept__ = __webpack_require__(1192);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__pages_tabs_tabs__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__pages_tx_details_tx_details__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__pages_txp_details_txp_details__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pages_wallet_details_search_tx_modal_search_tx_modal__ = __webpack_require__(854);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__pages_wallet_details_wallet_balance_wallet_balance__ = __webpack_require__(855);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__pages_wallet_details_wallet_details__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__pages_integrations_amazon_amazon__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__pages_integrations_amazon_amazon_card_details_amazon_card_details__ = __webpack_require__(737);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__pages_integrations_amazon_amazon_settings_amazon_settings__ = __webpack_require__(824);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__pages_integrations_amazon_buy_amazon_buy_amazon__ = __webpack_require__(721);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__pages_integrations_coinbase_buy_coinbase_buy_coinbase__ = __webpack_require__(723);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__pages_integrations_coinbase_coinbase__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__pages_integrations_coinbase_coinbase_settings_coinbase_settings__ = __webpack_require__(826);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__pages_integrations_coinbase_coinbase_tx_details_coinbase_tx_details__ = __webpack_require__(724);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__pages_integrations_coinbase_sell_coinbase_sell_coinbase__ = __webpack_require__(725);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__pages_integrations_glidera_buy_glidera_buy_glidera__ = __webpack_require__(726);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__pages_integrations_glidera_glidera__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__pages_integrations_glidera_glidera_settings_glidera_settings__ = __webpack_require__(827);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__pages_integrations_glidera_glidera_tx_details_glidera_tx_details__ = __webpack_require__(727);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__pages_integrations_glidera_sell_glidera_sell_glidera__ = __webpack_require__(729);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__pages_integrations_mercado_libre_buy_mercado_libre_buy_mercado_libre__ = __webpack_require__(730);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__pages_integrations_mercado_libre_mercado_libre__ = __webpack_require__(352);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__pages_integrations_mercado_libre_mercado_libre_card_details_mercado_libre_card_details__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__pages_integrations_mercado_libre_mercado_libre_settings_mercado_libre_settings__ = __webpack_require__(828);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__pages_integrations_shapeshift_shapeshift__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__pages_integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__ = __webpack_require__(731);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__pages_integrations_shapeshift_shapeshift_details_shapeshift_details__ = __webpack_require__(732);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__pages_integrations_shapeshift_shapeshift_settings_shapeshift_settings__ = __webpack_require__(829);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__pages_integrations_shapeshift_shapeshift_shift_shapeshift_shift__ = __webpack_require__(733);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__pages_integrations_bitpay_card_bitpay_card__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__pages_integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__ = __webpack_require__(722);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__pages_integrations_bitpay_card_bitpay_settings_bitpay_settings__ = __webpack_require__(825);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__pages_includes_card_item_card_item__ = __webpack_require__(1193);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__pages_includes_feedback_card_feedback_card__ = __webpack_require__(1194);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__pages_includes_gravatar_gravatar__ = __webpack_require__(1195);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__pages_includes_incoming_data_menu_incoming_data_menu__ = __webpack_require__(1197);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_56__pages_includes_txp_txp__ = __webpack_require__(1198);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_57__pages_includes_wallet_activity_wallet_activity__ = __webpack_require__(1199);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_58__pages_includes_wallet_item_wallet_item__ = __webpack_require__(1200);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_59__pages_includes_wallet_selector_wallet_selector__ = __webpack_require__(1201);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_60__pages_home_home__ = __webpack_require__(718);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_61__pages_receive_receive__ = __webpack_require__(819);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_62__pages_scan_scan__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_63__pages_send_send__ = __webpack_require__(822);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_64__pages_settings_settings__ = __webpack_require__(823);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_65__pages_home_activity_activity__ = __webpack_require__(738);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_66__pages_home_proposals_proposals__ = __webpack_require__(739);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_67__pages_fingerprint_fingerprint__ = __webpack_require__(856);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_68__pages_pin_pin__ = __webpack_require__(1202);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_69__pages_settings_about_about__ = __webpack_require__(831);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_70__pages_settings_about_session_log_session_log__ = __webpack_require__(832);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_71__pages_settings_addressbook_add_add__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_72__pages_settings_addressbook_addressbook__ = __webpack_require__(833);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_73__pages_settings_addressbook_view_view__ = __webpack_require__(834);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_74__pages_settings_advanced_advanced__ = __webpack_require__(835);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_75__pages_settings_alt_currency_alt_currency__ = __webpack_require__(836);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_76__pages_settings_fee_policy_fee_policy__ = __webpack_require__(837);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_77__pages_settings_language_language__ = __webpack_require__(838);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_78__pages_settings_lock_lock__ = __webpack_require__(839);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_79__pages_settings_notifications_notifications__ = __webpack_require__(840);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_80__pages_settings_wallet_settings_wallet_color_wallet_color__ = __webpack_require__(842);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_81__pages_settings_wallet_settings_wallet_name_wallet_name__ = __webpack_require__(843);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_82__pages_settings_wallet_settings_wallet_settings__ = __webpack_require__(841);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_83__pages_settings_wallet_settings_wallet_settings_advanced_bastoji_cash_bastoji_cash__ = __webpack_require__(845);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_84__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_all_addresses_all_addresses__ = __webpack_require__(846);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_85__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_86__pages_settings_wallet_settings_wallet_settings_advanced_wallet_delete_wallet_delete__ = __webpack_require__(847);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_87__pages_settings_wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__ = __webpack_require__(848);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_88__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_extended_private_key_wallet_extended_private_key__ = __webpack_require__(851);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_89__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_information__ = __webpack_require__(850);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_90__pages_settings_wallet_settings_wallet_settings_advanced_wallet_service_url_wallet_service_url__ = __webpack_require__(852);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_91__pages_settings_wallet_settings_wallet_settings_advanced_wallet_settings_advanced__ = __webpack_require__(844);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_92__pages_settings_wallet_settings_wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__ = __webpack_require__(853);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_93__pages_send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_94__pages_send_choose_fee_level_choose_fee_level__ = __webpack_require__(736);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_95__pages_send_confirm_confirm__ = __webpack_require__(355);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_96__pages_receive_custom_amount_custom_amount__ = __webpack_require__(734);
/* Pages */

























// Integrations: Amazon




// Integrations: Coinbase





// Integrations: Glidera





// Integrations: Mercado Libre




// Integrations: ShapeShift





// Integrations: BitPayCard




/*Includes */








/* Tabs */





/* Home */


/* Settings */













/* Wallet Settings */



/* Wallet Advanced Settings */










/* Send */



/* Receive */

const PAGES = [
    __WEBPACK_IMPORTED_MODULE_65__pages_home_activity_activity__["a" /* ActivityPage */],
    __WEBPACK_IMPORTED_MODULE_0__pages_add_add__["a" /* AddPage */],
    __WEBPACK_IMPORTED_MODULE_26__pages_integrations_amazon_amazon_card_details_amazon_card_details__["a" /* AmazonCardDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_25__pages_integrations_amazon_amazon__["a" /* AmazonPage */],
    __WEBPACK_IMPORTED_MODULE_27__pages_integrations_amazon_amazon_settings_amazon_settings__["a" /* AmazonSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_93__pages_send_amount_amount__["a" /* AmountPage */],
    __WEBPACK_IMPORTED_MODULE_72__pages_settings_addressbook_addressbook__["a" /* AddressbookPage */],
    __WEBPACK_IMPORTED_MODULE_71__pages_settings_addressbook_add_add__["a" /* AddressbookAddPage */],
    __WEBPACK_IMPORTED_MODULE_73__pages_settings_addressbook_view_view__["a" /* AddressbookViewPage */],
    __WEBPACK_IMPORTED_MODULE_69__pages_settings_about_about__["a" /* AboutPage */],
    __WEBPACK_IMPORTED_MODULE_74__pages_settings_advanced_advanced__["a" /* AdvancedPage */],
    __WEBPACK_IMPORTED_MODULE_84__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_all_addresses_all_addresses__["a" /* AllAddressesPage */],
    __WEBPACK_IMPORTED_MODULE_75__pages_settings_alt_currency_alt_currency__["a" /* AltCurrencyPage */],
    __WEBPACK_IMPORTED_MODULE_11__pages_onboarding_backup_request_backup_request__["a" /* BackupRequestPage */],
    __WEBPACK_IMPORTED_MODULE_83__pages_settings_wallet_settings_wallet_settings_advanced_bastoji_cash_bastoji_cash__["a" /* BastojiCashPage */],
    __WEBPACK_IMPORTED_MODULE_49__pages_integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
    __WEBPACK_IMPORTED_MODULE_48__pages_integrations_bitpay_card_bitpay_card__["a" /* BitPayCardPage */],
    __WEBPACK_IMPORTED_MODULE_51__pages_integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */],
    __WEBPACK_IMPORTED_MODULE_50__pages_integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__["a" /* BitPayCardTopUpPage */],
    __WEBPACK_IMPORTED_MODULE_28__pages_integrations_amazon_buy_amazon_buy_amazon__["a" /* BuyAmazonPage */],
    __WEBPACK_IMPORTED_MODULE_29__pages_integrations_coinbase_buy_coinbase_buy_coinbase__["a" /* BuyCoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_34__pages_integrations_glidera_buy_glidera_buy_glidera__["a" /* BuyGlideraPage */],
    __WEBPACK_IMPORTED_MODULE_39__pages_integrations_mercado_libre_buy_mercado_libre_buy_mercado_libre__["a" /* BuyMercadoLibrePage */],
    __WEBPACK_IMPORTED_MODULE_94__pages_send_choose_fee_level_choose_fee_level__["a" /* ChooseFeeLevelPage */],
    __WEBPACK_IMPORTED_MODULE_2__pages_add_create_wallet_create_wallet__["a" /* CreateWalletPage */],
    __WEBPACK_IMPORTED_MODULE_30__pages_integrations_coinbase_coinbase__["a" /* CoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_32__pages_integrations_coinbase_coinbase_tx_details_coinbase_tx_details__["a" /* CoinbaseTxDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_1__pages_add_copayers_copayers__["a" /* CopayersPage */],
    __WEBPACK_IMPORTED_MODULE_53__pages_includes_feedback_card_feedback_card__["a" /* FeedbackCardPage */],
    __WEBPACK_IMPORTED_MODULE_8__pages_feedback_feedback_feedback__["a" /* FeedbackPage */],
    __WEBPACK_IMPORTED_MODULE_7__pages_feedback_feedback_complete_feedback_complete__["a" /* FeedbackCompletePage */],
    __WEBPACK_IMPORTED_MODULE_55__pages_includes_incoming_data_menu_incoming_data_menu__["a" /* IncomingDataMenuPage */],
    __WEBPACK_IMPORTED_MODULE_3__pages_add_import_wallet_import_wallet__["a" /* ImportWalletPage */],
    __WEBPACK_IMPORTED_MODULE_4__pages_add_join_wallet_join_wallet__["a" /* JoinWalletPage */],
    __WEBPACK_IMPORTED_MODULE_6__pages_backup_backup_warning_backup_warning__["a" /* BackupWarningPage */],
    __WEBPACK_IMPORTED_MODULE_5__pages_backup_backup_game_backup_game__["a" /* BackupGamePage */],
    __WEBPACK_IMPORTED_MODULE_95__pages_send_confirm_confirm__["a" /* ConfirmPage */],
    __WEBPACK_IMPORTED_MODULE_96__pages_receive_custom_amount_custom_amount__["a" /* CustomAmountPage */],
    __WEBPACK_IMPORTED_MODULE_13__pages_onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */],
    __WEBPACK_IMPORTED_MODULE_12__pages_onboarding_collect_email_collect_email__["a" /* CollectEmailPage */],
    __WEBPACK_IMPORTED_MODULE_35__pages_integrations_glidera_glidera__["a" /* GlideraPage */],
    __WEBPACK_IMPORTED_MODULE_54__pages_includes_gravatar_gravatar__["a" /* GravatarPage */],
    __WEBPACK_IMPORTED_MODULE_67__pages_fingerprint_fingerprint__["a" /* FingerprintModalPage */],
    __WEBPACK_IMPORTED_MODULE_60__pages_home_home__["a" /* HomePage */],
    __WEBPACK_IMPORTED_MODULE_77__pages_settings_language_language__["a" /* LanguagePage */],
    __WEBPACK_IMPORTED_MODULE_78__pages_settings_lock_lock__["a" /* LockPage */],
    __WEBPACK_IMPORTED_MODULE_40__pages_integrations_mercado_libre_mercado_libre__["a" /* MercadoLibrePage */],
    __WEBPACK_IMPORTED_MODULE_42__pages_integrations_mercado_libre_mercado_libre_settings_mercado_libre_settings__["a" /* MercadoLibreSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_14__pages_onboarding_onboarding__["a" /* OnboardingPage */],
    __WEBPACK_IMPORTED_MODULE_16__pages_paper_wallet_paper_wallet__["a" /* PaperWalletPage */],
    __WEBPACK_IMPORTED_MODULE_17__pages_paypro_paypro__["a" /* PayProPage */],
    __WEBPACK_IMPORTED_MODULE_37__pages_integrations_glidera_glidera_tx_details_glidera_tx_details__["a" /* GlideraTxDetailsPage */],
    ...__WEBPACK_IMPORTED_MODULE_68__pages_pin_pin__["a" /* PIN_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_66__pages_home_proposals_proposals__["a" /* ProposalsPage */],
    __WEBPACK_IMPORTED_MODULE_61__pages_receive_receive__["a" /* ReceivePage */],
    __WEBPACK_IMPORTED_MODULE_62__pages_scan_scan__["a" /* ScanPage */],
    __WEBPACK_IMPORTED_MODULE_63__pages_send_send__["a" /* SendPage */],
    __WEBPACK_IMPORTED_MODULE_64__pages_settings_settings__["a" /* SettingsPage */],
    __WEBPACK_IMPORTED_MODULE_33__pages_integrations_coinbase_sell_coinbase_sell_coinbase__["a" /* SellCoinbasePage */],
    __WEBPACK_IMPORTED_MODULE_38__pages_integrations_glidera_sell_glidera_sell_glidera__["a" /* SellGlideraPage */],
    __WEBPACK_IMPORTED_MODULE_36__pages_integrations_glidera_glidera_settings_glidera_settings__["a" /* GlideraSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_31__pages_integrations_coinbase_coinbase_settings_coinbase_settings__["a" /* CoinbaseSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_44__pages_integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__["a" /* ShapeshiftConfirmPage */],
    __WEBPACK_IMPORTED_MODULE_45__pages_integrations_shapeshift_shapeshift_details_shapeshift_details__["a" /* ShapeshiftDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_46__pages_integrations_shapeshift_shapeshift_settings_shapeshift_settings__["a" /* ShapeshiftSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_43__pages_integrations_shapeshift_shapeshift__["a" /* ShapeshiftPage */],
    __WEBPACK_IMPORTED_MODULE_47__pages_integrations_shapeshift_shapeshift_shift_shapeshift_shift__["a" /* ShapeshiftShiftPage */],
    __WEBPACK_IMPORTED_MODULE_41__pages_integrations_mercado_libre_mercado_libre_card_details_mercado_libre_card_details__["a" /* MercadoLibreCardDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_79__pages_settings_notifications_notifications__["a" /* NotificationsPage */],
    __WEBPACK_IMPORTED_MODULE_76__pages_settings_fee_policy_fee_policy__["a" /* FeePolicyPage */],
    __WEBPACK_IMPORTED_MODULE_22__pages_wallet_details_search_tx_modal_search_tx_modal__["a" /* SearchTxModalPage */],
    __WEBPACK_IMPORTED_MODULE_70__pages_settings_about_session_log_session_log__["a" /* SessionLogPage */],
    __WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */],
    __WEBPACK_IMPORTED_MODULE_10__pages_finish_finish__["a" /* FinishModalPage */],
    __WEBPACK_IMPORTED_MODULE_15__pages_onboarding_tour_tour__["a" /* TourPage */],
    __WEBPACK_IMPORTED_MODULE_19__pages_tabs_tabs__["a" /* TabsPage */],
    __WEBPACK_IMPORTED_MODULE_21__pages_txp_details_txp_details__["a" /* TxpDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_20__pages_tx_details_tx_details__["a" /* TxDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_56__pages_includes_txp_txp__["a" /* TxpPage */],
    __WEBPACK_IMPORTED_MODULE_82__pages_settings_wallet_settings_wallet_settings__["a" /* WalletSettingsPage */],
    __WEBPACK_IMPORTED_MODULE_91__pages_settings_wallet_settings_wallet_settings_advanced_wallet_settings_advanced__["a" /* WalletSettingsAdvancedPage */],
    __WEBPACK_IMPORTED_MODULE_81__pages_settings_wallet_settings_wallet_name_wallet_name__["a" /* WalletNamePage */],
    __WEBPACK_IMPORTED_MODULE_80__pages_settings_wallet_settings_wallet_color_wallet_color__["a" /* WalletColorPage */],
    __WEBPACK_IMPORTED_MODULE_89__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_information__["a" /* WalletInformationPage */],
    __WEBPACK_IMPORTED_MODULE_85__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */],
    __WEBPACK_IMPORTED_MODULE_87__pages_settings_wallet_settings_wallet_settings_advanced_wallet_export_wallet_export__["a" /* WalletExportPage */],
    __WEBPACK_IMPORTED_MODULE_90__pages_settings_wallet_settings_wallet_settings_advanced_wallet_service_url_wallet_service_url__["a" /* WalletServiceUrlPage */],
    __WEBPACK_IMPORTED_MODULE_92__pages_settings_wallet_settings_wallet_settings_advanced_wallet_transaction_history_wallet_transaction_history__["a" /* WalletTransactionHistoryPage */],
    __WEBPACK_IMPORTED_MODULE_86__pages_settings_wallet_settings_wallet_settings_advanced_wallet_delete_wallet_delete__["a" /* WalletDeletePage */],
    __WEBPACK_IMPORTED_MODULE_88__pages_settings_wallet_settings_wallet_settings_advanced_wallet_information_wallet_extended_private_key_wallet_extended_private_key__["a" /* WalletExtendedPrivateKeyPage */],
    __WEBPACK_IMPORTED_MODULE_24__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */],
    __WEBPACK_IMPORTED_MODULE_23__pages_wallet_details_wallet_balance_wallet_balance__["a" /* WalletBalancePage */],
    __WEBPACK_IMPORTED_MODULE_58__pages_includes_wallet_item_wallet_item__["a" /* WalletItemPage */],
    __WEBPACK_IMPORTED_MODULE_57__pages_includes_wallet_activity_wallet_activity__["a" /* WalletActivityPage */],
    __WEBPACK_IMPORTED_MODULE_59__pages_includes_wallet_selector_wallet_selector__["a" /* WalletSelectorPage */],
    __WEBPACK_IMPORTED_MODULE_52__pages_includes_card_item_card_item__["a" /* CardItemPage */],
    __WEBPACK_IMPORTED_MODULE_18__pages_slide_to_accept_slide_to_accept__["a" /* SlideToAcceptPage */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PAGES;

//# sourceMappingURL=pages.js.map

/***/ }),

/***/ 1192:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SlideToAcceptPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let SlideToAcceptPage = class SlideToAcceptPage {
    constructor(navCtrl, navParams, renderer) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.renderer = renderer;
        this.slideDone = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.isPressed = false;
        this.delta = 8;
        this.done = false;
        this.isDisabled = false;
        this.isConfirm = false;
        this.animation = false;
    }
    set disabled(disabled) {
        this.isDisabled = disabled !== undefined ? disabled : false;
    }
    get disabled() {
        return this.isDisabled;
    }
    set slideButtonDone(done) {
        this.done = done !== undefined ? done : false;
    }
    get slideButtonDone() {
        return this.done;
    }
    ngAfterViewInit() {
        setTimeout(() => {
            this.htmlButtonElem = this.buttonElement.nativeElement;
            this.htmlContainerElem = this.containerElement.nativeElement;
            let buttonConstraints = this.htmlButtonElem.getBoundingClientRect();
            this.origin = {
                left: buttonConstraints.left,
                top: buttonConstraints.top,
                width: buttonConstraints.width
            };
            this.containerWidth = this.htmlContainerElem.clientWidth;
            const subtract = this.containerWidth < 800 ? 75 : 200;
            this.xMax = this.containerWidth - subtract;
        }, 0);
    }
    activateButton(event) {
        this.isPressed = true;
        if (typeof event.touches != 'undefined') {
            this.clickPosition = event.touches[0].pageX;
        }
    }
    dragButton(event) {
        if (typeof event.touches != 'undefined') {
            let xTranslate = event.touches[0].pageX;
            let xDisplacement = this.isPressed ? xTranslate - this.clickPosition : 0;
            // Adjust displacement to consider the delta value
            xDisplacement -= this.delta;
            // Use resource inexpensive translation to perform the sliding
            let posCss = {
                transform: 'translateX(' + xDisplacement + 'px)',
                '-webkit-transform': 'translateX(' + xDisplacement + 'px)'
            };
            // Move the element while the drag position is less than xMax
            // -delta/2 is a necessary adjustment
            if (xDisplacement >= 0 &&
                xDisplacement <
                    this.containerWidth - (this.origin.width * 15) / 100 + 30 &&
                this.isPressed) {
                // Set element styles
                this.renderer.setElementStyle(this.htmlButtonElem, 'transform', posCss['transform']);
                this.renderer.setElementStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
            }
            // If the max displacement position is reached
            this.slideButtonDone =
                xDisplacement >= this.xMax - this.delta / 2 ? true : false;
        }
    }
    resetButton() {
        // Only reset if button sliding is not done yet
        if (!this.slideButtonDone || this.isDisabled) {
            this.isConfirm = false;
            // Reset state variables
            // Resets button position
            let posCss = {
                transform: 'translateX(0px)',
                '-webkit-transform': 'translateX(0px)'
            };
            this.renderer.setElementStyle(this.htmlButtonElem, 'transform', posCss['transform']);
            this.renderer.setElementStyle(this.htmlButtonElem, '-webkit-transform', posCss['-webkit-transform']);
            this.ngAfterViewInit();
        }
        else if (this.slideButtonDone && !this.isDisabled) {
            this.isConfirm = true;
            this.slideButtonDone = false;
            this.slideDone.emit(true);
        }
    }
    isConfirmed(boolean) {
        if (!boolean) {
            this.resetButton();
        }
    }
    toggleAnimation() {
        if (this.isDisabled)
            return;
        this.animation = true;
        setTimeout(() => {
            this.animation = false;
        }, 300);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
    __metadata("design:type", Object)
], SlideToAcceptPage.prototype, "slideDone", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], SlideToAcceptPage.prototype, "buttonText", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SlideToAcceptPage.prototype, "disabled", null);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], SlideToAcceptPage.prototype, "slideButtonDone", null);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"] }),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
], SlideToAcceptPage.prototype, "buttonElement", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButtonContainer'),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
], SlideToAcceptPage.prototype, "containerElement", void 0);
SlideToAcceptPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-slide-to-accept',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/slide-to-accept/slide-to-accept.html"*/'<div #slideButtonContainer class="slide__listener" no-margin no-padding>\n  <button class="button-slider" [ngClass]="{\'animation\': animation}" #slideButton ion-button icon-right large (touchstart)="activateButton($event)" (touchmove)="dragButton($event)" (touchend)="resetButton()" [disabled]="isDisabled" *ngIf="!isConfirm">\n    <div class="slide__bastoji" [ngStyle]="bastojiStyle">\n      <img src="assets/img/icon-bastoji-white.svg">\n    </div>\n  </button>\n  <div class="slide__button-text" (touchstart)="toggleAnimation()" (touchmove)="toggleAnimation()" [ngStyle]="textStyle" *ngIf="!isConfirm">\n    <span class="justify">{{buttonText}}</span>\n  </div>\n  <div class="slide__arrow " *ngIf="!isConfirm">\n    <img src="assets/img/icon-arrow-right.svg">\n  </div>\n  <div class="slide__status-text" [ngClass]="{\'enter\': isConfirm}" *ngIf="isConfirm">\n    <ion-spinner *ngIf="isConfirm"></ion-spinner>\n  </div>\n</div>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/slide-to-accept/slide-to-accept.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"]])
], SlideToAcceptPage);

//# sourceMappingURL=slide-to-accept.js.map

/***/ }),

/***/ 1193:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CardItemPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let CardItemPage = class CardItemPage {
    constructor(timeProvider) {
        this.timeProvider = timeProvider;
        this.sent = false;
        this.received = false;
        this.pending = false;
    }
    set card(card) {
        this._card = card;
        if (card.pending) {
            this.pending = true;
        }
        else if (card.price.toString().indexOf('-') > -1) {
            this.sent = true;
        }
        else {
            this.received = true;
        }
    }
    get card() {
        return this._card;
    }
    set currencySymbol(cs) {
        this._currencySymbol = cs;
    }
    get currencySymbol() {
        return this._currencySymbol;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CardItemPage.prototype, "card", null);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CardItemPage.prototype, "currencySymbol", null);
CardItemPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-card-item',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/card-item/card-item.html"*/'<ion-item *ngIf="card">\n  <ion-icon class="card-icon" item-start>\n    <div class="houston">\n      <img src="assets/img/mcc-icons/{{card.icon}}.svg" class="svg" />\n    </div>\n  </ion-icon>\n  <h4 text-wrap>\n    {{card.merchant.name || \'Unknown Merchant\'}}\n    <span *ngIf="card.pending && card.transactionId" translate>\n      View Confirmation Status\n    </span>\n  </h4>\n  <p>\n    {{card.merchant.location}}\n  </p>\n  <ion-note class="amount" item-end text-end>\n    <div [ngClass]="{\'amount--sent\': sent, \'amount--received\': received, \'amount--pending\': pending}">\n      {{card.price | currency:currencySymbol:2 }}\n    </div>\n    {{card.date}}\n  </ion-note>\n</ion-item>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/card-item/card-item.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_time_time__["a" /* TimeProvider */]])
], CardItemPage);

//# sourceMappingURL=card-item.js.map

/***/ }),

/***/ 1194:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__pages_feedback_feedback_feedback__ = __webpack_require__(861);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__ = __webpack_require__(257);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




// pages


let FeedbackCardPage = class FeedbackCardPage {
    constructor(appProvider, navCtrl, logger, persistenceProvider, translate, platformProvider, replaceParametersProvider) {
        this.appProvider = appProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.score = 0;
        this.isCordova = this.platformProvider.isCordova;
        this.isShowRateCard = false;
    }
    setShowRateCard(value) {
        this.isShowRateCard = value;
        if (this.isShowRateCard) {
            let appName = this.appProvider.info.nameCase;
            this.feedbackCardTitle = this.replaceParametersProvider.replace(this.translate.instant('How do you like {{appName}}?'), { appName });
        }
    }
    hideCard() {
        this.isShowRateCard = false;
        this.logger.debug('Feedback card dismissed.');
        this.persistenceProvider.getFeedbackInfo().then(info => {
            let feedbackInfo = info;
            feedbackInfo.sent = true;
            this.persistenceProvider.setFeedbackInfo(feedbackInfo);
        });
    }
    setScore(score) {
        this.score = score;
        switch (this.score) {
            case 1:
                this.button_title = this.translate.instant('I think this app is terrible');
                break;
            case 2:
                this.button_title = this.translate.instant("I don't like it");
                break;
            case 3:
                this.button_title = this.translate.instant("Meh - it's alright");
                break;
            case 4:
                this.button_title = this.translate.instant('I like the app');
                break;
            case 5:
                this.button_title = this.translate.instant('This app is fantastic!');
                break;
        }
    }
    goFeedbackFlow() {
        this.hideCard();
        if (this.isCordova && this.score == 5) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__pages_feedback_feedback_feedback__["a" /* FeedbackPage */], { score: this.score });
        }
        else {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__pages_feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */], { score: this.score });
        }
    }
};
FeedbackCardPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-feedback-card',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/feedback-card/feedback-card.html"*/'<div class="card" *ngIf="isShowRateCard">\n  <ion-item-divider>\n    <div class="title" item-start>\n      <span>{{ feedbackCardTitle }}</span>\n    </div>\n    <div item-end>\n      <button ion-button clear icon-only color="grey" (click)="hideCard()">\n        <ion-icon name="close"></ion-icon>\n      </button>\n    </div>\n  </ion-item-divider>\n  <ion-list>\n    <ion-row>\n      <ion-col col-20>\n        <ion-icon class="icon-svg" (click)="setScore(1)">\n          <img *ngIf="1 <= score" src="assets/img/ico-star-filled.svg" />\n          <img *ngIf="1 > score" src="assets/img/ico-star.svg" />\n        </ion-icon>\n      </ion-col>\n      <ion-col col-20>\n        <ion-icon class="icon-svg" (click)="setScore(2)">\n          <img *ngIf="2 <= score" src="assets/img/ico-star-filled.svg" />\n          <img *ngIf="2 > score" src="assets/img/ico-star.svg" />\n        </ion-icon>\n      </ion-col>\n      <ion-col col-20>\n        <ion-icon class="icon-svg" (click)="setScore(3)">\n          <img *ngIf="3 <= score" src="assets/img/ico-star-filled.svg" />\n          <img *ngIf="3 > score" src="assets/img/ico-star.svg" />\n        </ion-icon>\n      </ion-col>\n      <ion-col col-20>\n        <ion-icon class="icon-svg" (click)="setScore(4)">\n          <img *ngIf="4 <= score" src="assets/img/ico-star-filled.svg" />\n          <img *ngIf="4 > score" src="assets/img/ico-star.svg" />\n        </ion-icon>\n      </ion-col>\n      <ion-col col-20>\n        <ion-icon class="icon-svg" (click)="setScore(5)">\n          <img *ngIf="5 <= score" src="assets/img/ico-star-filled.svg" />\n          <img *ngIf="5 > score" src="assets/img/ico-star.svg" />\n        </ion-icon>\n      </ion-col>\n    </ion-row>\n    <button ion-button class="button-standard" (click)="goFeedbackFlow()" *ngIf="button_title">\n      <span>{{button_title}}</span>\n    </button>\n  </ion-list>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/feedback-card/feedback-card.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */]])
], FeedbackCardPage);

//# sourceMappingURL=feedback-card.js.map

/***/ }),

/***/ 1195:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GravatarPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ts_md5_dist_md5__ = __webpack_require__(1196);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ts_md5_dist_md5___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_ts_md5_dist_md5__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let GravatarPage = class GravatarPage {
    constructor(logger) {
        this.logger = logger;
    }
    ngOnInit() {
        this.logger.info('ionViewDidLoad GravatarPage');
        if (typeof this.email === 'string') {
            this.emailHash = __WEBPACK_IMPORTED_MODULE_1_ts_md5_dist_md5__["Md5"].hashStr(this.email.toLowerCase() || '');
        }
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], GravatarPage.prototype, "email", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], GravatarPage.prototype, "name", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Number)
], GravatarPage.prototype, "height", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Number)
], GravatarPage.prototype, "width", void 0);
GravatarPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'gravatar',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/gravatar/gravatar.html"*/'<img class="gravatar" alt="{{ name }}" height="{{ height }}" width="{{ width }}" src="https://secure.gravatar.com/avatar/{{ emailHash }}.jpg?s={{ width }}&d=mm">\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/gravatar/gravatar.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], GravatarPage);

//# sourceMappingURL=gravatar.js.map

/***/ }),

/***/ 1197:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataMenuPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let IncomingDataMenuPage = class IncomingDataMenuPage {
    constructor(events, platform) {
        this.events = events;
        this.platform = platform;
        this.https = false;
        this.showIncomingDataMenu = false;
        this.showSlideEffect = false;
        this.events.subscribe('showIncomingDataMenuEvent', data => {
            this.showIncomingDataMenu = true;
            this.data = data.data;
            this.type = data.type;
            this.coin = data.coin;
            if (this.type === 'url') {
                this.https = this.data.indexOf('https://') === 0 ? true : false;
            }
            setTimeout(() => {
                this.showSlideEffect = true;
            }, 50);
            let unregisterBackButtonAction = this.platform.registerBackButtonAction(() => {
                unregisterBackButtonAction();
                this.backdropDismiss();
            }, 0);
        });
    }
    backdropDismiss() {
        this.close(null, null);
    }
    close(redirTo, value) {
        if (redirTo == 'AmountPage') {
            let coin = this.coin ? this.coin : 'btc';
            this.events.publish('finishIncomingDataMenuEvent', {
                redirTo,
                value,
                coin
            });
        }
        else {
            this.events.publish('finishIncomingDataMenuEvent', { redirTo, value });
        }
        if (redirTo != 'OpenExternalLink') {
            this.showSlideEffect = false;
            setTimeout(() => {
                this.showIncomingDataMenu = false;
            }, 150);
        }
    }
};
IncomingDataMenuPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'incoming-data-menu',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/incoming-data-menu/incoming-data-menu.html"*/'<div class="backdrop" *ngIf="showIncomingDataMenu" (click)="backdropDismiss()">\n</div>\n<div class="incoming-data-menu slider" [ngClass]="{\'opened\': showSlideEffect, \'closed\': !showSlideEffect }" [hidden]="!showIncomingDataMenu">\n  <ion-list *ngIf="type === \'url\'">\n    <ion-item-divider>{{\'Website\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n      <ion-icon item-start>\n        <img *ngIf="!https" src="assets/img/icon-lock-x.svg">\n        <img *ngIf="https" src="assets/img/icon-lock-green.svg">\n      </ion-icon>\n    </ion-item>\n    <button ion-item (click)="close(\'OpenExternalLink\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-link-external.svg">\n      </ion-icon>\n      <span translate>Open website</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'bastojiAddress\'">\n    <ion-item-divider>{{\'Bastoji Address\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n      <ion-icon item-start>\n        <img src="assets/img/icon-bastoji-small.svg">\n      </ion-icon>\n    </ion-item>\n    <button ion-item (click)="close(\'AddressBookPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-contacts.svg">\n      </ion-icon>\n      <span translate>Add as a contact</span>\n    </button>\n    <button ion-item (click)="close(\'AmountPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-send-alt.svg">\n      </ion-icon>\n      <span translate>Send payment to this address</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'text\'">\n    <ion-item-divider>{{\'Text\' | translate}}</ion-item-divider>\n    <ion-item>\n      {{data}}\n    </ion-item>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <ion-list *ngIf="type === \'privateKey\'">\n    <ion-item-divider>{{\'Private Key\' | translate}}</ion-item-divider>\n    <ion-item>{{data}}</ion-item>\n    <button ion-item (click)="close(\'PaperWalletPage\', data)">\n      <ion-icon item-start>\n        <img src="assets/img/icon-import.svg">\n      </ion-icon>\n      <span translate>Sweep paper wallet</span>\n    </button>\n    <button ion-item copy-to-clipboard="{{ data }}">\n      <ion-icon item-start>\n        <img src="assets/img/icon-paperclip.svg">\n      </ion-icon>\n      <span translate>Copy to clipboard</span>\n    </button>\n  </ion-list>\n\n  <button ion-button clear color="danger" class="button-standard" (click)="close(null, null)">\n    {{\'Close\' | translate}}\n  </button>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/incoming-data-menu/incoming-data-menu.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
], IncomingDataMenuPage);

//# sourceMappingURL=incoming-data-menu.js.map

/***/ }),

/***/ 1198:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxpPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_time_time__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__txp_details_txp_details__ = __webpack_require__(244);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let TxpPage = class TxpPage {
    constructor(timeProvider, events, modalCtrl) {
        this.timeProvider = timeProvider;
        this.events = events;
        this.modalCtrl = modalCtrl;
    }
    set tx(tx) {
        this._tx = tx;
    }
    get tx() {
        return this._tx;
    }
    set addressbook(addressbook) {
        this._addressbook = addressbook;
    }
    get addressbook() {
        return this._addressbook;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    openTxpModal(txp) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__txp_details_txp_details__["a" /* TxpDetailsPage */], { tx: txp }, { showBackdrop: false, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.events.publish('status:updated');
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TxpPage.prototype, "tx", null);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], TxpPage.prototype, "addressbook", null);
TxpPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-txp',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/txp/txp.html"*/'<button ion-item class="proposal-container" [ngStyle]="{\'border-left-color\': tx.wallet.color}" (click)="openTxpModal(tx)">\n  <div *ngIf="!tx.merchant" class="item-title">\n    <span *ngIf="tx.message">{{tx.message}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && addressbook[tx.toAddress]">{{addressbook[tx.toAddress].name || addressbook[tx.toAddress]}}</span>\n    <span *ngIf="!tx.message && tx.toAddress && !addressbook[tx.toAddress]" translate>Sending</span>\n  </div>\n  <span *ngIf="tx.merchant" class="item-subtitle">\n    <span *ngIf="tx.merchant.pr.ca">\n      <ion-icon class="fi-lock"></ion-icon>{{tx.merchant.domain}}\n    </span>\n    <span *ngIf="!tx.merchant.pr.ca">\n      <ion-icon class="fion-icon-unlock"></ion-icon>{{tx.merchant.domain}}\n    </span>\n  </span>\n  <div class="item-subtitle">\n    <span *ngIf="tx.creatorName">{{ tx.creatorName}}@</span>\n    <span>{{tx.wallet.name}}</span>\n  </div>\n\n  <ion-note item-right>\n    <div class="amount">\n      <span *ngIf="tx.action == \'sent\'"></span>\n      <span *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n      <span *ngIf="tx.action != \'invalid\'">{{tx.amount | satToUnit: tx.coin}}</span>\n    </div>\n    <div class="date">\n      <time *ngIf="tx.createdOn && createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amTimeAgo}}</time>\n      <time *ngIf="tx.createdOn && !createdWithinPastDay(tx.createdOn * 1000)">{{tx.createdOn * 1000 | amDateFormat:\'MMM D, YYYY\'}}</time>\n    </div>\n  </ion-note>\n</button>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/txp/txp.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
], TxpPage);

//# sourceMappingURL=txp.js.map

/***/ }),

/***/ 1199:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletActivityPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let WalletActivityPage = class WalletActivityPage {
    set notification(notification) {
        this._notification = notification;
    }
    get notification() {
        return this._notification;
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], WalletActivityPage.prototype, "notification", null);
WalletActivityPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-activity',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/wallet-activity/wallet-activity.html"*/'<button ion-item class="activity-container" [ngStyle]="{\'border-left-color\': notification.wallet.color}">\n\n  <div class="item-title" *ngIf="notification.type == \'NewCopayer\' && notification.wallet.n>1">\n    <span translate>Sqoiner joined</span>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'NewCopayer\' && notification.wallet.n==1">\n    <span translate>Wallet created</span>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'NewOutgoingTx\'"> \n    <span translate>Payment Sent</span>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'NewIncomingTx\'">\n    <span translate>Payment Received</span>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'TxProposalRemoved\'">\n    <span translate>Proposal Deleted</span>:\n    <b>{{notification.message}}</b>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'TxProposalRejectedBy\'">\n    <span translate>Proposal Rejected</span>:\n    <b>{{notification.message}}</b>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'NewTxProposal\'">\n    <span translate>New Proposal</span>:\n    <b>{{notification.message}}</b>\n  </div>\n\n  <div class="item-title" *ngIf="notification.type == \'TxProposalAcceptedBy\'">\n    <span translate>Proposal Accepted</span>:\n    <b>{{notification.message}}</b>\n  </div>\n\n  <div class="item-subtitle"> \n    <span *ngIf="notification.creatorName && notification.wallet.n != 1">{{notification.creatorName}}</span>\n    <span>{{notification.wallet.name}}</span>\n  </div>\n  <ion-note item-right>\n    <!-- {{notification.types}} -->\n    <div class="amount">\n      {{notification.data.amount | satToUnit: notification.wallet.coin}}\n    </div>\n    <time class="date">{{ notification.createdOn * 1000 | amTimeAgo}}</time>\n  </ion-note>\n</button>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/wallet-activity/wallet-activity.html"*/
    })
], WalletActivityPage);

//# sourceMappingURL=wallet-activity.js.map

/***/ }),

/***/ 1200:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletItemPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let WalletItemPage = class WalletItemPage {
    set wallet(wallet) {
        this._wallet = wallet;
    }
    get wallet() {
        return this._wallet;
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], WalletItemPage.prototype, "wallet", null);
WalletItemPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-item',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/wallet-item/wallet-item.html"*/'<div *ngIf="wallet">\n  <ion-list>\n    <ion-item>\n      <ion-icon item-start>\n        <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg"\n          class="icon-wallet" />\n        <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg"\n          class="icon-wallet" />\n      </ion-icon>\n      <h2>\n        {{wallet.name || wallet.id}} \n        <span *ngIf="wallet.n > 1">\n          ({{wallet.m}}-of-{{wallet.n}})\n        </span>  \n      </h2>\n      <p>\n      <span *ngIf="wallet.coin == \'btc\'">Bastoji Wallet (BTJ)</span>\n      <span *ngIf="wallet.coin == \'bch\'">Bastoji Cash Wallet (BCH)</span>\n      <span ion-text color="danger" *ngIf="!wallet.isComplete()">\n        - <span translate>Incomplete</span>\n      </span>\n    </ion-item>\n  </ion-list>\n</div>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/wallet-item/wallet-item.html"*/
    })
], WalletItemPage);

//# sourceMappingURL=wallet-item.js.map

/***/ }),

/***/ 1201:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSelectorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let WalletSelectorPage = class WalletSelectorPage {
    constructor(events, platform) {
        this.events = events;
        this.platform = platform;
        this.showWalletsSelector = false;
        this.showSlideEffect = false;
        this.wallets = [];
        this.events.subscribe('showWalletsSelectorEvent', (wallets, selectedWalletId, title) => {
            this.title = title ? title : null;
            this.showWalletsSelector = true;
            this.selectedWalletId = selectedWalletId;
            setTimeout(() => {
                this.showSlideEffect = true;
            }, 50);
            this.wallets = wallets;
            this.separateWallets();
            let unregisterBackButtonAction = this.platform.registerBackButtonAction(() => {
                unregisterBackButtonAction();
                this.backdropDismiss();
            }, 0);
        });
    }
    selectWallet(wallet) {
        this.events.publish('selectWalletEvent', wallet);
        this.showSlideEffect = false;
        setTimeout(() => {
            this.showWalletsSelector = false;
        }, 150);
    }
    separateWallets() {
        this.walletsBtc = [];
        this.walletsBch = [];
        if (this.wallets.length == 0)
            return;
        for (var i = 0; i <= this.wallets.length; i++) {
            if (this.wallets[i]) {
                if (this.wallets[i].coin == 'btc')
                    this.walletsBtc.push(this.wallets[i]);
                else
                    this.walletsBch.push(this.wallets[i]);
            }
        }
    }
    backdropDismiss() {
        this.events.publish('selectWalletEvent');
        this.showSlideEffect = false;
        setTimeout(() => {
            this.showWalletsSelector = false;
        }, 150);
    }
};
WalletSelectorPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'wallet-selector',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/includes/wallet-selector/wallet-selector.html"*/'<div class="backdrop" *ngIf="showWalletsSelector" (click)="backdropDismiss()">\n</div>\n<div class="wallet-selector slider" [ngClass]="{\'opened\': showSlideEffect, \'closed\': !showSlideEffect }" [hidden]="!showWalletsSelector">\n  <ion-row align-items-center>\n    <ion-col col-4 text-left>\n      <button ion-button clear icon-only color="grey" (click)="backdropDismiss()">\n        <ion-icon name="arrow-round-back"></ion-icon>\n      </button>\n    </ion-col>\n    <ion-col col-4 text-center class="destination-title">{{ title }}</ion-col>\n  </ion-row>\n  <!--<div *ngFor="let wallet of wallets" (click)="selectWallet(wallet)">{{wallet.name}}</div>-->\n  <div class="no-wallets" *ngIf="(!walletsBtc || !walletsBtc[0]) && (!walletsBch || !walletsBch[0])" translate>\n    No wallets available\n  </div>\n  <div *ngIf="walletsBtc && walletsBtc[0]">\n    <ion-item-divider>\n      <div class="title">\n        <img src="assets/img/icon-bastoji.svg" alt="Bastoji Wallets" width="16" />\n        <span translate>Bastoji Wallets</span>\n      </div>\n    </ion-item-divider>\n\n    <ion-list>\n      <button ion-item detail-none *ngFor="let wallet of walletsBtc" class="wallet-button" (click)="selectWallet(wallet)">\n        <ion-icon class="item-img" item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n        </ion-icon>\n        <ion-icon class="item-img" item-end>\n          <img class="check" src="assets/img/icon-check-selected.svg" *ngIf="selectedWalletId === wallet.id">\n        </ion-icon>\n        <div class="item-title">{{wallet.name}}</div>\n        <div class="item-subtitle">\n          <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n            Incomplete\n          </span>\n          <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n            Needs backup\n          </span>\n          <span *ngIf="wallet.isComplete() && !wallet.needsBackup">\n            <span *ngIf="!wallet.balanceHidden && !wallet.scanning">\n              {{wallet.status && wallet.status.totalBalanceStr ? (wallet.status.totalBalanceStr) : ( wallet.cachedBalance ? wallet.cachedBalance + (wallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( wallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\')}}\n            </span>\n            <span *ngIf="wallet.scanning" translate>Scanning funds</span>\n            <span *ngIf="wallet.balanceHidden && !wallet.scanning">[\n              <span translate>Balance Hidden</span>]</span>\n            <span class="text-gray" *ngIf="wallet.credentials.m > 1" translate>{{wallet.credentials.m}}-of-{{wallet.credentials.n}}</span>\n            <ion-icon *ngIf="!wallet.balanceHidden && wallet.status && (wallet.status.totalBalanceSat != wallet.status.spendableAmount)" name="timer"></ion-icon>\n            <span *ngIf="wallet.error" class="error">{{wallet.error}}</span>\n          </span>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n\n  <div *ngIf="walletsBch && walletsBch[0]">\n    <ion-item-divider>\n      <div class="title">\n        <img src="assets/img/bastoji-cash-logo.svg" alt="Bastoji Cash Wallets" width="22" />\n        <span translate>Bastoji Cash Wallets</span>\n      </div>\n    </ion-item-divider>\n\n    <ion-list>\n      <button ion-item detail-none *ngFor="let wallet of walletsBch" class="wallet-button" (click)="selectWallet(wallet)">\n        <ion-icon class="item-img" item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n        </ion-icon>\n        <ion-icon class="item-img" item-end>\n          <img class="check" src="assets/img/icon-check-selected.svg" *ngIf="selectedWalletId === wallet.id">\n        </ion-icon>\n        <div class="item-title">{{wallet.name}}</div>\n        <div class="item-subtitle">\n          <span *ngIf="!wallet.isComplete()" translate>\n            Incomplete\n          </span>\n          <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n            Needs backup\n          </span>\n          <span *ngIf="wallet.isComplete() && !wallet.needsBackup">\n            <span *ngIf="!wallet.balanceHidden && !wallet.scanning">\n              {{wallet.status && wallet.status.totalBalanceStr ? (wallet.status.totalBalanceStr) : ( wallet.cachedBalance ? wallet.cachedBalance + (wallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( wallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\')}}\n            </span>\n            <span *ngIf="wallet.scanning" translate>Scanning funds</span>\n            <span *ngIf="wallet.balanceHidden && !wallet.scanning">[\n              <span translate>Balance Hidden</span>]</span>\n            <span class="text-gray" *ngIf="wallet.credentials.m > 1">{{wallet.credentials.m}}-of-{{wallet.credentials.n}}</span>\n            <ion-icon *ngIf="!wallet.balanceHidden && wallet.status && (wallet.status.totalBalanceSat != wallet.status.spendableAmount)" name="timer"></ion-icon>\n            <span *ngIf="wallet.error" class="error">{{wallet.error}}</span>\n          </span>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n  <ion-item-divider></ion-item-divider>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/includes/wallet-selector/wallet-selector.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */]])
], WalletSelectorPage);

//# sourceMappingURL=wallet-selector.js.map

/***/ }),

/***/ 1202:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__pin_dots_pin_dots_component__ = __webpack_require__(1203);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__pin_modal_pin_modal__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__pin_pad_pin_pad_component__ = __webpack_require__(1204);



const PIN_COMPONENTS = [__WEBPACK_IMPORTED_MODULE_1__pin_modal_pin_modal__["a" /* PinModalPage */], __WEBPACK_IMPORTED_MODULE_0__pin_dots_pin_dots_component__["a" /* PinDots */], __WEBPACK_IMPORTED_MODULE_2__pin_pad_pin_pad_component__["a" /* PinPad */]];
/* harmony export (immutable) */ __webpack_exports__["a"] = PIN_COMPONENTS;

//# sourceMappingURL=pin.js.map

/***/ }),

/***/ 1203:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinDots; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__directives_animate_animate__ = __webpack_require__(368);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let PinDots = class PinDots {
    constructor() {
        this.dotArray = new Array(4);
    }
    ngOnChanges(changes) {
        const pinChanges = changes.pin;
        if (!pinChanges) {
            return;
        }
        const currentValue = pinChanges.currentValue;
        const previousValue = pinChanges.previousValue;
        if (!currentValue.length || currentValue.length < previousValue.length) {
            return;
        }
        this.pulseDot(currentValue.length - 1);
    }
    isFilled(limit) {
        return this.pin && this.pin.length >= limit;
    }
    pulseDot(dotIndex) {
        const dot = this.dots.toArray()[dotIndex];
        dot.animate('pulse');
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], PinDots.prototype, "pin", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChildren"])(__WEBPACK_IMPORTED_MODULE_1__directives_animate_animate__["a" /* Animate */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["QueryList"])
], PinDots.prototype, "dots", void 0);
PinDots = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'pin-dots',
        template: `
    <div *ngFor="let dot of dotArray; index as i" class="circle" [ngClass]="{filled: isFilled(i+1)}" animate></div>
  `
    })
], PinDots);

//# sourceMappingURL=pin-dots.component.js.map

/***/ }),

/***/ 1204:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinPad; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let PinPad = class PinPad {
    constructor() {
        this.keystrokeSubject = new __WEBPACK_IMPORTED_MODULE_2_rxjs_Subject__["Subject"]();
        this.keystroke = this.keystrokeSubject.asObservable();
        this.buttonRows = [
            [
                {
                    value: '1',
                    letters: ''
                },
                {
                    value: '2',
                    letters: 'ABC'
                },
                {
                    value: '3',
                    letters: 'DEF'
                }
            ],
            [
                {
                    value: '4',
                    letters: 'GHI'
                },
                {
                    value: '5',
                    letters: 'JKL'
                },
                {
                    value: '6',
                    letters: 'MNO'
                }
            ],
            [
                {
                    value: '7',
                    letters: 'PQRS'
                },
                {
                    value: '8',
                    letters: 'TUV'
                },
                {
                    value: '9',
                    letters: 'WXYZ'
                }
            ],
            [
                {
                    value: '',
                    letters: ''
                },
                {
                    value: '0',
                    letters: ''
                },
                {
                    value: 'delete',
                    letters: ''
                }
            ]
        ];
    }
    onKeystroke(value) {
        this.keystrokeSubject.next(value);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_rxjs_Observable__["Observable"])
], PinPad.prototype, "keystroke", void 0);
PinPad = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'pin-pad',
        template: `
    <ion-row *ngFor="let row of buttonRows">
      <ion-col *ngFor="let button of row" (click)="onKeystroke(button.value)" tappable>
        <div>
          <span *ngIf="button.value !== 'delete'">{{button.value}}</span>
          <img *ngIf="button.value === 'delete'" src="assets/img/tail-left.svg">
        </div>
        <div class="letters">{{button.letters}}</div>
      </ion-col>
    </ion-row>
  `
    })
], PinPad);

//# sourceMappingURL=pin-pad.component.js.map

/***/ }),

/***/ 1205:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FiatToUnitPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_rate_rate__ = __webpack_require__(113);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let FiatToUnitPipe = class FiatToUnitPipe {
    constructor(configProvider, rateProvider, decimalPipe) {
        this.configProvider = configProvider;
        this.rateProvider = rateProvider;
        this.decimalPipe = decimalPipe;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin, alternative) {
        alternative = alternative
            ? alternative
            : this.walletSettings.alternativeIsoCode;
        let amount_ = this.rateProvider.fromFiat(amount, alternative, coin.toLowerCase());
        return (this.decimalPipe.transform(amount_ / 1e8 || 0, '1.2-8') +
            ' ' +
            coin.toUpperCase());
    }
};
FiatToUnitPipe = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Pipe"])({
        name: 'fiatToUnit',
        pure: false
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common__["d" /* DecimalPipe */]])
], FiatToUnitPipe);

//# sourceMappingURL=fiatToUnit.js.map

/***/ }),

/***/ 1206:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeysPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/*
 * Example use
 *  Simple: *ngFor="let item of giftCards | keys"
 *	With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let KeysPipe = class KeysPipe {
    transform(value, orderBy) {
        let keys = [];
        for (let key in value) {
            keys.push({
                key,
                value: value[key],
                order: orderBy ? value[key][orderBy] : null
            });
        }
        return keys;
    }
};
KeysPipe = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Pipe"])({
        name: 'keys'
    })
], KeysPipe);

//# sourceMappingURL=keys.js.map

/***/ }),

/***/ 1207:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OrderByPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/*
 * Example use
 *		Basic Array of single type: *ngFor="#todo of todoService.todos | orderBy : '-'"
 *		Multidimensional Array Sort on single column: *ngFor="#todo of todoService.todos | orderBy : ['-status']"
 *		Multidimensional Array Sort on multiple columns: *ngFor="#todo of todoService.todos | orderBy : ['status', '-title']"
 *    With an object with objects: *ngFor="let item of (itemsObject | keys : 'date') | orderBy : ['-order']"
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

let OrderByPipe = OrderByPipe_1 = class OrderByPipe {
    static _orderByComparator(a, b) {
        if (isNaN(parseFloat(a)) ||
            !isFinite(a) ||
            (isNaN(parseFloat(b)) || !isFinite(b))) {
            // Isn't a number so lowercase the string to properly compare
            if (a.toLowerCase() < b.toLowerCase())
                return -1;
            if (a.toLowerCase() > b.toLowerCase())
                return 1;
        }
        else {
            // Parse strings as numbers to compare properly
            if (parseFloat(a) < parseFloat(b))
                return -1;
            if (parseFloat(a) > parseFloat(b))
                return 1;
        }
        return 0; // equal each other
    }
    transform(input, [config = '+']) {
        if (!Array.isArray(input))
            return input;
        if (!Array.isArray(config) ||
            (Array.isArray(config) && config.length == 1)) {
            var propertyToCheck = !Array.isArray(config) ? config : config[0];
            var desc = propertyToCheck.substr(0, 1) == '-';
            // Basic array
            if (!propertyToCheck ||
                propertyToCheck == '-' ||
                propertyToCheck == '+') {
                return !desc ? input.sort() : input.sort().reverse();
            }
            else {
                var property = propertyToCheck.substr(0, 1) == '+' ||
                    propertyToCheck.substr(0, 1) == '-'
                    ? propertyToCheck.substr(1)
                    : propertyToCheck;
                return input.sort((a, b) => {
                    return !desc
                        ? OrderByPipe_1._orderByComparator(a[property], b[property])
                        : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                });
            }
        }
        else {
            // Loop over property of the array in order and sort
            return input.sort((a, b) => {
                for (var i = 0; i < config.length; i++) {
                    var desc = config[i].substr(0, 1) == '-';
                    var property = config[i].substr(0, 1) == '+' || config[i].substr(0, 1) == '-'
                        ? config[i].substr(1)
                        : config[i];
                    var comparison = !desc
                        ? OrderByPipe_1._orderByComparator(a[property], b[property])
                        : -OrderByPipe_1._orderByComparator(a[property], b[property]);
                    // Don't return 0 yet in case of needing to sort by next property
                    if (comparison != 0)
                        return comparison;
                }
                return 0; // equal each other
            });
        }
    }
};
OrderByPipe = OrderByPipe_1 = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Pipe"])({
        name: 'orderBy',
        pure: false
    })
], OrderByPipe);

var OrderByPipe_1;
//# sourceMappingURL=order-by.js.map

/***/ }),

/***/ 1208:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SatToFiatPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_rate_rate__ = __webpack_require__(113);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let SatToFiatPipe = class SatToFiatPipe {
    constructor(configProvider, rateProvider, decimalPipe) {
        this.configProvider = configProvider;
        this.rateProvider = rateProvider;
        this.decimalPipe = decimalPipe;
        this.walletSettings = this.configProvider.get().wallet.settings;
    }
    transform(amount, coin) {
        let amount_ = this.rateProvider.toFiat(amount, this.walletSettings.alternativeIsoCode, coin.toLowerCase());
        return (this.decimalPipe.transform(amount_ || 0, '1.2-2') +
            ' ' +
            this.walletSettings.alternativeIsoCode);
    }
};
SatToFiatPipe = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Pipe"])({
        name: 'satToFiat',
        pure: false
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common__["d" /* DecimalPipe */]])
], SatToFiatPipe);

//# sourceMappingURL=satToFiat.js.map

/***/ }),

/***/ 1209:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SatToUnitPipe; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let SatToUnitPipe = class SatToUnitPipe {
    constructor(decimalPipe) {
        this.decimalPipe = decimalPipe;
    }
    transform(amount, coin) {
        return (this.decimalPipe.transform(amount / 1e8, '1.2-6') +
            ' ' +
            coin.toUpperCase());
    }
};
SatToUnitPipe = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Pipe"])({
        name: 'satToUnit',
        pure: false
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common__["d" /* DecimalPipe */]])
], SatToUnitPipe);

//# sourceMappingURL=satToUnit.js.map

/***/ }),

/***/ 1210:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopyToClipboard; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_node_webkit_node_webkit__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};





// providers



let CopyToClipboard = class CopyToClipboard {
    constructor(dom, toastCtrl, clipboard, platform, logger, translate, nodeWebkitProvider) {
        this.toastCtrl = toastCtrl;
        this.clipboard = clipboard;
        this.platform = platform;
        this.logger = logger;
        this.translate = translate;
        this.nodeWebkitProvider = nodeWebkitProvider;
        this.logger.info('CopyToClipboardDirective initialized.');
        this.isCordova = this.platform.isCordova;
        this.isNW = this.platform.isNW;
        this.dom = dom;
    }
    copyBrowser() {
        let textarea = this.dom.createElement('textarea');
        this.dom.body.appendChild(textarea);
        textarea.value = this.value;
        textarea.select();
        this.dom.execCommand('copy');
    }
    copy() {
        if (!this.value) {
            return;
        }
        if (this.isCordova) {
            this.clipboard.copy(this.value);
        }
        else if (this.isNW) {
            this.nodeWebkitProvider.writeToClipboard(this.value);
        }
        else {
            this.copyBrowser();
        }
        let showSuccess = this.toastCtrl.create({
            message: this.translate.instant('Copied to clipboard'),
            duration: 1000,
            position: 'top',
            cssClass: this.platform.isIOS
                ? 'iosToastAfterHeader'
                : 'mdToastAfterHeader'
        });
        showSuccess.present();
    }
};
CopyToClipboard = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[copy-to-clipboard]',
        inputs: ['value: copy-to-clipboard'],
        host: {
            '(click)': 'copy()'
        }
    }),
    __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Inject"])(__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["b" /* DOCUMENT */])),
    __metadata("design:paramtypes", [Document,
        __WEBPACK_IMPORTED_MODULE_4_ionic_angular__["p" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_node_webkit_node_webkit__["a" /* NodeWebkitProvider */]])
], CopyToClipboard);

//# sourceMappingURL=copy-to-clipboard.js.map

/***/ }),

/***/ 1211:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IosScrollBgColor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/*
iOS allows the user to overshoot when scrolling, which can cause gaps to appear between
elements if colors are not properly set on the scroll container to match the colors
of surrounding elements. This directive sets the proper bg-color on the scroll container
to create the illusion of smooth, fluid, and connected elements.
*/
let IosScrollBgColor = class IosScrollBgColor {
    constructor(element) {
        this.element = element;
        this.bottomColor = '#f5f5f5';
    }
    ngOnChanges() {
        this.setScrollContentBackgroundColor(this.color);
    }
    setScrollContentBackgroundColor(color) {
        const scrollContent = this.element.nativeElement.getElementsByClassName('scroll-content')[0];
        const linearGradient = `linear-gradient(to bottom, ${this.color}, ${this.color} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%, ${this.bottomColor} 50%)`;
        color
            ? scrollContent.style.setProperty('background-image', linearGradient)
            : scrollContent.style.removeProperty('background-image');
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])('ios-scroll-bg-color'),
    __metadata("design:type", String)
], IosScrollBgColor.prototype, "color", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], IosScrollBgColor.prototype, "bottomColor", void 0);
IosScrollBgColor = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[ios-scroll-bg-color]',
        host: { class: 'ios-scroll-bg-color' }
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
], IosScrollBgColor);

//# sourceMappingURL=ios-scroll-bg-color.js.map

/***/ }),

/***/ 1212:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LongPress; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular_gestures_gesture__ = __webpack_require__(462);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let LongPress = class LongPress {
    constructor(el) {
        this.longPress = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.el = el.nativeElement;
    }
    ngOnInit() {
        this.pressGesture = new __WEBPACK_IMPORTED_MODULE_1_ionic_angular_gestures_gesture__["a" /* Gesture */](this.el, {
            recognizers: [[Hammer.Press, { time: 1000 }]]
        });
        this.pressGesture.listen();
        this.pressGesture.on('press', e => {
            this.longPress.emit(e);
        });
    }
    ngOnDestroy() {
        this.pressGesture.destroy();
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"])
], LongPress.prototype, "longPress", void 0);
LongPress = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[longPress]'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
], LongPress);

//# sourceMappingURL=long-press.js.map

/***/ }),

/***/ 1213:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NavbarBg; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

/*
Ionic does not currently appear to provide an API to set the navbar background
to an arbitrary color. This directive enables this functionality.
*/
let NavbarBg = class NavbarBg {
    constructor(element) {
        this.element = element;
    }
    ngOnChanges() {
        this.setNewNavbarColor(this.color);
    }
    setNewNavbarColor(color) {
        const toolbarBg = this.element.nativeElement.getElementsByClassName('toolbar-background')[0];
        color
            ? toolbarBg.style.setProperty('background', color, 'important')
            : toolbarBg.style.removeProperty('background');
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])('navbar-bg'),
    __metadata("design:type", String)
], NavbarBg.prototype, "color", void 0);
NavbarBg = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[navbar-bg]'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
], NavbarBg);

//# sourceMappingURL=navbar-bg.js.map

/***/ }),

/***/ 1214:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NoLowFee; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Provider


let NoLowFee = class NoLowFee {
    constructor(configProvider, elem, logger, navCtrl, popupProvider) {
        this.configProvider = configProvider;
        this.elem = elem;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger.info('Hello NoLowFee Directive');
        this.configWallet = this.configProvider.get().wallet;
    }
    noLowFee() {
        if (this.configWallet.settings.feeLevel &&
            this.configWallet.settings.feeLevel.match(/conomy/)) {
            this.logger.debug('Economy Fee setting... disabling link:' +
                this.elem.nativeElement.innerText);
            this.popupProvider
                .ionicAlert('Low Fee Error', 'Please change your Bastoji Network Fee Policy setting to Normal or higher to use this service')
                .then(() => {
                this.navCtrl.pop();
            });
        }
    }
};
NoLowFee = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[no-low-fee]',
        host: {
            '(click)': 'noLowFee()'
        }
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__["a" /* PopupProvider */]])
], NoLowFee);

//# sourceMappingURL=no-low-fee.js.map

/***/ }),

/***/ 1215:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_item_editable_item__ = __webpack_require__(1216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__expandable_header_expandable_header__ = __webpack_require__(1482);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mini_modal_mini_modal__ = __webpack_require__(713);



const COMPONENTS = [
    __WEBPACK_IMPORTED_MODULE_2__mini_modal_mini_modal__["a" /* MINI_MODAL_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_1__expandable_header_expandable_header__["a" /* EXPANDABLE_HEADER_COMPONENTS */],
    __WEBPACK_IMPORTED_MODULE_0__editable_item_editable_item__["a" /* EditableItemComponent */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = COMPONENTS;

//# sourceMappingURL=components.js.map

/***/ }),

/***/ 1216:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EditableItemComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs__ = __webpack_require__(1217);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators__ = __webpack_require__(359);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// Providers

let EditableItemComponent = class EditableItemComponent {
    constructor(platformProvider) {
        this.platformProvider = platformProvider;
        this.textInput = new __WEBPACK_IMPORTED_MODULE_1__angular_forms__["b" /* FormControl */]('');
        this.valChange = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.focus = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"]();
        this.listenerForEnsuringBlurOnIos = (e) => {
            e.stopPropagation();
            e.preventDefault();
        };
        this.textInput.valueChanges
            .pipe(Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["debounceTime"])(600), Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["distinctUntilChanged"])(), Object(__WEBPACK_IMPORTED_MODULE_3_rxjs_operators__["skip"])(1))
            .subscribe(value => {
            this.value = value;
            this.saving = true;
            if (!this.value) {
                this.value = '';
            }
            this.valChange.emit(value);
            __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(2000)
                .toPromise()
                .then(() => {
                this.saving = false;
            });
        });
        this.saving = false;
        this.isFocused = false;
    }
    ngAfterViewInit() {
        this.resizeTextarea();
    }
    resizeTextarea() {
        if (!this.moveCaret)
            return;
        const textArea = this.moveCaret.nativeElement.getElementsByClassName('text-input')[0];
        textArea.style.overflow = 'hidden';
        textArea.style.minHeight = '31px';
        textArea.style.height = 'auto';
        textArea.style.height = textArea.scrollHeight + 'px';
    }
    saveValueNow() {
        this.isFocused = false;
        if (this.platformProvider.isCordova) {
            this.focus.emit(false);
        }
        if (!this.value) {
            this.value = '';
        }
        this.valChange.emit(this.value);
        this.disableClickBlock();
    }
    toggleValueUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isFocused)
                return;
            if (this.platformProvider.isCordova) {
                this.focus.emit(true);
            }
            this.isFocused = true;
            yield __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(150).toPromise();
            if (this.itemTextarea) {
                this.itemTextarea.setFocus();
            }
            if (this.moveCaret) {
                const elem = this.moveCaret.nativeElement.getElementsByTagName('textarea')[0];
                if (this.value) {
                    elem.setSelectionRange(this.value.length, this.value.length);
                }
            }
            this.enableClickBlock();
        });
    }
    getIonApp() {
        return document.getElementsByTagName('ion-app')[0];
    }
    enableClickBlock() {
        // Ensures that tapping on other clickable elements on a page
        // only blurs the textarea (and ignores any other click listeners)
        this.getIonApp().addEventListener('click', this.listenerForEnsuringBlurOnIos, true);
    }
    disableClickBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            yield __WEBPACK_IMPORTED_MODULE_2_rxjs__["Observable"].timer(100).toPromise();
            this.getIonApp().removeEventListener('click', this.listenerForEnsuringBlurOnIos, true);
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('itemTextarea'),
    __metadata("design:type", Object)
], EditableItemComponent.prototype, "itemTextarea", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('itemTextarea', { read: __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"] }),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"])
], EditableItemComponent.prototype, "moveCaret", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"])
], EditableItemComponent.prototype, "valChange", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Output"])(),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_0__angular_core__["EventEmitter"])
], EditableItemComponent.prototype, "focus", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], EditableItemComponent.prototype, "value", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])(),
    __metadata("design:type", String)
], EditableItemComponent.prototype, "itemPlaceholder", void 0);
EditableItemComponent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'editable-item',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/components/editable-item/editable-item.html"*/'<div ion-item [ngClass]="{\'no-border\': isFocused}" (mousedown)="toggleValueUpdate()">\n    <ng-content select="[item-label]"></ng-content>\n    <div class="spinner" [ngClass]="{\'spin-fade\': saving}">\n    </div>\n</div>\n<div ion-item class="item-text" [hidden]="!value && !isFocused">\n    <ion-textarea rows="1" [ngClass]="{\'ios-margin-fix\': platformProvider.isCordova}" (input)="resizeTextarea()" (ionFocus)="toggleValueUpdate()"\n        spellcheck="false" #itemTextarea [formControl]="textInput" (ionBlur)="saveValueNow()" class="item-textarea" [(ngModel)]="value"\n        placeholder="{{ itemPlaceholder }}"></ion-textarea>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/components/editable-item/editable-item.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__["a" /* PlatformProvider */]])
], EditableItemComponent);

//# sourceMappingURL=editable-item.js.map

/***/ }),

/***/ 122:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmazonProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// providers



let AmazonProvider = class AmazonProvider {
    constructor(http, logger, persistenceProvider, homeIntegrationsProvider, configProvider) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.logger.info('AmazonProvider initialized.');
        this.credentials = {};
        /*
        * Development: 'testnet'
        * Production: 'livenet'
        */
        this.credentials.NETWORK = 'livenet';
        this.credentials.BITPAY_API_URL =
            this.credentials.NETWORK === 'testnet'
                ? 'https://test.bitpay.com'
                : 'https://bitpay.com';
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    setCurrencyByLocation() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(resolve => {
                this.getSupportedCards()
                    .then(currency => {
                    this.setCountryParameters(currency);
                    resolve();
                })
                    .catch(() => {
                    this.setCountryParameters();
                    resolve();
                });
            });
        });
    }
    setCountryParameters(currency) {
        switch (currency) {
            case 'JPY':
                this.currency = currency;
                this.country = 'japan';
                this.limitPerDay = 200000;
                this.redeemAmazonUrl = 'https://www.amazon.co.jp/gc/redeem?claimCode=';
                this.amazonNetwork = this.getNetwork() + '-japan';
                this.pageTitle = 'Amazon.co.jp ';
                this.onlyIntegers = true;
                break;
            default:
                // For USA
                this.currency = 'USD';
                this.country = 'usa';
                this.limitPerDay = 2000;
                this.redeemAmazonUrl = 'https://www.amazon.com/gc/redeem?claimCode=';
                this.amazonNetwork = this.getNetwork();
                this.pageTitle = 'Amazon.com Gift Cards';
                this.onlyIntegers = false;
                break;
        }
        this.logger.info('Set Amazon Gift Card to: ' + this.currency);
    }
    savePendingGiftCard(gc, opts, cb) {
        this.persistenceProvider
            .getAmazonGiftCards(this.amazonNetwork)
            .then(oldGiftCards => {
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](oldGiftCards)) {
                oldGiftCards = JSON.parse(oldGiftCards);
            }
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](gc)) {
                gc = JSON.parse(gc);
            }
            var inv = oldGiftCards || {};
            inv[gc.invoiceId] = gc;
            if (opts && (opts.error || opts.status)) {
                inv[gc.invoiceId] = __WEBPACK_IMPORTED_MODULE_2_lodash__["assign"](inv[gc.invoiceId], opts);
            }
            if (opts && opts.remove) {
                delete inv[gc.invoiceId];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setAmazonGiftCards(this.amazonNetwork, inv);
            return cb(null);
        });
    }
    getPendingGiftCards(cb) {
        this.persistenceProvider
            .getAmazonGiftCards(this.amazonNetwork)
            .then(giftCards => {
            return cb(null, giftCards && !__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](giftCards) ? giftCards : null);
        })
            .catch(err => {
            return cb(err);
        });
    }
    createBitPayInvoice(data, cb) {
        var dataSrc = {
            currency: data.currency,
            amount: data.amount,
            clientId: data.uuid,
            email: data.email,
            buyerSelectedTransactionCurrency: data.buyerSelectedTransactionCurrency
        };
        this.http
            .post(this.credentials.BITPAY_API_URL + '/amazon-gift/pay', dataSrc)
            .subscribe(data => {
            this.logger.info('BitPay Create Invoice: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('BitPay Create Invoice: ERROR ' + data.error.message);
            return cb(data.error);
        });
    }
    getBitPayInvoice(id, cb) {
        this.http
            .get(this.credentials.BITPAY_API_URL + '/invoices/' + id)
            .subscribe((data) => {
            this.logger.info('BitPay Get Invoice: SUCCESS');
            return cb(null, data.data);
        }, data => {
            this.logger.error('BitPay Get Invoice: ERROR ' + data.error.message);
            return cb(data.error.message);
        });
    }
    createGiftCard(data, cb) {
        var dataSrc = {
            clientId: data.uuid,
            invoiceId: data.invoiceId,
            accessKey: data.accessKey
        };
        this.http
            .post(this.credentials.BITPAY_API_URL + '/amazon-gift/redeem', dataSrc)
            .subscribe((data) => {
            var status = data.status == 'new'
                ? 'PENDING'
                : data.status == 'paid'
                    ? 'PENDING'
                    : data.status;
            data.status = status;
            this.logger.info('Amazon Gift Card Create/Update: ' + status);
            return cb(null, data);
        }, data => {
            this.logger.error('Amazon Gift Card Create/Update: ' + data.message);
            return cb(data);
        });
    }
    cancelGiftCard(data, cb) {
        var dataSrc = {
            clientId: data.uuid,
            invoiceId: data.invoiceId,
            accessKey: data.accessKey
        };
        this.http
            .post(this.credentials.BITPAY_API_URL + '/amazon-gift/cancel', dataSrc)
            .subscribe(data => {
            this.logger.info('Amazon Gift Card Cancel: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Amazon Gift Card Cancel: ' + data.message);
            return cb(data);
        });
    }
    getSupportedCards() {
        return new Promise((resolve, reject) => {
            this.http
                .get(this.credentials.BITPAY_API_URL + '/amazon-gift/supportedCards')
                .subscribe(data => {
                this.logger.info('Amazon Gift Card Supported Cards: SUCCESS');
                return resolve(data['supportedCards'][0]);
            }, data => {
                this.logger.error('Amazon Gift Card Supported Cards: ' + data.message);
                return reject(data);
            });
        });
    }
    register() {
        const showItem = !!this.configProvider.get().showIntegration['amazon'];
        this.homeIntegrationsProvider.register({
            name: 'amazon',
            title: 'Amazon Gift Cards',
            icon: 'assets/img/amazon/icon-amazon.svg',
            page: 'AmazonPage',
            show: showItem
        });
    }
};
AmazonProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */]])
], AmazonProvider);

//# sourceMappingURL=amazon.js.map

/***/ }),

/***/ 124:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers







let CoinbaseProvider = class CoinbaseProvider {
    constructor(http, logger, persistenceProvider, platformProvider, homeIntegrationsProvider, configProvider, feeProvider, appProvider, events) {
        this.http = http;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.feeProvider = feeProvider;
        this.appProvider = appProvider;
        this.events = events;
        this.init = __WEBPACK_IMPORTED_MODULE_10_lodash__["throttle"](cb => {
            if (__WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](this.credentials.CLIENT_ID)) {
                return cb('Coinbase is Disabled. Missing credentials.');
            }
            this.logger.debug('Trying to initialize Coinbase...');
            this.persistenceProvider
                .getCoinbaseToken(this.credentials.NETWORK)
                .then(accessToken => {
                if (!accessToken)
                    return cb();
                this._getMainAccountId(accessToken, (err, accountId) => {
                    if (err) {
                        if (!err.errors)
                            return cb(err);
                        if (err.errors && !__WEBPACK_IMPORTED_MODULE_10_lodash__["isArray"](err.errors))
                            return cb(err);
                        let expiredToken;
                        for (let i = 0; i < err.errors.length; i++) {
                            if (err.errors[i].id == 'expired_token')
                                expiredToken = true;
                        }
                        if (expiredToken) {
                            this.logger.debug('Refresh token');
                            this.persistenceProvider
                                .getCoinbaseRefreshToken(this.credentials.NETWORK)
                                .then(refreshToken => {
                                this._refreshToken(refreshToken, (err, newToken) => {
                                    if (err)
                                        return cb(err);
                                    this._getMainAccountId(newToken, (err, accountId) => {
                                        if (err)
                                            return cb(err);
                                        return cb(null, {
                                            accessToken: newToken,
                                            accountId
                                        });
                                    });
                                });
                            })
                                .catch(err => {
                                return cb(err);
                            });
                        }
                        else {
                            return cb(err);
                        }
                    }
                    else {
                        return cb(null, {
                            accessToken,
                            accountId
                        });
                    }
                });
            })
                .catch(() => {
                return cb();
            });
        }, 10000);
        this.updatePendingTransactions = __WEBPACK_IMPORTED_MODULE_10_lodash__["throttle"](() => {
            this.logger.debug('Updating coinbase pending transactions...');
            var pendingTransactions = {
                data: {}
            };
            this.getPendingTransactions(pendingTransactions);
        }, 20000);
        this.logger.info('Coinbase initialized.');
        this.credentials = {};
        this.isCordova = this.platformProvider.isCordova;
        this.priceSensitivity = [
            {
                value: 0.5,
                name: '0.5%'
            },
            {
                value: 1,
                name: '1%'
            },
            {
                value: 2,
                name: '2%'
            },
            {
                value: 5,
                name: '5%'
            },
            {
                value: 10,
                name: '10%'
            }
        ];
        this.selectedPriceSensitivity = this.priceSensitivity[1];
        this.events.subscribe('bwsEvent', (_, type, n) => {
            if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet') {
                this.isActive((_, isActive) => {
                    // Update Coinbase
                    if (isActive)
                        this.updatePendingTransactions();
                });
            }
        });
    }
    setCredentials() {
        if (!this.appProvider.servicesInfo ||
            !this.appProvider.servicesInfo.coinbase) {
            return;
        }
        var coinbase = this.appProvider.servicesInfo.coinbase;
        /*
         * Development: 'testnet'
         * Production: 'livenet'
         */
        this.credentials.NETWORK = 'livenet';
        // Coinbase permissions
        this.credentials.SCOPE =
            '' +
                'wallet:accounts:read,' +
                'wallet:addresses:read,' +
                'wallet:addresses:create,' +
                'wallet:user:read,' +
                'wallet:user:email,' +
                'wallet:buys:read,' +
                'wallet:buys:create,' +
                'wallet:sells:read,' +
                'wallet:sells:create,' +
                'wallet:transactions:read,' +
                'wallet:transactions:send,' +
                'wallet:transactions:send:bypass-2fa,' +
                'wallet:payment-methods:read';
        // NW has a bug with Window Object
        this.credentials.REDIRECT_URI = this.isCordova
            ? coinbase.redirect_uri.mobile
            : coinbase.redirect_uri.desktop;
        if (this.credentials.NETWORK == 'testnet') {
            this.credentials.HOST = coinbase.sandbox.host;
            this.credentials.API = coinbase.sandbox.api;
            this.credentials.CLIENT_ID = coinbase.sandbox.client_id;
            this.credentials.CLIENT_SECRET = coinbase.sandbox.client_secret;
        }
        else {
            this.credentials.HOST = coinbase.production.host;
            this.credentials.API = coinbase.production.api;
            this.credentials.CLIENT_ID = coinbase.production.client_id;
            this.credentials.CLIENT_SECRET = coinbase.production.client_secret;
        }
        // Force to use specific version
        this.credentials.API_VERSION = '2017-10-31';
    }
    _afterTokenReceived(data, cb) {
        if (data && data.access_token && data.refresh_token) {
            this.persistenceProvider.setCoinbaseToken(this.credentials.NETWORK, data.access_token);
            this.persistenceProvider.setCoinbaseRefreshToken(this.credentials.NETWORK, data.refresh_token);
            this.homeIntegrationsProvider.updateLink('coinbase', data.access_token); // Name, Token
            return cb(null, data.access_token);
        }
        else {
            return cb('Could not get the access token');
        }
    }
    getErrorsAsString(data) {
        let errData;
        try {
            if (data && data.errors)
                errData = data.errors;
            else if (data && data.error)
                errData = data.error_description;
            else
                return JSON.stringify(data);
            if (!__WEBPACK_IMPORTED_MODULE_10_lodash__["isArray"](errData)) {
                errData = errData && errData.message ? errData.message : errData;
                return errData;
            }
            if (__WEBPACK_IMPORTED_MODULE_10_lodash__["isArray"](errData)) {
                var errStr = '';
                for (var i = 0; i < errData.length; i++) {
                    errStr = errStr + errData[i].message + '. ';
                }
                return errStr;
            }
            return JSON.stringify(errData);
        }
        catch (e) {
            this.logger.error(e);
            return e;
        }
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    getStoredToken(cb) {
        this.persistenceProvider
            .getCoinbaseToken(this.credentials.NETWORK)
            .then(accessToken => {
            if (!accessToken)
                return cb();
            return cb(accessToken);
        })
            .catch(err => {
            return cb(err);
        });
    }
    getAvailableCurrency() {
        var config = this.configProvider.get().wallet.settings;
        // ONLY "USD"
        switch (config.alternativeIsoCode) {
            default:
                return 'USD';
        }
    }
    checkEnoughFundsForFee(amount, cb) {
        this._getNetAmount(amount, (err, reducedAmount) => {
            if (err)
                return cb(err);
            // Check if transaction has enough funds to transfer bastoji from Coinbase to Sqoin
            if (reducedAmount < 0) {
                return cb('Not enough funds for fee');
            }
            return cb();
        });
    }
    getSignupUrl() {
        return this.credentials.HOST + '/signup';
    }
    getSupportUrl() {
        return 'https://support.coinbase.com/';
    }
    getOauthCodeUrl() {
        return (this.credentials.HOST +
            '/oauth/authorize?response_type=code&client_id=' +
            this.credentials.CLIENT_ID +
            '&redirect_uri=' +
            this.credentials.REDIRECT_URI +
            '&state=SECURE_RANDOM&scope=' +
            this.credentials.SCOPE +
            '&meta[send_limit_amount]=1000&meta[send_limit_currency]=USD&meta[send_limit_period]=day');
    }
    _getNetAmount(amount, cb) {
        // Fee Normal for a single transaction (450 bytes)
        var txNormalFeeKB = 450 / 1000;
        this.feeProvider
            .getFeeRate('btc', 'livenet', 'normal')
            .then(feePerKb => {
            var feeBTJ = ((feePerKb * txNormalFeeKB) / 100000000).toFixed(8);
            return cb(null, amount - parseInt(feeBTJ, 10), parseInt(feeBTJ, 10));
        })
            .catch(() => {
            return cb('Could not get fee rate');
        });
    }
    getToken(code, cb) {
        let url = this.credentials.HOST + '/oauth/token';
        let data = {
            grant_type: 'authorization_code',
            code,
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: GET Access Token: SUCCESS');
            // Show pending task from the UI
            this._afterTokenReceived(data, cb);
        }, data => {
            this.logger.error('Coinbase: GET Access Token: ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    _refreshToken(refreshToken, cb) {
        let url = this.credentials.HOST + '/oauth/token';
        let data = {
            grant_type: 'refresh_token',
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI,
            refresh_token: refreshToken
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Refresh Access Token SUCCESS');
            this._afterTokenReceived(data, cb);
        }, data => {
            this.logger.error('Coinbase: Refresh Access Token ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    _getMainAccountId(accessToken, cb) {
        this.getAccounts(accessToken, (err, a) => {
            if (err)
                return cb(err);
            var data = a.data;
            for (var i = 0; i < data.length; i++) {
                if (data[i].primary &&
                    data[i].type == 'wallet' &&
                    data[i].currency &&
                    data[i].currency.code == 'BTJ') {
                    return cb(null, data[i].id);
                }
            }
            this.logout();
            return cb('Your primary account should be a BTJ WALLET. Set your wallet account as primary and try again');
        });
    }
    getAccounts(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2' + '/accounts';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Accounts SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Accounts ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    logout() {
        this.persistenceProvider.removeCoinbaseToken(this.credentials.NETWORK);
        this.persistenceProvider.removeCoinbaseRefreshToken(this.credentials.NETWORK);
        this.persistenceProvider.removeCoinbaseTxs(this.credentials.NETWORK);
        this.homeIntegrationsProvider.updateLink('coinbase', null); // Name, Token
    }
    isActive(cb) {
        if (__WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](this.credentials.CLIENT_ID))
            return cb(false);
        this.persistenceProvider
            .getCoinbaseToken(this.credentials.NETWORK)
            .then(accessToken => {
            return cb(!!accessToken);
        });
    }
    getAccount(token, _, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Account SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Account ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getAuthorizationInformation(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/user/auth';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Authorization Information SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Authorization Information ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getCurrentUser(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/user';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Current User SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Current User ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getBuyOrder(token, accountId, buyId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/buys/' + buyId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Info SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Info ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getTransaction(token, accountId, transactionId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/transactions/' +
            transactionId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Transaction SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Transaction ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getAddressTransactions(token, accountId, addressId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/addresses/' +
            addressId +
            '/transactions';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Address Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Address Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getTransactions(token, accountId, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    paginationTransactions(token, Url, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.API + Url;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Pagination Transactions SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Pagination Transactions ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellPrice(token, currency, cb) {
        let url = this.credentials.API + '/v2/prices/sell?currency=' + currency;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Price SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Price ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyPrice(token, currency, cb) {
        let url = this.credentials.API + '/v2/prices/buy?currency=' + currency;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Price: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Price ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getPaymentMethods(token, cb) {
        let url = this.credentials.API + '/v2/payment-methods';
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Payment Methods SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Payment Methods ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    getPaymentMethod(token, paymentMethodId, cb) {
        let url = this.credentials.API + '/v2/payment-methods/' + paymentMethodId;
        let headers = {
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        };
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Get Payment Method SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Get Payment Method ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellRequest(token, accountId, dataSrc, cb) {
        let data = {
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            payment_method: dataSrc.payment_method || null,
            commit: dataSrc.commit || false,
            quote: dataSrc.quote || false
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/sells';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Request SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Request ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sellCommit(token, accountId, sellId, cb) {
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/sells/' +
            sellId +
            '/commit';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, null, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Sell Commit SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Sell Commit ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyRequest(token, accountId, dataSrc, cb) {
        let data = {
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            payment_method: dataSrc.payment_method || null,
            commit: dataSrc.commit || false,
            quote: dataSrc.quote || false
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/buys';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Request SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Request ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    buyCommit(token, accountId, buyId, cb) {
        let url = this.credentials.API +
            '/v2/accounts/' +
            accountId +
            '/buys/' +
            buyId +
            '/commit';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, null, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Buy Commit SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Buy Commit ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    createAddress(token, accountId, dataSrc, cb) {
        let data = {
            name: dataSrc.name
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/addresses';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Create Address SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Create Address ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    sendTo(token, accountId, dataSrc, cb) {
        let data = {
            type: 'send',
            to: dataSrc.to,
            amount: dataSrc.amount,
            currency: dataSrc.currency,
            description: dataSrc.description
        };
        let url = this.credentials.API + '/v2/accounts/' + accountId + '/transactions';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            'CB-VERSION': this.credentials.API_VERSION,
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Coinbase: Create Address SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Coinbase: Create Address ERROR ' +
                data.status +
                '. ' +
                this.getErrorsAsString(data.error));
            return cb(data.error);
        });
    }
    // Pending transactions
    savePendingTransaction(ctx, opts, cb) {
        this._savePendingTransaction(ctx, opts, cb);
    }
    _savePendingTransaction(ctx, opts, cb) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(oldTxs => {
            if (__WEBPACK_IMPORTED_MODULE_10_lodash__["isString"](oldTxs)) {
                oldTxs = JSON.parse(oldTxs);
            }
            if (__WEBPACK_IMPORTED_MODULE_10_lodash__["isString"](ctx)) {
                ctx = JSON.parse(ctx);
            }
            var tx = oldTxs || {};
            tx[ctx.id] = ctx;
            if (opts && (opts.error || opts.status)) {
                tx[ctx.id] = __WEBPACK_IMPORTED_MODULE_10_lodash__["assign"](tx[ctx.id], opts);
            }
            if (opts && opts.remove) {
                delete tx[ctx.id];
            }
            tx = JSON.stringify(tx);
            this.persistenceProvider.setCoinbaseTxs(this.credentials.NETWORK, tx);
            return cb();
        });
    }
    getPendingTransactions(coinbasePendingTransactions) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(txs => {
            txs = txs ? JSON.parse(txs) : {};
            coinbasePendingTransactions.data = __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](txs) ? null : txs;
            this.init((err, data) => {
                if (err || __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](data)) {
                    if (err)
                        this.logger.error(err);
                    return;
                }
                var accessToken = data.accessToken;
                var accountId = data.accountId;
                __WEBPACK_IMPORTED_MODULE_10_lodash__["forEach"](coinbasePendingTransactions.data, (dataFromStorage, txId) => {
                    if ((dataFromStorage.type == 'sell' &&
                        dataFromStorage.status == 'completed') ||
                        (dataFromStorage.type == 'buy' &&
                            dataFromStorage.status == 'completed') ||
                        dataFromStorage.status == 'error' ||
                        (dataFromStorage.type == 'send' &&
                            dataFromStorage.status == 'completed'))
                        return;
                    this.getTransaction(accessToken, accountId, txId, (err, tx) => {
                        if (err || __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](tx) || (tx.data && tx.data.error)) {
                            this._savePendingTransaction(dataFromStorage, {
                                status: 'error',
                                error: tx.data && tx.data.error ? tx.data.error : err
                            }, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                            return;
                        }
                        this._updateCoinbasePendingTransactions(dataFromStorage /* , tx.data */);
                        coinbasePendingTransactions.data[txId] = dataFromStorage;
                        if (tx.data.type == 'send' &&
                            tx.data.status == 'completed' &&
                            tx.data.from) {
                            this.sellPrice(accessToken, dataFromStorage.sell_price_currency, (err, s) => {
                                if (err) {
                                    this._savePendingTransaction(dataFromStorage, {
                                        status: 'error',
                                        error: err
                                    }, err => {
                                        if (err)
                                            this.logger.debug(err);
                                        this._updateTxs(coinbasePendingTransactions);
                                    });
                                    return;
                                }
                                var newSellPrice = s.data.amount;
                                var variance = Math.abs(((newSellPrice - dataFromStorage.sell_price_amount) /
                                    dataFromStorage.sell_price_amount) *
                                    100);
                                if (variance < dataFromStorage.price_sensitivity.value) {
                                    this._sellPending(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                                }
                                else {
                                    this._savePendingTransaction(dataFromStorage, {
                                        status: 'error',
                                        error: {
                                            errors: [
                                                {
                                                    message: 'Price falls over the selected percentage'
                                                }
                                            ]
                                        }
                                    }, err => {
                                        if (err)
                                            this.logger.debug(err);
                                        this._updateTxs(coinbasePendingTransactions);
                                    });
                                }
                            });
                        }
                        else if (tx.data.type == 'buy' &&
                            tx.data.status == 'completed' &&
                            tx.data.buy) {
                            this._sendToWallet(dataFromStorage, accessToken, accountId, coinbasePendingTransactions);
                        }
                        else {
                            this._savePendingTransaction(dataFromStorage, {}, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                        }
                    });
                });
            });
        });
    }
    _updateCoinbasePendingTransactions(obj /*, */) {
        for (var i = 1; i < arguments.length; i++) {
            for (var prop in arguments[i]) {
                var val = arguments[i][prop];
                if (typeof val == 'object')
                    this._updateCoinbasePendingTransactions(obj[prop] /* , val */);
                else
                    obj[prop] = val ? val : obj[prop];
            }
        }
        return obj;
    }
    _updateTxs(coinbasePendingTransactions) {
        this.persistenceProvider
            .getCoinbaseTxs(this.credentials.NETWORK)
            .then(txs => {
            txs = txs ? JSON.parse(txs) : {};
            coinbasePendingTransactions.data = __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](txs) ? null : txs;
        });
    }
    _sellPending(tx, accessToken, accountId, coinbasePendingTransactions) {
        var data = tx.amount;
        data['payment_method'] = tx.payment_method || null;
        data['commit'] = true;
        this.sellRequest(accessToken, accountId, data, (err, res) => {
            if (err) {
                this._savePendingTransaction(tx, {
                    status: 'error',
                    error: err
                }, err => {
                    if (err)
                        this.logger.debug(err);
                    this._updateTxs(coinbasePendingTransactions);
                });
            }
            else {
                if (res.data && !res.data.transaction) {
                    this._savePendingTransaction(tx, {
                        status: 'error',
                        error: {
                            errors: [{ message: 'Sell order: transaction not found.' }]
                        }
                    }, err => {
                        if (err)
                            this.logger.debug(err);
                        this._updateTxs(coinbasePendingTransactions);
                    });
                    return;
                }
                this.getTransaction(accessToken, accountId, res.data.transaction.id, (err, updatedTx) => {
                    if (err) {
                        this._savePendingTransaction(tx, {
                            status: 'error',
                            error: err
                        }, err => {
                            if (err)
                                this.logger.error(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                        return;
                    }
                    this._savePendingTransaction(tx, {
                        remove: true
                    }, () => {
                        this._savePendingTransaction(updatedTx.data, {}, err => {
                            if (err)
                                this.logger.debug(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                    });
                });
            }
        });
    }
    _sendToWallet(tx, accessToken, accountId, coinbasePendingTransactions) {
        if (!tx)
            return;
        var desc = this.appProvider.info.nameCase + ' Wallet';
        this._getNetAmount(tx.amount.amount, (err, amountBTJ, feeBTJ) => {
            if (err) {
                this._savePendingTransaction(tx, {
                    status: 'error',
                    error: { errors: [{ message: err }] }
                }, err => {
                    if (err)
                        this.logger.debug(err);
                    this._updateTxs(coinbasePendingTransactions);
                });
                return;
            }
            var data = {
                to: tx.toAddr,
                amount: amountBTJ,
                currency: tx.amount.currency,
                description: desc,
                fee: feeBTJ
            };
            this.sendTo(accessToken, accountId, data, (err, res) => {
                if (err) {
                    this._savePendingTransaction(tx, {
                        status: 'error',
                        error: err
                    }, err => {
                        if (err)
                            this.logger.debug(err);
                        this._updateTxs(coinbasePendingTransactions);
                    });
                }
                else {
                    if (res.data && !res.data.id) {
                        this._savePendingTransaction(tx, {
                            status: 'error',
                            error: {
                                errors: [
                                    { message: 'Transactions not found in Coinbase.com' }
                                ]
                            }
                        }, err => {
                            if (err)
                                this.logger.debug(err);
                            this._updateTxs(coinbasePendingTransactions);
                        });
                        return;
                    }
                    this.getTransaction(accessToken, accountId, res.data.id, (err, sendTx) => {
                        if (err) {
                            this._savePendingTransaction(tx, {
                                status: 'error',
                                error: err
                            }, function (err) {
                                if (err)
                                    this.logger.error(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                            return;
                        }
                        this._savePendingTransaction(tx, {
                            remove: true
                        }, err => {
                            if (err)
                                this.logger.error(err);
                            this._savePendingTransaction(sendTx.data, {}, err => {
                                if (err)
                                    this.logger.debug(err);
                                this._updateTxs(coinbasePendingTransactions);
                            });
                        });
                    });
                }
            });
        });
    }
    register() {
        this.isActive(isActive => {
            this.homeIntegrationsProvider.register({
                name: 'coinbase',
                title: 'Coinbase',
                icon: 'assets/img/coinbase/coinbase-icon.png',
                location: '33 Countries',
                page: 'CoinbasePage',
                show: !!this.configProvider.get().showIntegration['coinbase'],
                linked: !!isActive
            });
        });
    }
};
CoinbaseProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_9__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_4__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */]])
], CoinbaseProvider);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 135:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguageProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_moment__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






let LanguageProvider = class LanguageProvider {
    constructor(logger, translate, configProvider) {
        this.logger = logger;
        this.translate = translate;
        this.configProvider = configProvider;
        this.languages = [
            {
                name: 'English',
                isoCode: 'en'
            },
            {
                name: 'Espaol',
                isoCode: 'es'
            },
            {
                name: 'Franais',
                isoCode: 'fr'
            },
            {
                name: 'Italiano',
                isoCode: 'it'
            },
            {
                name: 'Nederlands',
                isoCode: 'nl'
            },
            {
                name: 'Polski',
                isoCode: 'pl'
            },
            {
                name: 'Deutsch',
                isoCode: 'de'
            },
            {
                name: '',
                isoCode: 'ja',
                useIdeograms: true
            },
            {
                name: '',
                isoCode: 'zh',
                useIdeograms: true
            },
            {
                name: 'P',
                isoCode: 'ru'
            },
            {
                name: 'Portugus',
                isoCode: 'pt'
            }
        ];
        this.logger.info('LanguageProvider initialized.');
        this.translate.onLangChange.subscribe(event => {
            this.logger.info('Setting new default language to: ' + event.lang);
        });
    }
    load() {
        let lang = this.configProvider.get().wallet.settings.defaultLanguage;
        if (!__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](lang))
            this.current = lang;
        else {
            // Get from browser
            const browserLang = this.translate.getBrowserLang();
            this.current = this.getName(browserLang)
                ? browserLang
                : this.getDefault();
        }
        this.logger.info('Default language: ' + this.current);
        this.translate.setDefaultLang(this.current);
        __WEBPACK_IMPORTED_MODULE_5_moment__["locale"](this.current);
    }
    set(lang) {
        this.current = lang;
        this.translate.use(lang);
        __WEBPACK_IMPORTED_MODULE_5_moment__["locale"](lang);
        this.configProvider.set({
            wallet: { settings: { defaultLanguage: lang } }
        });
    }
    getName(lang) {
        return __WEBPACK_IMPORTED_MODULE_4_lodash__["result"](__WEBPACK_IMPORTED_MODULE_4_lodash__["find"](this.languages, {
            isoCode: lang
        }), 'name');
    }
    getDefault() {
        return this.languages[0]['isoCode'];
    }
    getCurrent() {
        return this.current;
    }
    getAvailables() {
        return this.languages;
    }
};
LanguageProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3__config_config__["a" /* ConfigProvider */]])
], LanguageProvider);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 14:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProfileProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_language_language__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__models_profile_profile_model__ = __webpack_require__(1174);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





// providers










// models

let ProfileProvider = class ProfileProvider {
    constructor(logger, persistenceProvider, configProvider, replaceParametersProvider, bwcProvider, bwcErrorProvider, platformProvider, appProvider, languageProvider, events, popupProvider, onGoingProcessProvider, translate) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bwcProvider = bwcProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.languageProvider = languageProvider;
        this.events = events;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.wallet = {};
        this.UPDATE_PERIOD = 15;
        this.validationLock = false;
        this.errors = this.bwcProvider.getErrors();
        this.throttledBwsEvent = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((n, wallet) => {
            this.newBwsEvent(n, wallet);
        }, 10000);
    }
    updateWalletSettings(wallet) {
        let config = this.configProvider.get();
        let defaults = this.configProvider.getDefaults();
        let defaultColor = this.appProvider.info.nameCase == 'Sqoin' ? '#1abb9b' : '#647ce8';
        // this.config.whenAvailable( (config) => { TODO
        wallet.usingCustomBWS =
            config.bwsFor &&
                config.bwsFor[wallet.id] &&
                config.bwsFor[wallet.id] != defaults.bws.url;
        wallet.name =
            (config.aliasFor && config.aliasFor[wallet.id]) ||
                wallet.credentials.walletName;
        wallet.color =
            config.colorFor && config.colorFor[wallet.id]
                ? config.colorFor[wallet.id]
                : defaultColor;
        wallet.email = config.emailFor && config.emailFor[wallet.id];
        // });
    }
    setWalletOrder(walletId, index) {
        this.persistenceProvider.setWalletOrder(walletId, index).then(() => {
            this.logger.debug('Wallet new order stored for ' + walletId + ': ' + index);
        });
        if (this.wallet[walletId])
            this.wallet[walletId]['order'] = index;
    }
    getWalletOrder(walletId) {
        return __awaiter(this, void 0, void 0, function* () {
            const order = yield this.persistenceProvider.getWalletOrder(walletId);
            return order;
        });
    }
    setBackupFlag(walletId) {
        this.persistenceProvider.setBackupFlag(walletId);
        this.logger.debug('Backup flag stored');
        this.wallet[walletId].needsBackup = false;
    }
    requiresBackup(wallet) {
        if (wallet.isPrivKeyExternal())
            return false;
        if (!wallet.credentials.mnemonic && !wallet.credentials.mnemonicEncrypted)
            return false;
        if (wallet.credentials.network == 'testnet')
            return false;
        return true;
    }
    needsBackup(wallet) {
        return new Promise(resolve => {
            if (!this.requiresBackup(wallet)) {
                return resolve(false);
            }
            this.persistenceProvider
                .getBackupFlag(wallet.credentials.walletId)
                .then((val) => {
                if (val) {
                    return resolve(false);
                }
                return resolve(true);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    isBalanceHidden(wallet) {
        return new Promise(resolve => {
            this.persistenceProvider
                .getHideBalanceFlag(wallet.credentials.walletId)
                .then(shouldHideBalance => {
                let isHidden = shouldHideBalance && shouldHideBalance.toString() == 'true'
                    ? true
                    : false;
                return resolve(isHidden);
            })
                .catch(err => {
                this.logger.error(err);
            });
        });
    }
    bindWalletClient(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            opts = opts ? opts : {};
            let walletId = wallet.credentials.walletId;
            if (this.wallet[walletId] && this.wallet[walletId].started && !opts.force) {
                this.logger.info('This wallet has been initialized. Skip. ' + walletId);
                return;
            }
            // INIT WALLET VIEWMODEL
            wallet.id = walletId;
            wallet.started = true;
            wallet.network = wallet.credentials.network;
            wallet.copayerId = wallet.credentials.copayerId;
            wallet.m = wallet.credentials.m;
            wallet.n = wallet.credentials.n;
            wallet.coin = wallet.credentials.coin;
            wallet.status = {};
            this.updateWalletSettings(wallet);
            this.wallet[walletId] = wallet;
            wallet.needsBackup = yield this.needsBackup(wallet);
            wallet.balanceHidden = yield this.isBalanceHidden(wallet);
            wallet.order = yield this.getWalletOrder(wallet.id);
            wallet.removeAllListeners();
            wallet.on('report', n => {
                this.logger.info('BWC Report:' + n);
            });
            wallet.on('notification', n => {
                this.logger.debug('BWC Notification:', JSON.stringify(n));
                if (n.type == 'NewBlock' && n.data.network == 'testnet') {
                    this.throttledBwsEvent(n, wallet);
                }
                else
                    this.newBwsEvent(n, wallet);
            });
            wallet.on('walletCompleted', () => {
                this.logger.debug('Wallet completed');
                this.updateCredentials(JSON.parse(wallet.export()));
                this.events.publish('status:updated');
            });
            wallet.initialize({
                notificationIncludeOwn: true
            }, err => {
                if (err) {
                    this.logger.error('Could not init notifications err:', err);
                    return;
                }
                wallet.setNotificationsInterval(this.UPDATE_PERIOD);
                wallet.openWallet(() => {
                    if (wallet.status !== true)
                        this.logger.debug('Wallet + ' +
                            walletId +
                            ' status:' +
                            JSON.stringify(wallet.status));
                });
            });
            this.events.subscribe('wallet:updated', (walletId) => {
                if (walletId && walletId == wallet.id) {
                    this.logger.debug('Updating settings for wallet:' + wallet.id);
                    this.updateWalletSettings(wallet);
                }
            });
        });
    }
    newBwsEvent(n, wallet) {
        if (wallet.cachedStatus)
            wallet.cachedStatus.isValid = false;
        if (wallet.completeHistory)
            wallet.completeHistory.isValid = false;
        if (wallet.cachedActivity)
            wallet.cachedActivity.isValid = false;
        if (wallet.cachedTxps)
            wallet.cachedTxps.isValid = false;
        this.events.publish('bwsEvent', wallet.id, n.type, n);
    }
    updateCredentials(credentials) {
        this.profile.updateWallet(credentials);
        this.persistenceProvider.storeProfile(this.profile);
    }
    getLastKnownBalance(wid) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getBalanceCache(wid)
                .then((data) => {
                return resolve(data);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    addLastKnownBalance(wallet) {
        return new Promise(resolve => {
            let now = Math.floor(Date.now() / 1000);
            let showRange = 600; // 10min;
            this.getLastKnownBalance(wallet.id)
                .then((data) => {
                if (data) {
                    let parseData = data;
                    wallet.cachedBalance = parseData.balance;
                    wallet.cachedBalanceUpdatedOn =
                        parseData.updatedOn < now - showRange
                            ? parseData.updatedOn
                            : null;
                }
                return resolve();
            })
                .catch(err => {
                this.logger.warn('Could not get last known balance: ', err);
            });
        });
    }
    setLastKnownBalance(wid, balance) {
        this.persistenceProvider.setBalanceCache(wid, {
            balance,
            updatedOn: Math.floor(Date.now() / 1000)
        });
    }
    runValidation(wallet, delay, retryDelay) {
        delay = delay ? delay : 500;
        retryDelay = retryDelay ? retryDelay : 50;
        if (this.validationLock) {
            return setTimeout(() => {
                this.logger.debug('ValidatingWallet Locked: Retrying in: ' + retryDelay);
                return this.runValidation(wallet, delay, retryDelay);
            }, retryDelay);
        }
        this.validationLock = true;
        // IOS devices are already checked
        let skipDeviceValidation = this.platformProvider.isIOS ||
            this.profile.isDeviceChecked(this.platformProvider.ua);
        let walletId = wallet.credentials.walletId;
        this.logger.debug('ValidatingWallet: ' + walletId + ' skip Device:' + skipDeviceValidation);
        setTimeout(() => {
            wallet.validateKeyDerivation({
                skipDeviceValidation
            }, (_, isOK) => {
                this.validationLock = false;
                this.logger.debug('ValidatingWallet End:  ' + walletId + ' isOK:' + isOK);
                if (isOK) {
                    this.profile.setChecked(this.platformProvider.ua, walletId);
                }
                else {
                    this.logger.warn('Key Derivation failed for wallet:' + walletId);
                    this.persistenceProvider.clearLastAddress(walletId).then(() => { });
                }
                this.storeProfileIfDirty();
            });
        }, delay);
    }
    storeProfileIfDirty() {
        if (this.profile.dirty) {
            this.persistenceProvider.storeProfile(this.profile).then(() => {
                this.logger.debug('Saved modified Profile');
                return;
            });
        }
        else {
            return;
        }
    }
    importWallet(str, opts) {
        return new Promise((resolve, reject) => {
            let walletClient = this.bwcProvider.getClient(null, opts);
            this.logger.debug('Importing Wallet:', opts);
            try {
                let c = JSON.parse(str);
                if (c.xPrivKey && c.xPrivKeyEncrypted) {
                    this.logger.warn('Found both encrypted and decrypted key. Deleting the encrypted version');
                    delete c.xPrivKeyEncrypted;
                    delete c.mnemonicEncrypted;
                }
                str = JSON.stringify(c);
                walletClient.import(str, {
                    compressed: opts.compressed,
                    password: opts.password
                });
            }
            catch (err) {
                return reject(this.translate.instant('Could not import. Check input file.'));
            }
            let strParsed = JSON.parse(str);
            if (!strParsed.n) {
                return reject('Backup format not recognized. If you are using a Sqoin Beta backup and version is older than 0.10, please see: https://github.com/bitpay/copay/issues/4730#issuecomment-244522614');
            }
            let addressBook = strParsed.addressBook ? strParsed.addressBook : {};
            this.addAndBindWalletClient(walletClient, {
                bwsurl: opts.bwsurl
            })
                .then(() => {
                this.setMetaData(walletClient, addressBook)
                    .then(() => {
                    return resolve(walletClient);
                })
                    .catch(err => {
                    this.logger.warn('Could not set meta data: ', err);
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // An alert dialog
    askPassword(warnMsg, title) {
        return new Promise(resolve => {
            let opts = {
                type: 'password',
                useDanger: true
            };
            this.popupProvider.ionicPrompt(title, warnMsg, opts).then(res => {
                return resolve(res);
            });
        });
    }
    showWarningNoEncrypt() {
        return new Promise(resolve => {
            let title = this.translate.instant('Are you sure?');
            let msg = this.translate.instant('Without encryption, a thief or another application on this device may be able to access your funds.');
            let okText = this.translate.instant("I'm sure");
            let cancelText = this.translate.instant('Go Back');
            this.popupProvider
                .ionicConfirm(title, msg, okText, cancelText)
                .then(res => {
                return resolve(res);
            });
        });
    }
    askToEncryptWallet(wallet) {
        return new Promise(resolve => {
            if (!wallet.canSign())
                return resolve();
            var title = this.translate.instant('Would you like to protect this wallet with a password?');
            var message = this.translate.instant('Encryption can protect your funds if this device is stolen or compromised by malicious software.');
            var okText = this.translate.instant('Yes');
            var cancelText = this.translate.instant('No');
            this.popupProvider
                .ionicConfirm(title, message, okText, cancelText)
                .then(res => {
                if (!res) {
                    return this.showWarningNoEncrypt().then(res => {
                        if (res)
                            return resolve();
                        return this.encrypt(wallet).then(() => {
                            return resolve();
                        });
                    });
                }
                return this.encrypt(wallet).then(() => {
                    return resolve();
                });
            });
        });
    }
    encrypt(wallet) {
        return new Promise(resolve => {
            let title = this.translate.instant('Enter a password to encrypt your wallet');
            let warnMsg = this.translate.instant('This password is only for this device, and it cannot be recovered. To avoid losing funds, write your password down.');
            this.askPassword(warnMsg, title).then((password) => {
                if (!password) {
                    this.showWarningNoEncrypt().then(res => {
                        if (res)
                            return resolve();
                        this.encrypt(wallet).then(() => {
                            return resolve();
                        });
                    });
                }
                else {
                    title = this.translate.instant('Enter your encrypt password again to confirm');
                    this.askPassword(warnMsg, title).then((password2) => {
                        if (!password2 || password != password2) {
                            this.encrypt(wallet).then(() => {
                                return resolve();
                            });
                        }
                        else {
                            wallet.encryptPrivateKey(password);
                            return resolve();
                        }
                    });
                }
            });
        });
    }
    // Adds and bind a new client to the profile
    addAndBindWalletClient(wallet, opts) {
        return new Promise((resolve, reject) => {
            if (!wallet || !wallet.credentials) {
                return reject(this.translate.instant('Could not access wallet'));
            }
            // Encrypt wallet
            this.onGoingProcessProvider.pause();
            this.askToEncryptWallet(wallet).then(() => {
                this.onGoingProcessProvider.resume();
                let walletId = wallet.credentials.walletId;
                if (!this.profile.addWallet(JSON.parse(wallet.export()))) {
                    let message = this.replaceParametersProvider.replace(this.translate.instant('Wallet already in {{nameCase}}'), { nameCase: this.appProvider.info.nameCase });
                    return reject(message);
                }
                let skipKeyValidation = this.shouldSkipValidation(walletId);
                if (!skipKeyValidation)
                    this.runValidation(wallet);
                this.bindWalletClient(wallet);
                let saveBwsUrl = () => {
                    return new Promise(resolve => {
                        let defaults = this.configProvider.getDefaults();
                        let bwsFor = {};
                        bwsFor[walletId] = opts.bwsurl || defaults.bws.url;
                        // Dont save the default
                        if (bwsFor[walletId] == defaults.bws.url) {
                            return resolve();
                        }
                        this.configProvider.set({ bwsFor });
                        return resolve();
                    });
                };
                saveBwsUrl().then(() => {
                    this.persistenceProvider
                        .storeProfile(this.profile)
                        .then(() => {
                        return resolve(wallet);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                });
            });
        });
    }
    shouldSkipValidation(walletId) {
        return (this.profile.isChecked(this.platformProvider.ua, walletId) ||
            this.platformProvider.isIOS);
    }
    setMetaData(wallet, addressBook) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(wallet.credentials.network)
                .then(localAddressBook => {
                let localAddressBook1 = {};
                try {
                    localAddressBook1 = JSON.parse(localAddressBook);
                }
                catch (ex) {
                    this.logger.info('Address Book: JSON.parse not neccesary.', localAddressBook);
                }
                let mergeAddressBook = __WEBPACK_IMPORTED_MODULE_3_lodash__["merge"](addressBook, localAddressBook1);
                this.persistenceProvider
                    .setAddressBook(wallet.credentials.network, JSON.stringify(mergeAddressBook))
                    .then(() => {
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        return new Promise((resolve, reject) => {
            let walletClient = this.bwcProvider.getClient(null, opts);
            this.logger.debug('Importing Wallet xPrivKey');
            walletClient.importFromExtendedPrivateKey(xPrivKey, opts, err => {
                if (err) {
                    if (err instanceof this.errors.NOT_AUTHORIZED)
                        return reject(err);
                    this.bwcErrorProvider
                        .cb(err, this.translate.instant('Could not import'))
                        .then((msg) => {
                        return reject(msg);
                    });
                }
                else {
                    this.addAndBindWalletClient(walletClient, {
                        bwsurl: opts.bwsurl
                    })
                        .then(wallet => {
                        return resolve(wallet);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                }
            });
        });
    }
    normalizeMnemonic(words) {
        if (!words || !words.indexOf)
            return words;
        let isJA = words.indexOf('\u3000') > -1;
        let wordList = words.split(/[\u3000\s]+/);
        return wordList.join(isJA ? '\u3000' : ' ');
    }
    importMnemonic(words, opts) {
        return new Promise((resolve, reject) => {
            let walletClient = this.bwcProvider.getClient(null, opts);
            this.logger.debug('Importing Wallet Mnemonic');
            words = this.normalizeMnemonic(words);
            walletClient.importFromMnemonic(words, {
                network: opts.networkName,
                passphrase: opts.passphrase,
                entropySourcePath: opts.entropySourcePath,
                derivationStrategy: opts.derivationStrategy || 'BIP44',
                account: opts.account || 0,
                coin: opts.coin
            }, err => {
                if (err) {
                    if (err instanceof this.errors.NOT_AUTHORIZED) {
                        return reject(err);
                    }
                    this.bwcErrorProvider
                        .cb(err, this.translate.instant('Could not import'))
                        .then((msg) => {
                        return reject(msg);
                    });
                }
                this.addAndBindWalletClient(walletClient, {
                    bwsurl: opts.bwsurl
                })
                    .then(wallet => {
                    return resolve(wallet);
                })
                    .catch(err => {
                    return reject(err);
                });
            });
        });
    }
    importExtendedPublicKey(opts) {
        return new Promise((resolve, reject) => {
            let walletClient = this.bwcProvider.getClient(null, opts);
            this.logger.debug('Importing Wallet XPubKey');
            walletClient.importFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
                account: opts.account || 0,
                derivationStrategy: opts.derivationStrategy || 'BIP44',
                coin: opts.coin
            }, err => {
                if (err) {
                    // in HW wallets, req key is always the same. They can't addAccess.
                    if (err instanceof this.errors.NOT_AUTHORIZED)
                        err.name = 'WALLET_DOES_NOT_EXIST';
                    this.bwcErrorProvider
                        .cb(err, this.translate.instant('Could not import'))
                        .then((msg) => {
                        return reject(msg);
                    });
                }
                this.addAndBindWalletClient(walletClient, {
                    bwsurl: opts.bwsurl
                })
                    .then(wallet => {
                    return resolve(wallet);
                })
                    .catch(err => {
                    return reject(err);
                });
            });
        });
    }
    createProfile() {
        this.logger.info('Creating profile');
        this.profile = new __WEBPACK_IMPORTED_MODULE_15__models_profile_profile_model__["a" /* Profile */]();
        this.profile = this.profile.create();
        this.persistenceProvider.storeNewProfile(this.profile);
    }
    bindProfile(profile) {
        return new Promise((resolve, reject) => {
            let bindWallets = () => {
                return new Promise((resolve, reject) => {
                    let l = profile.credentials.length;
                    let i = 0;
                    let totalBound = 0;
                    if (!l) {
                        return resolve();
                    }
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](profile.credentials, credentials => {
                        this.bindWallet(credentials)
                            .then((bound) => {
                            i++;
                            totalBound += bound;
                            if (i == l) {
                                this.logger.info('Bound ' + totalBound + ' out of ' + l + ' wallets');
                                return resolve();
                            }
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                });
            };
            bindWallets()
                .then(() => {
                this.isOnboardingCompleted()
                    .then(() => {
                    this.isDisclaimerAccepted()
                        .then(() => {
                        return resolve();
                    })
                        .catch(() => {
                        return reject(new Error('NONAGREEDDISCLAIMER: Non agreed disclaimer'));
                    });
                })
                    .catch(() => {
                    this.isDisclaimerAccepted()
                        .then(() => {
                        this.setOnboardingCompleted()
                            .then(() => {
                            return resolve();
                        })
                            .catch(err => {
                            this.logger.error(err);
                        });
                    })
                        .catch(() => {
                        return reject(new Error('ONBOARDINGNONCOMPLETED: Onboarding non completed'));
                    });
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    isDisclaimerAccepted() {
        return new Promise((resolve, reject) => {
            let disclaimerAccepted = this.profile && this.profile.disclaimerAccepted;
            if (disclaimerAccepted)
                return resolve();
            // OLD flag
            this.persistenceProvider.getCopayDisclaimerFlag().then(val => {
                if (val) {
                    this.profile.disclaimerAccepted = true;
                    return resolve();
                }
                else {
                    return reject();
                }
            });
        });
    }
    isOnboardingCompleted() {
        return new Promise((resolve, reject) => {
            let onboardingCompleted = this.profile && this.profile.onboardingCompleted;
            if (onboardingCompleted)
                return resolve();
            this.persistenceProvider.getCopayOnboardingFlag().then(val => {
                if (val) {
                    this.profile.onboardingCompleted = true;
                    return resolve();
                }
                else {
                    return reject();
                }
            });
        });
    }
    bindWallet(credentials) {
        return new Promise((resolve, reject) => {
            if (!credentials.walletId || !credentials.m) {
                return reject('bindWallet should receive credentials JSON');
            }
            // Create the client
            let getBWSURL = (walletId) => {
                let config = this.configProvider.get();
                let defaults = this.configProvider.getDefaults();
                return (config.bwsFor && config.bwsFor[walletId]) || defaults.bws.url;
            };
            let walletClient = this.bwcProvider.getClient(JSON.stringify(credentials), {
                bwsurl: getBWSURL(credentials.walletId)
            });
            let skipKeyValidation = this.shouldSkipValidation(credentials.walletId);
            if (!skipKeyValidation)
                this.runValidation(walletClient, 500);
            this.logger.info('Binding wallet:' +
                credentials.walletId +
                ' Validating?:' +
                !skipKeyValidation);
            return resolve(this.bindWalletClient(walletClient));
        });
    }
    loadAndBindProfile() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getProfile()
                .then(profile => {
                if (!profile) {
                    return resolve();
                }
                this.profile = new __WEBPACK_IMPORTED_MODULE_15__models_profile_profile_model__["a" /* Profile */]();
                this.profile = this.profile.fromObj(profile);
                // Deprecated: storageService.tryToMigrate
                this.logger.debug('Profile read');
                this.bindProfile(this.profile)
                    .then(() => {
                    return resolve(this.profile);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    seedWallet(opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            let walletClient = this.bwcProvider.getClient(null, opts);
            let network = opts.networkName || 'livenet';
            if (opts.mnemonic) {
                try {
                    opts.mnemonic = this.normalizeMnemonic(opts.mnemonic);
                    walletClient.seedFromMnemonic(opts.mnemonic, {
                        network,
                        passphrase: opts.passphrase,
                        account: opts.account || 0,
                        derivationStrategy: opts.derivationStrategy || 'BIP44',
                        coin: opts.coin
                    });
                }
                catch (ex) {
                    this.logger.info('Invalid wallet recovery phrase: ', ex);
                    return reject(this.translate.instant('Could not create: Invalid wallet recovery phrase'));
                }
            }
            else if (opts.extendedPrivateKey) {
                try {
                    walletClient.seedFromExtendedPrivateKey(opts.extendedPrivateKey, {
                        network,
                        account: opts.account || 0,
                        derivationStrategy: opts.derivationStrategy || 'BIP44',
                        coin: opts.coin
                    });
                }
                catch (ex) {
                    this.logger.warn('Could not get seed from Extended Private Key: ', ex);
                    return reject(this.translate.instant('Could not create using the specified extended private key'));
                }
            }
            else if (opts.extendedPublicKey) {
                try {
                    walletClient.seedFromExtendedPublicKey(opts.extendedPublicKey, opts.externalSource, opts.entropySource, {
                        account: opts.account || 0,
                        derivationStrategy: opts.derivationStrategy || 'BIP44',
                        coin: opts.coin
                    });
                    walletClient.credentials.hwInfo = opts.hwInfo;
                }
                catch (ex) {
                    this.logger.warn('Creating wallet from Extended Public Key Arg:', ex, opts);
                    return reject(this.translate.instant('Could not create using the specified extended public key'));
                }
            }
            else {
                let lang = this.languageProvider.getCurrent();
                try {
                    walletClient.seedFromRandomWithMnemonic({
                        network,
                        passphrase: opts.passphrase,
                        language: lang,
                        account: 0,
                        coin: opts.coin
                    });
                }
                catch (e) {
                    this.logger.info('Error creating recovery phrase: ' + e.message);
                    if (e.message.indexOf('language') > 0) {
                        this.logger.info('Using default language for recovery phrase');
                        walletClient.seedFromRandomWithMnemonic({
                            network,
                            passphrase: opts.passphrase,
                            account: 0,
                            coin: opts.coin
                        });
                    }
                    else {
                        return reject(e);
                    }
                }
            }
            return resolve(walletClient);
        });
    }
    // Creates a wallet on BWC/BWS
    doCreateWallet(opts) {
        return new Promise((resolve, reject) => {
            let showOpts = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](opts);
            if (showOpts.extendedPrivateKey)
                showOpts.extendedPrivateKey = '[hidden]';
            if (showOpts.mnemonic)
                showOpts.mnemonic = '[hidden]';
            this.logger.debug('Creating Wallet:', JSON.stringify(showOpts));
            setTimeout(() => {
                this.seedWallet(opts)
                    .then(walletClient => {
                    let name = opts.name || this.translate.instant('Personal Wallet');
                    let myName = opts.myName || this.translate.instant('me');
                    walletClient.createWallet(name, myName, opts.m, opts.n, {
                        network: opts.networkName,
                        singleAddress: opts.singleAddress,
                        walletPrivKey: opts.walletPrivKey,
                        coin: opts.coin
                    }, err => {
                        if (err) {
                            this.bwcErrorProvider
                                .cb(err, this.translate.instant('Error creating wallet'))
                                .then((msg) => {
                                return reject(msg);
                            });
                        }
                        else {
                            return resolve(walletClient);
                        }
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }, 50);
        });
    }
    // create and store a wallet
    createWallet(opts) {
        return new Promise((resolve, reject) => {
            this.doCreateWallet(opts)
                .then(walletClient => {
                this.addAndBindWalletClient(walletClient, {
                    bwsurl: opts.bwsurl
                }).then(wallet => {
                    return resolve(wallet);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // joins and stores a wallet
    joinWallet(opts) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Joining Wallet:', opts);
            try {
                var walletData = this.bwcProvider.parseSecret(opts.secret);
                // check if exist
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.profile.credentials, {
                    walletId: walletData.walletId
                })) {
                    return reject(this.translate.instant('Cannot join the same wallet more that once'));
                }
            }
            catch (ex) {
                this.logger.debug(ex);
                return reject(this.translate.instant('Bad wallet invitation'));
            }
            opts.networkName = walletData.network;
            this.logger.debug('Joining Wallet:', opts);
            this.seedWallet(opts)
                .then(walletClient => {
                walletClient.joinWallet(opts.secret, opts.myName || 'me', {
                    coin: opts.coin
                }, err => {
                    if (err) {
                        this.bwcErrorProvider
                            .cb(err, this.translate.instant('Could not join wallet'))
                            .then((msg) => {
                            return reject(msg);
                        });
                    }
                    else {
                        this.addAndBindWalletClient(walletClient, {
                            bwsurl: opts.bwsurl
                        }).then(wallet => {
                            return resolve(wallet);
                        });
                    }
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getWallet(walletId) {
        return this.wallet[walletId];
    }
    deleteWalletClient(wallet) {
        return new Promise((resolve, reject) => {
            let walletId = wallet.credentials.walletId;
            this.logger.debug('Deleting Wallet:', wallet.credentials.walletName);
            wallet.removeAllListeners();
            this.profile.deleteWallet(walletId);
            delete this.wallet[walletId];
            this.persistenceProvider.removeAllWalletData(walletId).catch(err => {
                this.logger.warn('Could not remove all wallet data: ', err);
            });
            this.persistenceProvider
                .storeProfile(this.profile)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createDefaultWallet() {
        return new Promise((resolve, reject) => {
            let opts = {};
            opts.m = 1;
            opts.n = 1;
            opts.networkName = 'livenet';
            opts.coin = 'btc';
            this.createWallet(opts)
                .then(wallet => {
                return resolve(wallet);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    setDisclaimerAccepted() {
        return new Promise((resolve, reject) => {
            this.profile.disclaimerAccepted = true;
            this.persistenceProvider
                .storeProfile(this.profile)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    setOnboardingCompleted() {
        return new Promise((resolve, reject) => {
            this.profile.onboardingCompleted = true;
            this.persistenceProvider
                .storeProfile(this.profile)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getWallets(opts) {
        if (opts && !__WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](opts))
            throw new Error('bad argument');
        opts = opts || {};
        let ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["values"](this.wallet);
        if (opts.coin) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, x => {
                return x.credentials.coin == opts.coin;
            });
        }
        if (opts.network) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, x => {
                return x.credentials.network == opts.network;
            });
        }
        if (opts.n) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, w => {
                return w.credentials.n == opts.n;
            });
        }
        if (opts.m) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, w => {
                return w.credentials.m == opts.m;
            });
        }
        if (opts.hasFunds) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, w => {
                if (!w.status)
                    return undefined;
                return w.status.availableBalanceSat > 0;
            });
        }
        if (opts.minAmount) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, w => {
                if (!w.status)
                    return undefined;
                return w.status.availableBalanceSat > opts.minAmount;
            });
        }
        if (opts.onlyComplete) {
            ret = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](ret, w => {
                return w.isComplete();
            });
        }
        else {
        }
        // Add cached balance async
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](ret, x => {
            this.addLastKnownBalance(x);
        });
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](ret, 'order');
    }
    toggleHideBalanceFlag(walletId) {
        this.wallet[walletId].balanceHidden = !this.wallet[walletId].balanceHidden;
        this.persistenceProvider.setHideBalanceFlag(walletId, this.wallet[walletId].balanceHidden);
    }
    getNotifications(opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            let TIME_STAMP = 60 * 60 * 6;
            let MAX = 30;
            let typeFilter = {
                NewOutgoingTx: 1,
                NewIncomingTx: 1
            };
            let w = this.getWallets();
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](w))
                return reject('Could not find any wallet');
            let l = w.length;
            let j = 0;
            let notifications = [];
            let isActivityCached = (wallet) => {
                return wallet.cachedActivity && wallet.cachedActivity.isValid;
            };
            let updateNotifications = (wallet) => {
                return new Promise((resolve, reject) => {
                    if (isActivityCached(wallet) && !opts.force) {
                        return resolve();
                    }
                    wallet.getNotifications({
                        timeSpan: TIME_STAMP,
                        includeOwn: true
                    }, (err, n) => {
                        if (err) {
                            return reject(err);
                        }
                        wallet.cachedActivity = {
                            n: n.slice(-MAX),
                            isValid: true
                        };
                        return resolve();
                    });
                });
            };
            let process = notifications => {
                if (!notifications)
                    return [];
                let shown = __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](notifications, 'createdOn').reverse();
                shown = shown.splice(0, opts.limit || MAX);
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](shown, x => {
                    x.txpId = x.data ? x.data.txProposalId : null;
                    x.txid = x.data ? x.data.txid : null;
                    x.types = [x.type];
                    x.action = () => {
                        // TODO?
                        // $state.go('tabs.wallet', {
                        //   walletId: x.walletId,
                        //   txpId: x.txpId,
                        //   txid: x.txid,
                        // });
                    };
                });
                // let finale = shown; GROUPING DISABLED!
                let finale = [];
                let prev;
                // Item grouping... DISABLED.
                // REMOVE (if we want 1-to-1 notification) ????
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](shown, x => {
                    if (prev &&
                        prev.walletId === x.walletId &&
                        prev.txpId &&
                        prev.txpId === x.txpId &&
                        prev.creatorId &&
                        prev.creatorId === x.creatorId) {
                        prev.types.push(x.type);
                        prev.data = __WEBPACK_IMPORTED_MODULE_3_lodash__["assign"](prev.data, x.data);
                        prev.txid = prev.txid || x.txid;
                        prev.creatorName = prev.creatorName || x.creatorName;
                    }
                    else {
                        finale.push(x);
                        prev = x;
                    }
                });
                let u = this.bwcProvider.getUtils();
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](finale, x => {
                    if (x.data &&
                        x.data.message &&
                        x.wallet &&
                        x.wallet.credentials.sharedEncryptingKey) {
                        // TODO TODO TODO => BWC
                        x.message = u.decryptMessage(x.data.message, x.wallet.credentials.sharedEncryptingKey);
                    }
                });
                return finale;
            };
            let pr = (wallet, cb) => {
                updateNotifications(wallet)
                    .then(() => {
                    let n = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](wallet.cachedActivity.n, x => {
                        return typeFilter[x.type];
                    });
                    let idToName = {};
                    if (wallet.cachedStatus) {
                        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](wallet.cachedStatus.wallet.copayers, c => {
                            idToName[c.id] = c.name;
                        });
                    }
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](n, x => {
                        x.wallet = wallet;
                        if (x.creatorId && wallet.cachedStatus) {
                            x.creatorName = idToName[x.creatorId];
                        }
                    });
                    notifications.push(n);
                    return cb();
                })
                    .catch(err => {
                    return cb(err);
                });
            };
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](w, wallet => {
                pr(wallet, err => {
                    if (err)
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Error updating notifications for ' + wallet.name));
                    if (++j == l) {
                        notifications = __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](notifications, 'createdOn').reverse();
                        notifications = __WEBPACK_IMPORTED_MODULE_3_lodash__["compact"](__WEBPACK_IMPORTED_MODULE_3_lodash__["flatten"](notifications)).slice(0, MAX);
                        let total = notifications.length;
                        let processArray = process(notifications);
                        return resolve({ notifications: processArray, total });
                    }
                });
            });
        });
    }
    getTxps(opts) {
        return new Promise((resolve, reject) => {
            let MAX = 100;
            opts = opts ? opts : {};
            let w = this.getWallets();
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](w)) {
                return reject('No wallets available');
            }
            let txps = [];
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](w, x => {
                if (x.pendingTxps)
                    txps = txps.concat(x.pendingTxps);
            });
            let n = txps.length;
            txps = __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](txps, 'createdOn').reverse();
            txps = __WEBPACK_IMPORTED_MODULE_3_lodash__["compact"](__WEBPACK_IMPORTED_MODULE_3_lodash__["flatten"](txps)).slice(0, opts.limit || MAX);
            return resolve({ txps, n });
        });
    }
};
ProfileProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_9__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_14__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_8__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_12__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_13__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], ProfileProvider);

//# sourceMappingURL=profile.js.map

/***/ }),

/***/ 142:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlideraProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers






let GlideraProvider = class GlideraProvider {
    constructor(logger, http, platformProvider, persistenceProvider, homeIntegrationsProvider, configProvider, appProvider) {
        this.logger = logger;
        this.http = http;
        this.platformProvider = platformProvider;
        this.persistenceProvider = persistenceProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.configProvider = configProvider;
        this.appProvider = appProvider;
        this.logger.info('GlideraProvider initialized');
        this.credentials = {};
        this.isCordova = this.platformProvider.isCordova;
    }
    setCredentials() {
        if (!this.appProvider.servicesInfo ||
            !this.appProvider.servicesInfo.glidera) {
            return;
        }
        var glidera = this.appProvider.servicesInfo.glidera;
        /*
         * Development: 'testnet'
         * Production: 'livenet'
         */
        this.credentials.NETWORK = 'livenet';
        if (this.credentials.NETWORK == 'testnet') {
            this.credentials.HOST = glidera.sandbox.host;
            if (this.isCordova) {
                this.credentials.REDIRECT_URI = glidera.sandbox.mobile.redirect_uri;
                this.credentials.CLIENT_ID = glidera.sandbox.mobile.client_id;
                this.credentials.CLIENT_SECRET = glidera.sandbox.mobile.client_secret;
            }
            else {
                this.credentials.REDIRECT_URI = glidera.sandbox.desktop.redirect_uri;
                this.credentials.CLIENT_ID = glidera.sandbox.desktop.client_id;
                this.credentials.CLIENT_SECRET = glidera.sandbox.desktop.client_secret;
            }
        }
        else {
            this.credentials.HOST = glidera.production.host;
            if (this.isCordova) {
                this.credentials.REDIRECT_URI = glidera.production.mobile.redirect_uri;
                this.credentials.CLIENT_ID = glidera.production.mobile.client_id;
                this.credentials.CLIENT_SECRET =
                    glidera.production.mobile.client_secret;
            }
            else {
                this.credentials.REDIRECT_URI = glidera.production.desktop.redirect_uri;
                this.credentials.CLIENT_ID = glidera.production.desktop.client_id;
                this.credentials.CLIENT_SECRET =
                    glidera.production.desktop.client_secret;
            }
        }
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    getCurrency() {
        return 'USD';
    }
    getSignupUrl() {
        return this.credentials.HOST + '/register';
    }
    getSupportUrl() {
        return 'https://twitter.com/GlideraInc';
    }
    getOauthCodeUrl() {
        return (this.credentials.HOST +
            '/oauth2/auth?response_type=code&client_id=' +
            this.credentials.CLIENT_ID +
            '&redirect_uri=' +
            this.credentials.REDIRECT_URI);
    }
    remove() {
        this.persistenceProvider.removeGlideraToken(this.credentials.NETWORK);
        this.persistenceProvider.removeGlideraPermissions(this.credentials.NETWORK);
        this.persistenceProvider.removeGlideraStatus(this.credentials.NETWORK);
        this.persistenceProvider.removeGlideraTxs(this.credentials.NETWORK);
        this.homeIntegrationsProvider.updateLink('glidera', null); // Name, Token
    }
    getToken(code, cb) {
        let url = this.credentials.HOST + '/api/v1/oauth/token';
        let data = {
            grant_type: 'authorization_code',
            code,
            client_id: this.credentials.CLIENT_ID,
            client_secret: this.credentials.CLIENT_SECRET,
            redirect_uri: this.credentials.REDIRECT_URI
        };
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json'
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Glidera Authorization Access Token: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Authorization Access Token: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    authorize(code, cb) {
        this.getToken(code, (err, data) => {
            if (err)
                return cb(err);
            if (data && !data.access_token)
                return cb('No access token');
            let accessToken = data.access_token;
            this.getAccessTokenPermissions(accessToken, (err, p) => {
                if (err)
                    return cb(err);
                this.getStatus(accessToken, (err, status) => {
                    if (err)
                        this.logger.error(err);
                    this.persistenceProvider.setGlideraToken(this.credentials.NETWORK, accessToken);
                    this.persistenceProvider.setGlideraPermissions(this.credentials.NETWORK, p);
                    this.persistenceProvider.setGlideraStatus(this.credentials.NETWORK, status);
                    this.homeIntegrationsProvider.updateLink('glidera', accessToken); // Name, Token
                    return cb(null, {
                        token: accessToken,
                        permissions: p,
                        status
                    });
                });
            });
        });
    }
    getAccessTokenPermissions(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/oauth/token';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera Access Token Permissions: SUCCESS');
            return cb(null, data);
        }, data => {
            let message = data && data.message ? data.message : data.statusText;
            this.logger.error('Glidera Access Token Permissions: ERROR ' + message);
            return cb(message);
        });
    }
    getEmail(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/user/email';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera Get Email: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Get Email: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getPersonalInfo(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/user/personalinfo';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera Get Personal Info: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Get Personal Info: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getStatus(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/user/status';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera User Status: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera User Status: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getLimits(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/user/limits';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera Transaction Limits: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Transaction Limits: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getTransactions(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/transaction';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe((data) => {
            this.logger.info('Glidera Transactions: SUCCESS');
            return cb(null, data.transactions);
        }, data => {
            this.logger.error('Glidera Transactions: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getTransaction(token, txid, cb) {
        if (!token)
            return cb('Invalid Token');
        if (!txid)
            return cb('TxId required');
        let url = this.credentials.HOST + '/api/v1/transaction/' + txid;
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera Transaction: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Transaction: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getSellAddress(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/user/create_sell_address';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe((data) => {
            this.logger.info('Glidera Create Sell Address: SUCCESS');
            return cb(null, data.sellAddress);
        }, data => {
            this.logger.error('Glidera Create Sell Address: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    get2faCode(token, cb) {
        if (!token)
            return cb('Invalid Token');
        let url = this.credentials.HOST + '/api/v1/authentication/get2faCode';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.get(url, { headers }).subscribe(data => {
            this.logger.info('Glidera 2FA code: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera 2FA code: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    sellPrice(token, price, cb) {
        let data = {
            qty: price.qty,
            fiat: price.fiat
        };
        let url = this.credentials.HOST + '/api/v1/prices/sell';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Glidera Sell Price: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Sell Price: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    sell(token, twoFaCode, dataSrc, cb) {
        let data = {
            refundAddress: dataSrc.refundAddress,
            signedTransaction: dataSrc.signedTransaction,
            priceUuid: dataSrc.priceUuid,
            useCurrentPrice: dataSrc.useCurrentPrice,
            ip: dataSrc.ip
        };
        let url = this.credentials.HOST + '/api/v1/sell';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token,
            'X-2FA-CODE': [twoFaCode]
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Glidera Sell: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Sell Request: ERROR ' + data.statusText);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    buyPrice(token, price, cb) {
        const url = this.credentials.HOST + '/api/v1/prices/buy';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token
        });
        this.http.post(url, price, { headers }).subscribe(data => {
            this.logger.info('Glidera Buy Price: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Buy Price: ERROR ' + JSON.stringify(data));
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    buy(token, twoFaCode, dataSrc, cb) {
        let data = {
            destinationAddress: dataSrc.destinationAddress,
            qty: dataSrc.qty,
            priceUuid: dataSrc.priceUuid,
            useCurrentPrice: dataSrc.useCurrentPrice,
            ip: dataSrc.ip
        };
        let url = this.credentials.HOST + '/api/v1/buy';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json',
            Accept: 'application/json',
            Authorization: 'Bearer ' + token,
            'X-2FA-CODE': [twoFaCode]
        });
        this.http.post(url, data, { headers }).subscribe(data => {
            this.logger.info('Glidera Buy: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Glidera Buy Request: ERROR ' + data);
            let message = data && data.message ? data.message : data.statusText;
            return cb(message);
        });
    }
    getPermissions(accessToken, network, force, cb) {
        this.persistenceProvider
            .getGlideraPermissions(network)
            .then(permissions => {
            if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isString"](permissions))
                permissions = permissions;
            if (force || __WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](permissions)) {
                this.getAccessTokenPermissions(accessToken, (err, p) => {
                    if (err) {
                        // Return error and remove token
                        this.remove();
                        return cb(err);
                    }
                    else {
                        // Return permissions and store
                        this.persistenceProvider.setGlideraPermissions(network, p);
                        return cb(null, p);
                    }
                });
            }
            else {
                return cb(null, permissions);
            }
        });
    }
    init(cb) {
        if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](this.credentials.CLIENT_ID)) {
            return cb('Glidera is Disabled');
        }
        this.logger.debug('Trying to initialize Glidera...');
        this.persistenceProvider
            .getGlideraToken(this.credentials.NETWORK)
            .then(accessToken => {
            if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isEmpty"](accessToken))
                return cb();
            this.getPermissions(accessToken, this.credentials.NETWORK, true, (err, permissions) => {
                if (err)
                    return cb(err);
                this.persistenceProvider
                    .getGlideraStatus(this.credentials.NETWORK)
                    .then(status => {
                    if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isString"](status))
                        status = JSON.parse(status);
                    this.persistenceProvider
                        .getGlideraTxs(this.credentials.NETWORK)
                        .then(txs => {
                        if (__WEBPACK_IMPORTED_MODULE_8_lodash__["isString"](txs))
                            txs = JSON.parse(txs);
                        return cb(null, {
                            token: accessToken,
                            permissions,
                            status,
                            txs
                        });
                    });
                });
            });
        });
    }
    updateStatus(data) {
        this.persistenceProvider
            .getGlideraToken(this.credentials.NETWORK)
            .then(accessToken => {
            this.getPermissions(accessToken, this.credentials.NETWORK, false, (err, permissions) => {
                if (err)
                    return;
                data.permissions = permissions;
                data.price = {};
                this.buyPrice(accessToken, {
                    qty: 1
                }, (err, buy) => {
                    if (err)
                        return;
                    data.price['buy'] = buy.price;
                });
                this.sellPrice(accessToken, {
                    qty: 1
                }, (err, sell) => {
                    if (err)
                        return;
                    data.price['sell'] = sell.price;
                });
                this.getStatus(accessToken, (err, status) => {
                    if (err)
                        return;
                    data.status = status;
                    this.persistenceProvider.setGlideraStatus(this.credentials.NETWORK, status);
                });
                this.getLimits(accessToken, (_, limits) => {
                    data.limits = limits;
                });
                if (permissions.transaction_history) {
                    this.getTransactions(accessToken, (err, txs) => {
                        if (err)
                            return;
                        this.persistenceProvider.setGlideraTxs(this.credentials.NETWORK, txs);
                        data.txs = txs;
                    });
                }
                if (permissions.view_email_address) {
                    this.getEmail(accessToken, (err, email) => {
                        if (err)
                            return;
                        data.email = email;
                    });
                }
                if (permissions.personal_info) {
                    this.getPersonalInfo(accessToken, (err, info) => {
                        if (err)
                            return;
                        data.personalInfo = info;
                    });
                }
            });
        });
    }
    register() {
        this.persistenceProvider
            .getGlideraToken(this.credentials.NETWORK)
            .then(token => {
            this.homeIntegrationsProvider.register({
                name: 'glidera',
                title: 'Glidera',
                icon: 'assets/img/glidera/glidera-icon.png',
                location: 'US Only',
                page: 'GlideraPage',
                show: !!this.configProvider.get().showIntegration['glidera'],
                linked: !!token
            });
        });
    }
};
GlideraProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_7__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_5__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_4__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__app_app__["a" /* AppProvider */]])
], GlideraProvider);

//# sourceMappingURL=glidera.js.map

/***/ }),

/***/ 143:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MercadoLibreProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers




let MercadoLibreProvider = class MercadoLibreProvider {
    // private availableCountries;
    constructor(persistenceProvider, homeIntegrationsProvider, http, logger, configProvider) {
        this.persistenceProvider = persistenceProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.http = http;
        this.logger = logger;
        this.configProvider = configProvider;
        this.logger.info('MercadoLibreProvider initialized');
        // Not used yet
        /* this.availableCountries = [{
          'country': 'Brazil',
          'currency': 'BRL',
          'name': 'Mercado Livre',
          'url': 'https://www.mercadolivre.com.br'
        }]; */
        this.credentials = {};
        /*
        * Development: 'testnet'
        * Production: 'livenet'
        */
        this.credentials.NETWORK = 'livenet';
        this.credentials.BITPAY_API_URL =
            this.credentials.NETWORK === 'testnet'
                ? 'https://test.bitpay.com'
                : 'https://bitpay.com';
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    savePendingGiftCard(gc, opts, cb) {
        let network = this.getNetwork();
        this.persistenceProvider
            .getMercadoLibreGiftCards(network)
            .then(oldGiftCards => {
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](oldGiftCards)) {
                oldGiftCards = JSON.parse(oldGiftCards);
            }
            if (__WEBPACK_IMPORTED_MODULE_6_lodash__["isString"](gc)) {
                gc = JSON.parse(gc);
            }
            let inv = oldGiftCards || {};
            inv[gc.invoiceId] = gc;
            if (opts && (opts.error || opts.status || opts.archived)) {
                inv[gc.invoiceId] = __WEBPACK_IMPORTED_MODULE_6_lodash__["assign"](inv[gc.invoiceId], opts);
            }
            if (opts && opts.remove) {
                delete inv[gc.invoiceId];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setMercadoLibreGiftCards(network, inv);
            return cb();
        });
    }
    getPendingGiftCards(cb) {
        const network = this.getNetwork();
        return this.persistenceProvider
            .getMercadoLibreGiftCards(network)
            .then(giftCards => {
            var _gcds = giftCards ? giftCards : null;
            return cb(null, _gcds);
        });
    }
    createBitPayInvoice(data, cb) {
        let dataSrc = {
            currency: data.currency,
            amount: data.amount,
            clientId: data.uuid,
            email: data.email,
            buyerSelectedTransactionCurrency: data.buyerSelectedTransactionCurrency
        };
        let url = this.credentials.BITPAY_API_URL + '/mercado-libre-gift/pay';
        let headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json'
        });
        this.http.post(url, dataSrc, { headers }).subscribe(data => {
            this.logger.info('BitPay Create Invoice: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('BitPay Create Invoice: ERROR', JSON.stringify(data));
            return cb(data);
        });
    }
    getBitPayInvoice(id, cb) {
        let url = this.credentials.BITPAY_API_URL + '/invoices/' + id;
        let headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json'
        });
        this.http.get(url, { headers }).subscribe((data) => {
            this.logger.info('BitPay Get Invoice: SUCCESS');
            return cb(null, data.data);
        }, data => {
            this.logger.error('BitPay Get Invoice: ERROR', JSON.stringify(data));
            return cb(data);
        });
    }
    createGiftCard(data, cb) {
        var dataSrc = {
            clientId: data.uuid,
            invoiceId: data.invoiceId,
            accessKey: data.accessKey
        };
        let url = this.credentials.BITPAY_API_URL + '/mercado-libre-gift/redeem';
        let headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/json'
        });
        this.http.post(url, dataSrc, { headers }).subscribe((data) => {
            var status = data.status == 'new'
                ? 'PENDING'
                : data.status == 'paid'
                    ? 'PENDING'
                    : data.status;
            data.status = status;
            this.logger.info('Mercado Libre Gift Card Create/Update: ' + status);
            return cb(null, data);
        }, data => {
            this.logger.error('Mercado Libre Gift Card Create/Update: ERROR', JSON.stringify(data));
            return cb(data);
        });
    }
    /*
   * Disabled for now *
   */
    /*
    public cancelGiftCard(data, cb) {
  
      var dataSrc = {
        "clientId": data.uuid,
        "invoiceId": data.invoiceId,
        "accessKey": data.accessKey
      };
      let url = this.credentials.BITPAY_API_URL + '/mercado-libre-gift/cancel';
      let headers = {
        'content-type': 'application/json'
      };
      this.http.post(url, dataSrc, headers).subscribe((data) => {
        this.logger.info('Mercado Libre Gift Card Cancel: SUCCESS');
        return cb(null, data);
      }, (data) => {
        this.logger.error('Mercado Libre Gift Card Cancel: ' + data.message);
        return cb(data);
      });
    };
    */
    register() {
        this.homeIntegrationsProvider.register({
            name: 'mercadolibre',
            title: 'Mercado Livre Brazil Gift Cards',
            icon: 'assets/img/mercado-libre/icon-ml.svg',
            page: 'MercadoLibrePage',
            show: !!this.configProvider.get().showIntegration['mercadolibre']
        });
    }
};
MercadoLibreProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__config_config__["a" /* ConfigProvider */]])
], MercadoLibreProvider);

//# sourceMappingURL=mercado-libre.js.map

/***/ }),

/***/ 144:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




let ShapeshiftProvider = class ShapeshiftProvider {
    constructor(appProvider, homeIntegrationsProvider, http, logger, configProvider, persistenceProvider) {
        this.appProvider = appProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.http = http;
        this.logger = logger;
        this.configProvider = configProvider;
        this.persistenceProvider = persistenceProvider;
        this.logger.info('Hello ShapeshiftProvider Provider');
        this.credentials = {};
        // (Optional) Affiliate PUBLIC KEY, for volume tracking, affiliate payments, split-shifts, etc.
        if (this.appProvider.servicesInfo &&
            this.appProvider.servicesInfo.shapeshift) {
            this.credentials.API_KEY =
                this.appProvider.servicesInfo.shapeshift.api_key || null;
        }
        /*
        * Development: 'testnet'
        * Production: 'livenet'
        */
        this.credentials.NETWORK = 'livenet';
        this.credentials.API_URL =
            this.credentials.NETWORK === 'testnet'
                ? ''
                : // CORS: cors.shapeshift.io
                    'https://shapeshift.io';
    }
    getNetwork() {
        return this.credentials.NETWORK;
    }
    shift(data, cb) {
        let dataSrc = {
            withdrawal: data.withdrawal,
            pair: data.pair,
            returnAddress: data.returnAddress,
            apiKey: this.credentials.API_KEY
        };
        this.http.post(this.credentials.API_URL + '/shift', dataSrc).subscribe(data => {
            this.logger.info('Shapeshift SHIFT: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Shapeshift SHIFT ERROR: ' + data.error.message);
            return cb(data);
        });
    }
    saveShapeshift(data, opts, cb) {
        let network = this.getNetwork();
        this.persistenceProvider
            .getShapeshift(network)
            .then(oldData => {
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](oldData)) {
                oldData = JSON.parse(oldData);
            }
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isString"](data)) {
                data = JSON.parse(data);
            }
            let inv = oldData ? oldData : {};
            inv[data.address] = data;
            if (opts && (opts.error || opts.status)) {
                inv[data.address] = __WEBPACK_IMPORTED_MODULE_2_lodash__["assign"](inv[data.address], opts);
            }
            if (opts && opts.remove) {
                delete inv[data.address];
            }
            inv = JSON.stringify(inv);
            this.persistenceProvider.setShapeshift(network, inv);
            return cb(null);
        })
            .catch(err => {
            return cb(err);
        });
    }
    getShapeshift(cb) {
        let network = this.getNetwork();
        this.persistenceProvider
            .getShapeshift(network)
            .then(ss => {
            return cb(null, ss);
        })
            .catch(err => {
            return cb(err, null);
        });
    }
    getRate(pair, cb) {
        this.http.get(this.credentials.API_URL + '/rate/' + pair).subscribe(data => {
            this.logger.info('Shapeshift PAIR: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Shapeshift PAIR ERROR: ' + data.error.message);
            return cb(data);
        });
    }
    getLimit(pair, cb) {
        this.http.get(this.credentials.API_URL + '/limit/' + pair).subscribe(data => {
            this.logger.info('Shapeshift LIMIT: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Shapeshift LIMIT ERROR: ' + data.error.message);
            return cb(data);
        });
    }
    getMarketInfo(pair, cb) {
        this.http.get(this.credentials.API_URL + '/marketinfo/' + pair).subscribe(data => {
            this.logger.info('Shapeshift MARKET INFO: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Shapeshift MARKET INFO ERROR', data.error.message);
            return cb(data);
        });
    }
    getStatus(addr, cb) {
        this.http.get(this.credentials.API_URL + '/txStat/' + addr).subscribe(data => {
            this.logger.info('Shapeshift STATUS: SUCCESS');
            return cb(null, data);
        }, data => {
            this.logger.error('Shapeshift STATUS ERROR: ' + data.error.message);
            return cb(data);
        });
    }
    register() {
        this.homeIntegrationsProvider.register({
            name: 'shapeshift',
            title: 'ShapeShift',
            icon: 'assets/img/shapeshift/icon-shapeshift.svg',
            page: 'ShapeshiftPage',
            show: !!this.configProvider.get().showIntegration['shapeshift']
        });
    }
};
ShapeshiftProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__persistence_persistence__["a" /* PersistenceProvider */]])
], ShapeshiftProvider);

//# sourceMappingURL=shapeshift.js.map

/***/ }),

/***/ 145:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CopayersPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pages_wallet_details_wallet_details__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Pages

// Providers










let CopayersPage = class CopayersPage {
    constructor(app, appProvider, bwcErrorProvider, events, logger, navCtrl, navParams, platformProvider, popupProvider, profileProvider, onGoingProcessProvider, walletProvider, translate, pushNotificationsProvider) {
        this.app = app;
        this.appProvider = appProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.events = events;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.appName = this.appProvider.info.userVisibleName;
        this.appUrl = this.appProvider.info.url;
        this.isCordova = this.platformProvider.isCordova;
        this.secret = null;
    }
    ionViewWillEnter() {
        this.logger.info('ionViewDidLoad CopayersPage');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.updateWallet();
        this.events.subscribe('bwsEvent', (walletId, type) => {
            if (this.wallet &&
                walletId == this.wallet.id &&
                type == ('NewCopayer' || 'WalletComplete')) {
                this.updateWallet();
            }
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    updateWallet() {
        this.logger.debug('Updating wallet:' + this.wallet.name);
        this.walletProvider
            .getStatus(this.wallet, {})
            .then(status => {
            this.wallet.status = status;
            this.copayers = this.wallet.status.wallet.copayers;
            this.secret = this.wallet.status.wallet.secret;
            if (status.wallet.status == 'complete') {
                this.wallet.openWallet(err => {
                    if (err)
                        this.logger.error(err);
                    this.navCtrl.popToRoot();
                    this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                        walletId: this.wallet.credentials.walletId
                    });
                });
            }
        })
            .catch(err => {
            let message = this.translate.instant('Could not update wallet');
            this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, message));
            return;
        });
    }
    showDeletePopup() {
        let title = this.translate.instant('Confirm');
        let msg = this.translate.instant('Are you sure you want to cancel and delete this wallet?');
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_13__tabs_tabs__["a" /* TabsPage */]);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            let errorText = this.translate.instant('Error');
            this.popupProvider.ionicAlert(errorText, err.message || err);
        });
    }
};
CopayersPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-copayers',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/add/copayers/copayers.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title *ngIf="wallet">{{ wallet.name }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div *ngIf="wallet" [hidden]="wallet.notAuthorized">\n    <ion-list class="copayers-secret">\n      <ion-item class="list-title">\n        {{ \'Share this invitation with your sqoiners\' | translate }}\n      </ion-item>\n      <ion-item>\n        <div class="qr-code-container" copy-to-clipboard="{{ secret }}">\n          <ngx-qrcode *ngIf="secret" qrc-value="{{secret}}" qrc-class="aclass" qrc-errorCorrectionLevel="L"></ngx-qrcode>\n          <div [hidden]="secret" class="spinner">\n            <ion-spinner></ion-spinner>\n          </div>\n          <div class="secret" text-wrap>\n            {{ secret || (\'Loading...\'|translate) }}\n          </div>\n        </div>\n        <button ion-button clear color="danger" type="button" *ngIf="secret" (click)="showDeletePopup()">\n          {{\'Cancel invitation\' | translate}}\n        </button>\n      </ion-item>\n    </ion-list>\n\n    <div [hidden]="!secret">\n      <ion-card class="copayers-card">\n        <ion-card-header>\n          <span translate>Waiting for sqoiners</span>\n          <span class="gray-color">\n            [\n            <span translate>{{wallet.m}}-of-{{wallet.n}}</span> ]\n          </span>\n        </ion-card-header>\n        <ion-card-content>\n          <ion-list>\n            <div *ngFor="let copayer of copayers">\n              <ion-item [hidden]="copayer.id != wallet.copayerId">\n                <ion-icon ios="ios-checkmark" md="md-checkmark" item-start></ion-icon>\n                {{\'Me\'|translate}}\n              </ion-item>\n              <ion-item [hidden]="copayer.id == wallet.copayerId">\n                <ion-icon ios="ios-checkmark" md="md-checkmark" item-start></ion-icon>\n                {{copayer.name}}\n              </ion-item>\n            </div>\n            <div>\n              <ion-item *ngIf="!wallet.isComplete()">\n                <ion-icon ios="ios-repeat" md="md-repeat" item-start></ion-icon> {{\'Waiting...\'|translate}}\n              </ion-item>\n            </div>\n          </ion-list>\n        </ion-card-content>\n      </ion-card>\n\n      <ion-card [hidden]="!wallet.notAuthorized" class="errors-card">\n        <h1 translate>Wallet incomplete and broken</h1>\n        <h4 translate>Delete it and create a new one</h4>\n      </ion-card>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/add/copayers/copayers.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], CopayersPage);

//# sourceMappingURL=copayers.js.map

/***/ }),

/***/ 146:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_time_time__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pages_backup_backup_warning_backup_warning__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__pages_tx_details_tx_details__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__search_tx_modal_search_tx_modal__ = __webpack_require__(854);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_balance_wallet_balance__ = __webpack_require__(855);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers








// pages





const HISTORY_SHOW_LIMIT = 10;
let WalletDetailsPage = class WalletDetailsPage {
    constructor(navCtrl, navParams, profileProvider, walletProvider, addressbookProvider, bwcError, events, logger, timeProvider, translate, modalCtrl, onGoingProcessProvider, externalLinkProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.addressbookProvider = addressbookProvider;
        this.bwcError = bwcError;
        this.events = events;
        this.logger = logger;
        this.timeProvider = timeProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.currentPage = 0;
        this.history = [];
        this.groupedHistory = [];
        this.updatingTxHistoryProgress = 0;
        this.showBalanceButton = false;
        this.addressbook = {};
        this.txps = [];
        this.updateAll = __WEBPACK_IMPORTED_MODULE_3_lodash__["debounce"]((force) => {
            this.updateStatus(force);
            this.updateTxHistory();
        }, 2000, {
            leading: true
        });
        let clearCache = this.navParams.data.clearCache;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        // Getting info from cache
        if (clearCache) {
            this.clearHistoryCache();
        }
        else {
            this.wallet.status = this.wallet.cachedStatus;
            if (this.wallet.completeHistory)
                this.showHistory();
        }
        this.requiresMultipleSignatures = this.wallet.credentials.m > 1;
        this.addressbookProvider
            .list()
            .then(ab => {
            this.addressbook = ab;
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    ionViewDidEnter() {
        this.updateAll();
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', (walletId, type) => {
            if (walletId == this.wallet.id && type != 'NewAddress')
                this.updateAll();
        });
        this.events.subscribe('Local/TxAction', walletId => {
            if (walletId == this.wallet.id)
                this.updateAll();
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('Local/TxAction');
        this.events.unsubscribe('bwsEvent');
    }
    clearHistoryCache() {
        this.history = [];
        this.currentPage = 0;
    }
    groupHistory(history) {
        return history.reduce((groups, tx, txInd) => {
            this.isFirstInGroup(txInd)
                ? groups.push([tx])
                : groups[groups.length - 1].push(tx);
            return groups;
        }, []);
    }
    showHistory() {
        this.history = this.wallet.completeHistory.slice(0, (this.currentPage + 1) * HISTORY_SHOW_LIMIT);
        this.groupedHistory = this.groupHistory(this.history);
        this.currentPage++;
    }
    setPendingTxps(txps) {
        /* Uncomment to test multiple outputs */
        // var txp = {
        //   message: 'test multi-output',
        //   fee: 1000,
        //   createdOn: new Date() / 1000,
        //   outputs: [],
        //   wallet: $scope.wallet
        // };
        //
        // function addOutput(n) {
        //   txp.outputs.push({
        //     amount: 600,
        //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        //     message: 'output #' + (Number(n) + 1)
        //   });
        // };
        // lodash.times(15, addOutput);
        // txps.push(txp);
        this.txps = !txps ? [] : __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](txps, 'createdOn').reverse();
    }
    updateTxHistory() {
        this.updatingTxHistory = true;
        this.updateTxHistoryError = false;
        this.updatingTxHistoryProgress = 0;
        let progressFn = function (_, newTxs) {
            if (newTxs > 5)
                this.thistory = null;
            this.updatingTxHistoryProgress = newTxs;
        }.bind(this);
        this.walletProvider
            .getTxHistory(this.wallet, {
            progressFn
        })
            .then(txHistory => {
            this.updatingTxHistory = false;
            let hasTx = txHistory[0];
            this.showNoTransactionsYetMsg = hasTx ? false : true;
            this.wallet.completeHistory = txHistory;
            this.showHistory();
        })
            .catch(() => {
            this.updatingTxHistory = false;
            this.updateTxHistoryError = true;
        });
    }
    toggleBalance() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    loadHistory(loading) {
        if (this.history.length === this.wallet.completeHistory.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.showHistory();
            loading.complete();
        }, 300);
    }
    updateStatus(force) {
        this.updatingStatus = true;
        this.updateStatusError = null;
        this.walletNotRegistered = false;
        this.showBalanceButton = false;
        this.walletProvider
            .getStatus(this.wallet, { force: !!force })
            .then(status => {
            this.updatingStatus = false;
            this.setPendingTxps(status.pendingTxps);
            this.wallet.status = status;
            this.showBalanceButton =
                this.wallet.status.totalBalanceSat !=
                    this.wallet.status.spendableAmount;
        })
            .catch(err => {
            this.updatingStatus = false;
            if (err === 'WALLET_NOT_REGISTERED') {
                this.walletNotRegistered = true;
            }
            else {
                this.updateStatusError = this.bwcError.msg(err, this.translate.instant('Could not update wallet'));
            }
            this.wallet.status = null;
        });
    }
    recreate() {
        this.onGoingProcessProvider.set('recreating');
        this.walletProvider
            .recreate(this.wallet)
            .then(() => {
            this.onGoingProcessProvider.clear();
            setTimeout(() => {
                this.walletProvider.startScan(this.wallet).then(() => {
                    this.updateAll(true);
                });
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
        });
    }
    goToTxDetails(tx) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__pages_tx_details_tx_details__["a" /* TxDetailsPage */], {
            walletId: this.wallet.credentials.walletId,
            txid: tx.txid
        });
    }
    openBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__pages_backup_backup_warning_backup_warning__["a" /* BackupWarningPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__pages_settings_wallet_settings_wallet_settings_advanced_wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    getDate(txCreated) {
        let date = new Date(txCreated * 1000);
        return date;
    }
    trackByFn(index) {
        return index;
    }
    isFirstInGroup(index) {
        if (index === 0) {
            return true;
        }
        let curTx = this.history[index];
        let prevTx = this.history[index - 1];
        return !this.createdDuringSameMonth(curTx, prevTx);
    }
    createdDuringSameMonth(curTx, prevTx) {
        return this.timeProvider.withinSameMonth(curTx.time * 1000, prevTx.time * 1000);
    }
    isDateInCurrentMonth(date) {
        return this.timeProvider.isDateInCurrentMonth(date);
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
    isUnconfirmed(tx) {
        return !tx.confirmations || tx.confirmations === 0;
    }
    openBalanceDetails() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_balance_wallet_balance__["a" /* WalletBalancePage */], { status: this.wallet.status });
    }
    back() {
        this.navCtrl.pop();
    }
    openSearchModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_15__search_tx_modal_search_tx_modal__["a" /* SearchTxModalPage */], {
            addressbook: this.addressbook,
            completeHistory: this.wallet.completeHistory,
            wallet: this.wallet
        }, { showBackdrop: false, enableBackdropDismiss: true });
        modal.present();
        modal.onDidDismiss(data => {
            if (!data || !data.txid)
                return;
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__pages_tx_details_tx_details__["a" /* TxDetailsPage */], {
                walletId: this.wallet.credentials.walletId,
                txid: data.txid
            });
        });
    }
    openExternalLink(url) {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
WalletDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/wallet-details/wallet-details.html"*/'<ion-header no-border>\n  <ion-navbar [navbar-bg]="wallet.color">\n    <ion-title>{{wallet.name}}</ion-title>\n    <ion-buttons right>\n      <button ion-button clear *ngIf="wallet && wallet.completeHistory && wallet.completeHistory.length > 4" (click)="openSearchModal()">\n        <ion-icon item-end name="search" class="search-icon"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce #scrollArea [ios-scroll-bg-color]="wallet.color">\n  <div class="wrapper">\n    <expandable-header class="balance-card" [scrollArea]="scrollArea" [ngStyle]="{\'background\': wallet.color}">\n      <expandable-header-primary class="balance-header">\n        <div (longPress)="toggleBalance()">\n          <div (tap)="updateAll(true)" *ngIf="!updateStatusError && !wallet.balanceHidden && !wallet.scanning && wallet.status">\n            <div class="balance-str">{{wallet.status.totalBalanceStr}}</div>\n            <div class="balance-alt-str">\n              {{wallet.status.totalBalanceAlternative}} {{wallet.status.alternativeIsoCode}}\n            </div>\n          </div>\n\n          <div class="balance-hidden" *ngIf="!updateStatusError && wallet.balanceHidden  && !wallet.scanning">\n            <span class="title" translate>[Balance Hidden]</span>\n            <div translate>\n              Tap and hold to show\n            </div>\n          </div>\n        </div>\n\n        <div class="balance-scanning" *ngIf="!updateStatusError && wallet.scanning">\n          <span class="title" translate>[Scanning Funds]</span>\n          <div translate>\n            Please wait...\n          </div>\n        </div>\n\n        <div class="balance-spendable" (click)="openBalanceDetails()" *ngIf="!wallet.balanceHidden && !wallet.scanning && showBalanceButton && wallet.status">\n          <ion-icon ios="ios-timer-outline" md="md-timer"></ion-icon>\n          <strong>\n            {{wallet.status.spendableBalanceStr}}\n          </strong>\n          &nbsp;\n          <span>\n            ({{wallet.status.spendableBalanceAlternative}} {{wallet.status.alternativeIsoCode}})\n          </span>\n          &rarr;\n        </div>\n\n        <div class="balance-error" *ngIf="updateStatusError" (tap)="updateAll(true)">\n          <span class="title">Tap to retry</span>\n          <div>{{updateStatusError}}.</div>\n        </div>\n        <div class="balance-error" *ngIf="walletNotRegistered" (tap)="recreate()">\n          <span class="title">Tap to recreate</span>\n          <div translate>This wallet is not registered at the given Bitcore Wallet Service (BWS). You can recreate it from the local information.</div>\n        </div>\n      </expandable-header-primary>\n      <expandable-header-footer class="wallet-info" *ngIf="wallet">\n        <ion-spinner *ngIf="(updatingStatus || updatingTxHistory) && !walletNotRegistered && !updateStatusError && !updateTxHistoryError"></ion-spinner>\n\n        <img class="testnet" *ngIf="wallet.network == \'testnet\'" src="assets/img/icon-wallet-testnet.svg">\n        <img class="testnet-text" *ngIf="wallet.network == \'testnet\'" src="assets/img/icon-text-testnet.svg">\n        <img class="read-only" *ngIf="!wallet.canSign()" src="assets/img/icon-read-only.svg">\n        <img class="read-only-text" *ngIf="!wallet.canSign()" src="assets/img/icon-text-read-only.svg">\n        <img class="auditable-text" *ngIf="wallet.status && wallet.status.wallet.singleAddress" src="assets/img/icon-text-auditable.svg">\n        <img class="custom-bws" *ngIf="wallet.usingCustomBWS" src="assets/img/icon-bws-white.svg">\n        <img class="encrypted" *ngIf="wallet.isPrivKeyEncrypted()" src="assets/img/icon-lock-white.svg">\n\n        <span class="wallet-type" *ngIf="wallet.credentials.n > 1">\n          <span translate>{{wallet.m}}-of-{{wallet.n}}</span>\n        </span>\n      </expandable-header-footer>\n\n    </expandable-header>\n\n    <div *ngIf="wallet.needsBackup" class="box-notification no-margin warn">\n      <a (click)="openBackup()">\n        <ion-icon name="warning"></ion-icon>\n        {{\'Wallet not backed up\'|translate}}\n        <ion-icon name="arrow-forward"></ion-icon>\n      </a>\n    </div>\n\n    <div *ngIf="wallet.network == \'testnet\'" class="box-notification no-margin warn">\n      <a (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/360004102011-What-is-testnet-How-do-I-avoid-testnet-Bastoji-scams-\')">\n        <ion-icon name="warning"></ion-icon>\n        {{\'Learn more about testnet blockchain\' | translate}}\n        <ion-icon name="arrow-forward"></ion-icon>\n      </a>\n    </div>\n\n    <div *ngIf="lowUtxosWarning" class="box-notification no-margin warn">\n      <a (click)="openAddresses()">\n        <ion-icon name="alert"></ion-icon>\n        {{\'Spending this balance will need significant Bastoji network fees\'|translate}}\n        <ion-icon name="arrow-forward"></ion-icon>\n      </a>\n    </div>\n\n    <div class="history-wrapper">\n\n      <ion-list *ngIf="wallet && wallet.isComplete() && !walletNotRegistered && txps && txps[0]" class="tx-history">\n        <ion-item-divider *ngIf="wallet.incorrectDerivation">\n          <span translate>\n            WARNING: Key derivation is not working on this device/wallet. Actions cannot be performed on this wallet.\n          </span>\n        </ion-item-divider>\n        <ion-item-divider class="tx-history-header tx-history-header--large">\n          <span *ngIf="requiresMultipleSignatures" translate>Proposals</span>\n          <span *ngIf="!requiresMultipleSignatures" translate>Unsent transactions</span>\n        </ion-item-divider>\n        <page-txp *ngFor="let txp of txps" [tx]="txp" [addressbook]="addressbook"></page-txp>\n        <ion-item *ngIf="wallet.status && wallet.status.lockedBalanceSat" class="locked-balance">\n          <span translate>Total Locked Balance</span>\n          <ion-note item-end>\n            <span class="total-locked-amount">{{wallet.status.lockedBalanceStr}}</span>\n            <div class="total-alt-locked-amount">{{wallet.status.lockedBalanceAlternative}} {{wallet.status.alternativeIsoCode}}</div>\n          </ion-note>\n        </ion-item>\n      </ion-list>\n\n      <!-- Transactions -->\n\n      <div class="middle-message" *ngIf="showNoTransactionsYetMsg && !updateStatusError" translate>\n        No transactions yet\n      </div>\n\n      <div class="middle-message" *ngIf="txHistory && !txHistory[0] && updateTxHistoryError" translate>\n        Could not update transaction history\n      </div>\n\n      <div class="middle-message" *ngIf="updatingTxHistory && updatingTxHistoryProgress>5">\n        <span translate>Updating transaction history. Please stand by.</span>\n        <br>\n        <span translate>{{updatingTxHistoryProgress}} transactions downloaded</span>\n      </div>\n\n      <ion-list *ngIf="history && history[0]" class="tx-history">\n        <ion-item-group *ngFor="let group of groupedHistory; trackBy: trackByFn; let i = index;">\n\n          <ion-item-divider sticky class="tx-history-header">\n            <span translate *ngIf="isDateInCurrentMonth(getDate(group[0].time))">Recent</span>\n            <span *ngIf="!isDateInCurrentMonth(getDate(group[0].time))">{{getDate(group[0].time) | amDateFormat:\'MMMM\'}}</span>\n          </ion-item-divider>\n\n          <div class="item-wrapper" *ngFor="let tx of group; trackBy: trackByFn; let i = index">\n\n            <button ion-item (click)="goToTxDetails(tx)">\n              <ion-icon class="item-img" item-start>\n                <div *ngIf="tx.confirmations == 0">\n                  <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n                </div>\n                <div *ngIf="tx.confirmations > 0">\n                  <span *ngIf="tx.customData && tx.customData.service">\n                    <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'"\n                      width="40">\n                    <img class="icon-services" src="assets/img/amazon/icon-amazon.svg" *ngIf="tx.customData.service == \'amazon\'" width="40">\n                    <img class="icon-services" src="assets/img/mercado-libre/icon-ml.svg" *ngIf="tx.customData.service == \'mercadolibre\'" width="40">\n                    <img class="icon-services" src="assets/img/bitpay-card/icon-bitpay.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n                  </span>\n                  <span *ngIf="tx.customData && tx.customData.toWalletName && !tx.customData.service">\n                    <img class="icon-services" src="assets/img/icon-wallet-reverse.svg" *ngIf="tx.action == \'sent\'" width="40">\n                  </span>\n                  <span *ngIf="!tx.customData || (tx.customData && !tx.customData.service && (!tx.customData.toWalletName || tx.customData.toWalletName === wallet.name))">\n                    <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                    <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                    <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n                  </span>\n                </div>\n              </ion-icon>\n\n              <div class="action" *ngIf="tx.confirmations == 0">\n                <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && !(addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{\'Sending\' | translate}}</span>\n                <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}</span>\n                <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n              </div>\n\n              <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n                <span *ngIf="(!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address])">{{\'Received\' | translate}}</span>\n                <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n                <span *ngIf="addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                  {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n                </span>\n              </div>\n\n              <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\'">\n                <span *ngIf="(tx.message && (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)"\n                  translate>Sent</span>\n                <span *ngIf="(tx.message && (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (tx.customData && tx.customData.toWalletName)">{{tx.customData.toWalletName}}</span>\n                <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (!tx.customData || !tx.customData.toWalletName)">{{\'Sent\' | translate}}</span>\n                <span *ngIf="!tx.message && (!tx.note || (tx.note && !tx.note.body)) && (!addressbook || !tx.outputs[0] || !addressbook[tx.outputs[0].address]) && (tx.customData && tx.customData.toWalletName)">{{tx.customData.toWalletName}}</span>\n                <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n                <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n                <span *ngIf="!tx.message && addressbook && tx.outputs[0] && addressbook[tx.outputs[0].address]">\n                  {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n                </span>\n              </div>\n\n              <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n                <span *ngIf="(tx.message && (tx.note && !tx.note.body))" translate>Moved</span>\n                <span *ngIf="((!tx.note || (tx.note && !tx.note.body)) && !tx.message)" translate>Moved</span>\n                <span *ngIf="!tx.note && tx.message">{{tx.message}}</span>\n                <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n              </div>\n\n              <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n                <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n              </div>\n\n              <ion-note item-end text-end>\n                <div class="amount">\n                  <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\'">{{tx.amount | satToUnit: wallet.coin}}</span>\n                  <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n                </div>\n                <div class="date">\n                  <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n                  <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM D, YYYY\'}}</span>\n                </div>\n              </ion-note>\n            </button>\n          </div>\n        </ion-item-group>\n      </ion-list>\n\n      <ion-infinite-scroll (ionInfinite)="loadHistory($event)">\n        <ion-infinite-scroll-content></ion-infinite-scroll-content>\n      </ion-infinite-scroll>\n\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/wallet-details/wallet-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], WalletDetailsPage);

//# sourceMappingURL=wallet-details.js.map

/***/ }),

/***/ 1482:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ExpandableHeaderPrimaryComponent */
/* unused harmony export ExpandableHeaderFooterComponent */
/* unused harmony export ExpandableHeaderComponent */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ExpandableHeaderPrimaryComponent = class ExpandableHeaderPrimaryComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderPrimaryComponent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'expandable-header-primary',
        template: '<ng-content></ng-content>'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
], ExpandableHeaderPrimaryComponent);

let ExpandableHeaderFooterComponent = class ExpandableHeaderFooterComponent {
    constructor(element) {
        this.element = element;
    }
};
ExpandableHeaderFooterComponent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'expandable-header-footer',
        template: '<ng-content></ng-content>'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"]])
], ExpandableHeaderFooterComponent);

let ExpandableHeaderComponent = class ExpandableHeaderComponent {
    constructor(element, renderer) {
        this.element = element;
        this.renderer = renderer;
    }
    ngOnInit() {
        this.scrollArea.ionScroll.subscribe(event => {
            event.domWrite(() => {
                this.applyTransforms(event.scrollTop);
            });
        });
    }
    ngAfterViewInit() {
        this.headerHeight = this.element.nativeElement.offsetHeight;
    }
    applyTransforms(scrollTop) {
        clearTimeout(this.setTransformTo2dTimeout);
        const transformations = this.computeTransformations(scrollTop);
        this.transformPrimaryContent(transformations, true);
        this.transformFooterContent(transformations);
        this.setTransformTo2dTimeout = setTimeout(() => {
            // Using 3d transforms allows us to achieve great performance. However, on iOS devices, switching to a
            // different app and then returning back to this app causes any 3d transformed elements to dissapear
            // initially for some reason. Scrolling again causes them to reappear. However, we can ensure the
            // elements remain visible at all times by switching to 2d transforms once the user stops scrolling.
            this.transformPrimaryContent(transformations, false);
        }, 1000);
    }
    getNewHeaderHeight(scrollTop) {
        const newHeaderHeight = this.headerHeight - scrollTop;
        return newHeaderHeight < 0 ? 0 : newHeaderHeight;
    }
    computeTransformations(scrollTop) {
        const newHeaderHeight = this.getNewHeaderHeight(scrollTop);
        const opacity = this.getScaleValue(newHeaderHeight, 2.5);
        const scale = this.getScaleValue(newHeaderHeight, 0.5);
        const translateY = scrollTop > 0 ? scrollTop / 1.5 : 0;
        return [opacity, scale, translateY];
    }
    getScaleValue(newHeaderHeight, exponent) {
        return (Math.pow(newHeaderHeight, exponent) /
            Math.pow(this.headerHeight, exponent));
    }
    transformPrimaryContent(transformations, is3d) {
        const [opacity, scale, translateY] = transformations;
        const transform3d = `scale3d(${scale}, ${scale}, ${scale}) translateY(${translateY}px)`;
        const transform2d = `scale(${scale}, ${scale}) translate(0, ${translateY}px)`;
        const transformStr = is3d ? transform3d : transform2d;
        this.renderer.setElementStyle(this.primaryContent.element.nativeElement, 'opacity', `${opacity}`);
        this.primaryContent &&
            this.renderer.setElementStyle(this.primaryContent.element.nativeElement, 'transform', transformStr);
    }
    transformFooterContent(transformations) {
        const [opacity] = transformations;
        this.footerContent &&
            this.renderer.setElementStyle(this.footerContent.element.nativeElement, 'opacity', `${opacity}`);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ContentChild"])(ExpandableHeaderPrimaryComponent),
    __metadata("design:type", ExpandableHeaderPrimaryComponent)
], ExpandableHeaderComponent.prototype, "primaryContent", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ContentChild"])(ExpandableHeaderFooterComponent),
    __metadata("design:type", ExpandableHeaderFooterComponent)
], ExpandableHeaderComponent.prototype, "footerContent", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Input"])('scrollArea'),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["d" /* Content */])
], ExpandableHeaderComponent.prototype, "scrollArea", void 0);
ExpandableHeaderComponent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'expandable-header',
        template: '<ng-content></ng-content>'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"]])
], ExpandableHeaderComponent);

const EXPANDABLE_HEADER_COMPONENTS = [
    ExpandableHeaderComponent,
    ExpandableHeaderFooterComponent,
    ExpandableHeaderPrimaryComponent
];
/* harmony export (immutable) */ __webpack_exports__["a"] = EXPANDABLE_HEADER_COMPONENTS;

//# sourceMappingURL=expandable-header.js.map

/***/ }),

/***/ 1483:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProvidersModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_common__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index__ = __webpack_require__(1484);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



let ProvidersModule = class ProvidersModule {
};
ProvidersModule = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["NgModule"])({
        providers: [
            __WEBPACK_IMPORTED_MODULE_2__index__["b" /* AddressProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["a" /* AddressBookProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["d" /* AndroidFingerprintAuth */],
            __WEBPACK_IMPORTED_MODULE_2__index__["f" /* AppProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["e" /* AppIdentityProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["c" /* AmazonProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["g" /* BackupProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["j" /* BitPayProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["i" /* BitPayCardProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["h" /* BitPayAccountProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["l" /* BwcProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["k" /* BwcErrorProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["o" /* ConfigProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["n" /* CoinbaseProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["m" /* Clipboard */],
            __WEBPACK_IMPORTED_MODULE_2__index__["p" /* DerivationPathHelperProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["q" /* Device */],
            __WEBPACK_IMPORTED_MODULE_2__index__["s" /* ExternalLinkProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["v" /* FeedbackProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["t" /* FCM */],
            __WEBPACK_IMPORTED_MODULE_2__index__["z" /* HomeIntegrationsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["u" /* FeeProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["y" /* GlideraProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["A" /* IncomingDataProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["B" /* LanguageProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["C" /* Logger */],
            { provide: 'console', useValue: console },
            __WEBPACK_IMPORTED_MODULE_2__index__["D" /* MercadoLibreProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["E" /* NodeWebkitProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["F" /* OnGoingProcessProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["G" /* PayproProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["I" /* PlatformProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["K" /* ProfileProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["J" /* PopupProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["M" /* QRScanner */],
            __WEBPACK_IMPORTED_MODULE_2__index__["L" /* PushNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["N" /* RateProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["O" /* ReleaseProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["P" /* ReplaceParametersProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["S" /* ShapeshiftProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["V" /* StatusBar */],
            __WEBPACK_IMPORTED_MODULE_2__index__["U" /* SplashScreen */],
            __WEBPACK_IMPORTED_MODULE_2__index__["Q" /* ScanProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["R" /* ScreenOrientation */],
            __WEBPACK_IMPORTED_MODULE_2__index__["T" /* SocialSharing */],
            __WEBPACK_IMPORTED_MODULE_2__index__["X" /* Toast */],
            __WEBPACK_IMPORTED_MODULE_2__index__["Y" /* TouchID */],
            __WEBPACK_IMPORTED_MODULE_2__index__["_2" /* Vibration */],
            __WEBPACK_IMPORTED_MODULE_2__index__["W" /* TimeProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["Z" /* TouchIdProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["_0" /* TxConfirmNotificationProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["x" /* FilterProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["_1" /* TxFormatProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["_3" /* WalletProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["r" /* EmailNotificationsProvider */],
            __WEBPACK_IMPORTED_MODULE_1__angular_common__["d" /* DecimalPipe */],
            __WEBPACK_IMPORTED_MODULE_2__index__["H" /* PersistenceProvider */],
            __WEBPACK_IMPORTED_MODULE_2__index__["w" /* File */]
        ]
    })
], ProvidersModule);

//# sourceMappingURL=providers.module.js.map

/***/ }),

/***/ 1484:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ionic_native_android_fingerprint_auth__ = __webpack_require__(714);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return __WEBPACK_IMPORTED_MODULE_0__ionic_native_android_fingerprint_auth__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__ = __webpack_require__(370);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return __WEBPACK_IMPORTED_MODULE_1__ionic_native_clipboard__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__ = __webpack_require__(184);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return __WEBPACK_IMPORTED_MODULE_2__ionic_native_device__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_fcm__ = __webpack_require__(716);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return __WEBPACK_IMPORTED_MODULE_3__ionic_native_fcm__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__ = __webpack_require__(332);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "w", function() { return __WEBPACK_IMPORTED_MODULE_4__ionic_native_file__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_qr_scanner__ = __webpack_require__(821);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "M", function() { return __WEBPACK_IMPORTED_MODULE_5__ionic_native_qr_scanner__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_screen_orientation__ = __webpack_require__(638);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "R", function() { return __WEBPACK_IMPORTED_MODULE_6__ionic_native_screen_orientation__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "T", function() { return __WEBPACK_IMPORTED_MODULE_7__ionic_native_social_sharing__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__ionic_native_splash_screen__ = __webpack_require__(330);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "U", function() { return __WEBPACK_IMPORTED_MODULE_8__ionic_native_splash_screen__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__ionic_native_status_bar__ = __webpack_require__(331);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "V", function() { return __WEBPACK_IMPORTED_MODULE_9__ionic_native_status_bar__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__ionic_native_toast__ = __webpack_require__(1485);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "X", function() { return __WEBPACK_IMPORTED_MODULE_10__ionic_native_toast__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__ionic_native_touch_id__ = __webpack_require__(715);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Y", function() { return __WEBPACK_IMPORTED_MODULE_11__ionic_native_touch_id__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ionic_native_vibration__ = __webpack_require__(830);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_2", function() { return __WEBPACK_IMPORTED_MODULE_12__ionic_native_vibration__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return __WEBPACK_IMPORTED_MODULE_13__providers_address_book_address_book__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_address_address__ = __webpack_require__(254);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_14__providers_address_address__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return __WEBPACK_IMPORTED_MODULE_15__providers_amazon_amazon__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_app_identity_app_identity__ = __webpack_require__(218);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return __WEBPACK_IMPORTED_MODULE_16__providers_app_identity_app_identity__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_app_app__ = __webpack_require__(27);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return __WEBPACK_IMPORTED_MODULE_17__providers_app_app__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_backup_backup__ = __webpack_require__(849);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return __WEBPACK_IMPORTED_MODULE_18__providers_backup_backup__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_bitpay_account_bitpay_account__ = __webpack_require__(358);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return __WEBPACK_IMPORTED_MODULE_19__providers_bitpay_account_bitpay_account__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return __WEBPACK_IMPORTED_MODULE_20__providers_bitpay_card_bitpay_card__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_bitpay_bitpay__ = __webpack_require__(170);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return __WEBPACK_IMPORTED_MODULE_21__providers_bitpay_bitpay__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return __WEBPACK_IMPORTED_MODULE_22__providers_bwc_error_bwc_error__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return __WEBPACK_IMPORTED_MODULE_23__providers_bwc_bwc__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return __WEBPACK_IMPORTED_MODULE_24__providers_coinbase_coinbase__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_config_config__ = __webpack_require__(10);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return __WEBPACK_IMPORTED_MODULE_25__providers_config_config__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(240);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return __WEBPACK_IMPORTED_MODULE_26__providers_derivation_path_helper_derivation_path_helper__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return __WEBPACK_IMPORTED_MODULE_27__providers_email_notifications_email_notifications__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return __WEBPACK_IMPORTED_MODULE_28__providers_external_link_external_link__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_fee_fee__ = __webpack_require__(82);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return __WEBPACK_IMPORTED_MODULE_29__providers_fee_fee__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_feedback_feedback__ = __webpack_require__(245);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "v", function() { return __WEBPACK_IMPORTED_MODULE_30__providers_feedback_feedback__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_filter_filter__ = __webpack_require__(237);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "x", function() { return __WEBPACK_IMPORTED_MODULE_31__providers_filter_filter__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "y", function() { return __WEBPACK_IMPORTED_MODULE_32__providers_glidera_glidera__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "z", function() { return __WEBPACK_IMPORTED_MODULE_33__providers_home_integrations_home_integrations__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_incoming_data_incoming_data__ = __webpack_require__(238);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "A", function() { return __WEBPACK_IMPORTED_MODULE_34__providers_incoming_data_incoming_data__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_language_language__ = __webpack_require__(135);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "B", function() { return __WEBPACK_IMPORTED_MODULE_35__providers_language_language__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__providers_logger_logger__ = __webpack_require__(5);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "C", function() { return __WEBPACK_IMPORTED_MODULE_36__providers_logger_logger__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "D", function() { return __WEBPACK_IMPORTED_MODULE_37__providers_mercado_libre_mercado_libre__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_38__providers_node_webkit_node_webkit__ = __webpack_require__(239);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return __WEBPACK_IMPORTED_MODULE_38__providers_node_webkit_node_webkit__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_39__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "F", function() { return __WEBPACK_IMPORTED_MODULE_39__providers_on_going_process_on_going_process__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_40__providers_paypro_paypro__ = __webpack_require__(179);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "G", function() { return __WEBPACK_IMPORTED_MODULE_40__providers_paypro_paypro__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_41__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "H", function() { return __WEBPACK_IMPORTED_MODULE_41__providers_persistence_persistence__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_42__providers_platform_platform__ = __webpack_require__(15);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "I", function() { return __WEBPACK_IMPORTED_MODULE_42__providers_platform_platform__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_43__providers_popup_popup__ = __webpack_require__(11);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "J", function() { return __WEBPACK_IMPORTED_MODULE_43__providers_popup_popup__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_44__providers_profile_profile__ = __webpack_require__(14);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "K", function() { return __WEBPACK_IMPORTED_MODULE_44__providers_profile_profile__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_45__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "L", function() { return __WEBPACK_IMPORTED_MODULE_45__providers_push_notifications_push_notifications__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_46__providers_rate_rate__ = __webpack_require__(113);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "N", function() { return __WEBPACK_IMPORTED_MODULE_46__providers_rate_rate__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_47__providers_release_release__ = __webpack_require__(740);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "O", function() { return __WEBPACK_IMPORTED_MODULE_47__providers_release_release__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_48__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "P", function() { return __WEBPACK_IMPORTED_MODULE_48__providers_replace_parameters_replace_parameters__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_49__providers_scan_scan__ = __webpack_require__(820);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Q", function() { return __WEBPACK_IMPORTED_MODULE_49__providers_scan_scan__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_50__providers_shapeshift_shapeshift__ = __webpack_require__(144);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "S", function() { return __WEBPACK_IMPORTED_MODULE_50__providers_shapeshift_shapeshift__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_51__providers_time_time__ = __webpack_require__(88);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "W", function() { return __WEBPACK_IMPORTED_MODULE_51__providers_time_time__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_52__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Z", function() { return __WEBPACK_IMPORTED_MODULE_52__providers_touchid_touchid__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_53__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(356);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_0", function() { return __WEBPACK_IMPORTED_MODULE_53__providers_tx_confirm_notification_tx_confirm_notification__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_54__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_1", function() { return __WEBPACK_IMPORTED_MODULE_54__providers_tx_format_tx_format__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_55__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "_3", function() { return __WEBPACK_IMPORTED_MODULE_55__providers_wallet_wallet__["a"]; });
/* Native modules */













/* Providers */











































//# sourceMappingURL=index.js.map

/***/ }),

/***/ 15:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PlatformProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let PlatformProvider = class PlatformProvider {
    constructor(platform, logger) {
        this.platform = platform;
        this.logger = logger;
        let ua = navigator ? navigator.userAgent : null;
        if (!ua) {
            this.logger.info('Could not determine navigator. Using fixed string');
            ua = 'dummy user-agent';
        }
        // Fixes IOS WebKit UA
        ua = ua.replace(/\(\d+\)$/, '');
        this.isAndroid = this.platform.is('android');
        this.isIOS = this.platform.is('ios');
        this.ua = ua;
        this.isCordova = this.platform.is('cordova');
        this.isNW = this.isNodeWebkit();
        this.isMobile = this.platform.is('mobile');
        this.isDevel = !this.isMobile && !this.isNW;
        this.logger.info('PlatformProvider initialized.');
    }
    getBrowserName() {
        let userAgent = window.navigator.userAgent;
        let browsers = {
            chrome: /chrome/i,
            safari: /safari/i,
            firefox: /firefox/i,
            ie: /internet explorer/i
        };
        for (let key in browsers) {
            if (browsers[key].test(userAgent)) {
                return key;
            }
        }
        return 'unknown';
    }
    isNodeWebkit() {
        let isNode = typeof process !== 'undefined' && "function" !== 'undefined';
        if (isNode) {
            try {
                return typeof window.require('nw.gui') !== 'undefined';
            }
            catch (e) {
                return false;
            }
        }
        return false;
    }
};
PlatformProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */], __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], PlatformProvider);

//# sourceMappingURL=platform.js.map
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(34)))

/***/ }),

/***/ 17:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnGoingProcessProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





let OnGoingProcessProvider = class OnGoingProcessProvider {
    constructor(loadingCtrl, logger, translate) {
        this.loadingCtrl = loadingCtrl;
        this.logger = logger;
        this.translate = translate;
        this.logger.info('OnGoingProcessProvider initialized.');
        // TODO GET - CLEAR - CHECK DecimalPipe for FILTER WITH TRANSLATE
        this.ongoingProcess = [];
    }
    getProccessNames() {
        const processNames = {
            broadcastingTx: this.translate.instant('Broadcasting transaction...'),
            calculatingFee: this.translate.instant('Calculating fee...'),
            connectingCoinbase: this.translate.instant('Connecting to Coinbase...'),
            connectingGlidera: this.translate.instant('Connecting to Glidera...'),
            connectingShapeshift: this.translate.instant('Connecting to ShapeShift...'),
            creatingTx: this.translate.instant('Creating transaction...'),
            creatingWallet: this.translate.instant('Creating Wallet...'),
            deletingWallet: this.translate.instant('Deleting Wallet...'),
            extractingWalletInfo: this.translate.instant('Extracting Wallet information...'),
            fetchingPayPro: this.translate.instant('Fetching payment information...'),
            generatingCSV: this.translate.instant('Generating .csv file...'),
            gettingFeeLevels: this.translate.instant('Getting fee levels...'),
            importingWallet: this.translate.instant('Importing Wallet...'),
            joiningWallet: this.translate.instant('Joining Wallet...'),
            recreating: this.translate.instant('Recreating Wallet...'),
            rejectTx: this.translate.instant('Rejecting payment proposal...'),
            removeTx: this.translate.instant('Deleting payment proposal...'),
            retrievingInputs: this.translate.instant('Retrieving inputs information...'),
            scanning: this.translate.instant('Scanning Wallet funds...'),
            sendingTx: this.translate.instant('Sending transaction...'),
            signingTx: this.translate.instant('Signing transaction...'),
            sweepingWallet: this.translate.instant('Sweeping Wallet...'),
            validatingWords: this.translate.instant('Validating recovery phrase...'),
            loadingTxInfo: this.translate.instant('Loading transaction info...'),
            sendingFeedback: this.translate.instant('Sending feedback...'),
            generatingNewAddress: this.translate.instant('Generating new address...'),
            sendingByEmail: this.translate.instant('Preparing addresses...'),
            sending2faCode: this.translate.instant('Sending 2FA code...'),
            buyingBastoji: this.translate.instant('Buying Bastoji...'),
            sellingBastoji: this.translate.instant('Selling Bastoji...'),
            fetchingBitPayAccount: this.translate.instant('Fetching BitPay Account...'),
            fetchingBitPayCards: this.translate.instant('Fetching BitPay Cards...'),
            updatingGiftCards: this.translate.instant('Updating Gift Cards...'),
            updatingGiftCard: this.translate.instant('Updating Gift Card...'),
            cancelingGiftCard: this.translate.instant('Canceling Gift Card...'),
            creatingGiftCard: this.translate.instant('Creating Gift Card...'),
            buyingGiftCard: this.translate.instant('Buying Gift Card...'),
            topup: this.translate.instant('Top up in progress...'),
            duplicatingWallet: this.translate.instant('Duplicating wallet...')
        };
        return processNames;
    }
    clear() {
        this.ongoingProcess = [];
        try {
            this.loading.dismiss();
        }
        catch (e) {
            // No problem
            this.logger.warn('on-going-process is still active. No problem.', e);
        }
        this.loading = null;
        this.logger.debug('ongoingProcess clear');
    }
    pause() {
        this.pausedOngoingProcess = this.ongoingProcess;
        this.clear();
    }
    resume() {
        this.ongoingProcess = this.pausedOngoingProcess;
        __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](this.pausedOngoingProcess, v => {
            this.set(v);
            return;
        });
        this.pausedOngoingProcess = [];
    }
    set(processName) {
        this.logger.debug('ongoingProcess active: ', processName);
        this.ongoingProcess.push(processName);
        let showName = this.getProccessNames()[processName] || processName;
        if (!this.loading) {
            this.loading = this.loadingCtrl.create();
        }
        this.loading.setContent(showName);
        this.loading.present();
    }
};
OnGoingProcessProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["i" /* LoadingController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], OnGoingProcessProvider);

//# sourceMappingURL=on-going-process.js.map

/***/ }),

/***/ 170:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth__ = __webpack_require__(643);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_bitauth__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers


let BitPayProvider = class BitPayProvider {
    constructor(http, appIdentityProvider, logger) {
        this.http = http;
        this.appIdentityProvider = appIdentityProvider;
        this.logger = logger;
        this.logger.info('BitPayProvider initialized.');
        this.NETWORK = 'livenet';
        this.BITPAY_API_URL =
            this.NETWORK == 'livenet'
                ? 'https://bitpay.com'
                : 'https://test.bitpay.com';
    }
    getEnvironment() {
        return {
            network: this.NETWORK
        };
    }
    get(endpoint, successCallback, errorCallback) {
        let url = this.BITPAY_API_URL + endpoint;
        let headers = {
            'Content-Type': 'application/json'
        };
        this.http.get(url, { headers }).subscribe(data => {
            successCallback(data);
        }, data => {
            errorCallback(data);
        });
    }
    post(endpoint, json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            let dataToSign = this.BITPAY_API_URL + endpoint + JSON.stringify(json);
            let signedData = __WEBPACK_IMPORTED_MODULE_4_bitauth__["sign"](dataToSign, appIdentity.priv);
            let url = this.BITPAY_API_URL + endpoint;
            let headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]().set('content-type', 'application/json');
            headers = headers.append('x-identity', appIdentity.pub);
            headers = headers.append('x-signature', signedData);
            this.http.post(url, json, { headers }).subscribe(data => {
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
    postAuth(json, successCallback, errorCallback) {
        this.appIdentityProvider.getIdentity(this.getEnvironment().network, (err, appIdentity) => {
            if (err) {
                return errorCallback(err);
            }
            json['params'].signature = __WEBPACK_IMPORTED_MODULE_4_bitauth__["sign"](JSON.stringify(json.params), appIdentity.priv);
            json['params'].pubkey = appIdentity.pub;
            json['params'] = JSON.stringify(json.params);
            let url = this.BITPAY_API_URL + '/api/v2/';
            let headers = {
                'Content-Type': 'application/json'
            };
            this.logger.debug('post auth:' + JSON.stringify(json));
            this.http.post(url, json, { headers }).subscribe((data) => {
                data.appIdentity = appIdentity;
                successCallback(data);
            }, data => {
                errorCallback(data);
            });
        });
    }
};
BitPayProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], BitPayProvider);

//# sourceMappingURL=bitpay.js.map

/***/ }),

/***/ 179:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PayproProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_text_encoding__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_text_encoding___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_text_encoding__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__profile_profile__ = __webpack_require__(14);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers


let PayproProvider = class PayproProvider {
    constructor(profileProvider, logger, onGoingProcessProvider, translate) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.translate = translate;
        this.logger.info('PayproProvider initialized');
    }
    getPayProDetails(uri, coin, disableLoader) {
        return new Promise((resolve, reject) => {
            let wallet = this.profileProvider.getWallets({
                onlyComplete: true,
                coin
            })[0];
            if (!wallet)
                return resolve();
            this.logger.debug('Fetch PayPro Request...', uri);
            if (disableLoader) {
                this.onGoingProcessProvider.set('');
            }
            else {
                this.onGoingProcessProvider.set('fetchingPayPro');
            }
            wallet.fetchPayPro({
                payProUrl: uri
            }, (err, paypro) => {
                this.onGoingProcessProvider.clear();
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isArrayBuffer"](err)) {
                    const enc = new __WEBPACK_IMPORTED_MODULE_4_text_encoding___default.a.TextDecoder();
                    err = enc.decode(err);
                    return reject(err);
                }
                else if (err)
                    return reject(this.translate.instant('Could Not Fetch Payment: Check if it is still valid'));
                else if (!paypro.verified) {
                    this.logger.warn('Failed to verify payment protocol signatures');
                    return reject(this.translate.instant('Payment Protocol Invalid'));
                }
                return resolve(paypro);
            });
        });
    }
};
PayproProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], PayproProvider);

//# sourceMappingURL=paypro.js.map

/***/ }),

/***/ 180:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupWarningPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__backup_game_backup_game__ = __webpack_require__(717);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// pages


let BackupWarningPage = class BackupWarningPage {
    constructor(navCtrl, navParams, alertCtrl, popupProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.alertCtrl = alertCtrl;
        this.popupProvider = popupProvider;
        this.walletId = this.navParams.get('walletId');
        this.fromOnboarding = this.navParams.get('fromOnboarding');
    }
    openWarningModal() {
        const backupWarningModal = this.popupProvider.createMiniModal('backup-warning');
        backupWarningModal.present({ animate: false });
        backupWarningModal.onDidDismiss(response => {
            if (response) {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_2__backup_game_backup_game__["a" /* BackupGamePage */], {
                    walletId: this.walletId,
                    fromOnboarding: this.fromOnboarding
                });
            }
        });
    }
};
BackupWarningPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-backup-warning',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/backup/backup-warning/backup-warning.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton="fromOnboarding"></ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <h3 class="title" translate>Are you being watched?</h3>\n  <p translate class="top-description">Now is a perfect time to assess your surroundings. Nearby windows? Hidden cameras? Shoulder-spies?</p>\n  <div class="img-container">\n    <img src=\'assets/img/app/onboarding/backup-warning.svg\' />\n  </div>\n  <div class="bottom-absolute">\n    <p translate class="bottom-description">Anyone with your backup phrase can access or spend your bastoji.</p>\n    <button ion-button class="button-standard" (click)="openWarningModal()">\n      {{\'Got it\' | translate}}\n    </button>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/backup/backup-warning/backup-warning.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_popup_popup__["a" /* PopupProvider */]])
], BackupWarningPage);

//# sourceMappingURL=backup-warning.js.map

/***/ }),

/***/ 181:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DisclaimerPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__tabs_tabs__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








let DisclaimerPage = class DisclaimerPage {
    constructor(navCtrl, logger, emailProvider, externalLinkProvider, persistenceProvider, translate) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.emailProvider = emailProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.hasEmail = this.emailProvider.getEmailIfEnabled() ? true : false;
        this.accepted = {
            first: false,
            second: false,
            third: this.hasEmail ? false : true
        };
        this.terms = {
            accepted: false
        };
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad DisclaimerPage');
    }
    selectTerms() {
        this.terms.accepted = !this.terms.accepted;
    }
    openDisclaimer() {
        let url = 'https://bitpay.com/about/terms#wallet';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Wallet Terms of Use');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPrivacyPolicy() {
        let url = 'https://bitpay.com/about/privacy';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Privacy Policy');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    confirm() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.persistenceProvider.setDisclaimerAccepted();
        this.navCtrl.setRoot(__WEBPACK_IMPORTED_MODULE_4__tabs_tabs__["a" /* TabsPage */]);
        this.navCtrl.popToRoot({ animate: false });
    }
};
DisclaimerPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-disclaimer',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/onboarding/disclaimer/disclaimer.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton="true"></ion-navbar>\n</ion-header>\n<ion-content no-bounce>\n  <h3 *ngIf="resume" class="title" translate>Quick review!</h3>\n  <h3 *ngIf="!resume" class="title" translate>Almost done! Let\'s review.</h3>\n  <p class="top-description" translate>Bastoji is different - it cannot be safely held with a bank or web service.</p>\n  <ion-list class="checkbox-list" no-lines>\n    <ion-item>\n      <ion-label>\n        {{\'I understand that my funds are held securely on this device, not by a company\' | translate}}.\n      </ion-label>\n      <ion-checkbox [(ngModel)]="accepted.first"></ion-checkbox>\n    </ion-item>\n    <ion-item>\n      <ion-label>\n        {{\'I understand that if this app is moved to another device or deleted, my bastoji can only be recovered with the backup phrase\' | translate}}.\n      </ion-label>\n      <ion-checkbox [(ngModel)]="accepted.second"></ion-checkbox>\n    </ion-item>\n    <div *ngIf="hasEmail">\n      <ion-item>\n        <ion-label>\n          <span translate>I give explicit consent to BitPay to use my email address to send me email notifications about payments (and, if selected, email updates and news about the wallet).</span> \n        </ion-label>\n        <ion-checkbox [(ngModel)]="accepted.third"></ion-checkbox>\n      </ion-item>\n      <a class="externalLink" (click)="openPrivacyPolicy()" translate>View Privacy Policy</a>\n    </div>\n  </ion-list>\n</ion-content>\n<ion-footer>\n  <ion-toolbar>\n    <div class="checkbox-list">\n      <div *ngIf="accepted.first && accepted.second && accepted.third">\n        <ion-item no-lines>\n          <ion-label>\n            {{\'I have read, understood, and agree to the Terms of Use\' | translate}}.\n          </ion-label>\n          <ion-checkbox [(ngModel)]="terms.accepted"></ion-checkbox>\n        </ion-item>\n        <a class="externalLink" (click)="openDisclaimer()" translate>Terms of Use</a>\n      </div>\n      <button ion-button class="button-standard" [disabled]="!accepted.first || !accepted.second || !accepted.third || !terms.accepted" (click)="confirm()">\n        <span translate>Confirm &amp; Finish</span>\n      </button>\n    </div>\n  </ion-toolbar>\n</ion-footer>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/onboarding/disclaimer/disclaimer.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], DisclaimerPage);

//# sourceMappingURL=disclaimer.js.map

/***/ }),

/***/ 182:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__coinbase_tx_details_coinbase_tx_details__ = __webpack_require__(724);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers





// pages



let CoinbasePage = class CoinbasePage {
    constructor(coinbaseProvider, logger, popupProvider, navCtrl, externalLinkProvider, platformProvider, onGoingProcessProvider, modalCtrl, navParams, formBuilder) {
        this.coinbaseProvider = coinbaseProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
        this.platformProvider = platformProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.pendingTransactions = { data: {} };
        this.isNW = false; // TODO: desktop
        this.oauthCodeForm = this.formBuilder.group({
            code: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required])
            ]
        });
        this.isNW = this.platformProvider.isNW;
        this.isCordova = this.platformProvider.isCordova;
        this.showOauthForm = false;
    }
    ionViewWillEnter() {
        if (this.navParams.data.code) {
            this.coinbaseProvider.getStoredToken((at) => {
                if (!at)
                    this.submitOauthCode(this.navParams.data.code);
            });
        }
        else {
            this.init();
        }
    }
    init() {
        this.currency = this.coinbaseProvider.getAvailableCurrency();
        this.loading = true;
        this.coinbaseProvider.getStoredToken((at) => {
            this.accessToken = at;
            // Update Access Token if necessary
            this.coinbaseProvider.init((err, data) => {
                if (err || __WEBPACK_IMPORTED_MODULE_11_lodash__["isEmpty"](data)) {
                    this.loading = false;
                    if (err) {
                        this.logger.error(err);
                        let errorId = err.errors ? err.errors[0].id : null;
                        err = err.errors
                            ? err.errors[0].message
                            : err.error_description
                                ? err.error_description
                                : err.error || 'Unknown error';
                        this.popupProvider
                            .ionicAlert('Error connecting to Coinbase', err)
                            .then(() => {
                            if (errorId == 'revoked_token') {
                                this.coinbaseProvider.logout();
                            }
                            this.navCtrl.pop();
                        });
                    }
                    return;
                }
                // Show rates
                this.coinbaseProvider.buyPrice(data.accessToken, this.currency, (_, b) => {
                    this.buyPrice = b.data || null;
                    this.coinbaseProvider.sellPrice(data.accessToken, this.currency, (_, s) => {
                        this.sellPrice = s.data || null;
                        this.loading = false;
                    });
                });
                // Updating accessToken and accountId
                this.accessToken = data.accessToken;
                this.accountId = data.accountId;
                this.updateTransactions();
            });
        });
    }
    updateTransactions() {
        this.logger.debug('Getting transactions...');
        this.coinbaseProvider.getPendingTransactions(this.pendingTransactions);
    }
    openAuthenticateWindow() {
        let oauthUrl = this.getAuthenticateUrl();
        if (!this.isNW) {
            this.externalLinkProvider.open(oauthUrl);
        }
        else {
            let gui = window.require('nw.gui');
            gui.Window.open(oauthUrl, {
                focus: true,
                position: 'center'
            }, new_win => {
                new_win.on('loaded', () => {
                    let title = new_win.window.document.title;
                    if (title.indexOf('Coinbase') == -1) {
                        this.code = title;
                        this.submitOauthCode(this.code);
                        new_win.close();
                    }
                });
            });
        }
    }
    submitOauthCode(code) {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.getToken(code, (err, accessToken) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Error connecting to Coinbase', err);
                return;
            }
            this.accessToken = accessToken;
            this.init();
        });
    }
    getAuthenticateUrl() {
        this.showOauthForm = this.isCordova || this.isNW ? false : true;
        return this.coinbaseProvider.getOauthCodeUrl();
    }
    openSignupWindow() {
        let url = this.coinbaseProvider.getSignupUrl();
        let optIn = true;
        let title = 'Sign Up for Coinbase';
        let message = 'This will open Coinbase.com, where you can create an account.';
        let okText = 'Go to Coinbase';
        let cancelText = 'Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openSupportWindow() {
        let url = this.coinbaseProvider.getSupportUrl();
        let optIn = true;
        let title = 'Coinbase Support';
        let message = 'You can email support@coinbase.com for direct support, or you can view their help center.';
        let okText = 'Open Help Center';
        let cancelText = 'Go Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    toggleOauthForm() {
        this.showOauthForm = !this.showOauthForm;
    }
    openTxModal(tx) {
        this.tx = tx;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_10__coinbase_tx_details_coinbase_tx_details__["a" /* CoinbaseTxDetailsPage */], { tx: this.tx });
        modal.present();
        modal.onDidDismiss(data => {
            if (data.updateRequired)
                this.updateTransactions();
        });
    }
    goToBuyCoinbasePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'BuyCoinbasePage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
    goToSellCoinbasePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'SellCoinbasePage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
};
CoinbasePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-coinbase',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div *ngIf="!accessToken" class="center-header">\n    <img margin src="assets/img/coinbase/coinbase-logo.png" width="200">\n    <div margin-bottom padding>\n      <div *ngIf="!showOauthForm">Coinbase\'s exchange service is available in 33 countries, and can take 3-5 days to buy or sell bastoji.</div>\n      <div *ngIf="showOauthForm">If you have trouble, contact Coinbase support for direct assistance.</div>\n    </div>\n    <button  *ngIf="!showOauthForm" ion-button outline class="button-standard" (click)="openAuthenticateWindow()">Connect Coinbase Account</button>\n    <button  *ngIf="!showOauthForm" ion-button clear small color="dark" (click)="openSignupWindow()">Sign Up for Coinbase &rarr;</button>\n    <div *ngIf="showOauthForm">\n      <form [formGroup]="oauthCodeForm" (ngSubmit)="submitOauthCode(oauthCodeForm.value.code)">\n        <ion-label stacked>OAuth Code</ion-label>\n        <ion-input type="text" formControlName="code" [value]="oauthCodeForm.value.code" placeholder="{{\'Enter OAuth Code\'}}" required></ion-input>\n        <button ion-button block outline type="submit" [disabled]="!oauthCodeForm.valid">Connect Coinbase Account</button>\n      </form>\n      <button ion-button block clear small color="dark" (click)="openSupportWindow()">Coinbase Support &rarr;</button>\n    </div>\n  </div>\n  <div *ngIf="accessToken">\n    <div class="main-header">\n      <img margin src="assets/img/coinbase/coinbase-logo-white.svg" (click)="updateTransactions()">\n      <ion-spinner *ngIf="loading"></ion-spinner>\n    </div>\n    <ion-list>\n      <button ion-item (click)="goToBuyCoinbasePage()">\n        <ion-icon item-start>\n          <img src="assets/img/buy-bastoji.svg" alt="buy bastoji" width="30">\n        </ion-icon>\n        <ion-label>Buy</ion-label>\n        <ion-note *ngIf="buyPrice" item-end>\n          {{buyPrice.amount|currency:\'$\':2}} {{buyPrice.currency}}/BTJ\n        </ion-note>\n      </button>\n      <button ion-item (click)="goToSellCoinbasePage()">\n        <ion-icon item-start>\n          <img src="assets/img/sell-bastoji.svg" alt="sell bastoji" width="30">\n        </ion-icon>\n        <ion-label>Sell</ion-label>\n        <ion-note *ngIf="sellPrice"  item-end>\n          {{sellPrice.amount|currency:\'$\':2}} {{sellPrice.currency}}/BTJ\n        </ion-note>\n      </button>\n      <ion-item-divider>Activity</ion-item-divider>\n      <div *ngIf="pendingTransactions.data && !error">\n        <button ion-item (click)="openTxModal(tx)" *ngFor="let tx of pendingTransactions.data | keys">\n          <ion-icon item-start>\n              <img src="assets/img/bought-pending.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.to &&tx.type == \'send\')) && tx.status != \'completed\'">\n              <img src="assets/img/bought.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.to &&tx.type == \'send\')) && tx.status == \'completed\'">\n              <img src="assets/img/sold-pending.svg" alt="sold" *ngIf="tx.from && tx.type == \'send\'">\n              <img src="assets/img/sold.svg" alt="sold" *ngIf="!tx.from && tx.type == \'sell\' && tx.status == \'completed\'">\n          </ion-icon>\n          <span *ngIf="tx.type == \'sell\' && tx.status == \'completed\'">Sold</span>\n          <span *ngIf="tx.type == \'send\' && tx.to && tx.status == \'completed\'">Bought</span>\n          <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.amount.amount.replace(\'-\',\'\')}}\n          {{tx.amount.currency}}\n          <ion-note item-end text-end>\n            <div class="assertive" *ngIf="tx.error || tx.status == \'error\'">\n              Error\n            </div>\n            <div *ngIf="!tx.error">\n              <div *ngIf="tx.status == \'completed\'">\n                <time *ngIf="tx.created_at">{{tx.created_at | amTimeAgo}}</time>\n              </div>\n              <div *ngIf="tx.status == \'pending\'">\n                <span *ngIf="tx.status == \'pending\'">Pending</span>\n              </div>\n            </div>\n          </ion-note>\n        </button>\n      </div>\n    </ion-list>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */]])
], CoinbasePage);

//# sourceMappingURL=coinbase.js.map

/***/ }),

/***/ 183:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlideraPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__glidera_tx_details_glidera_tx_details__ = __webpack_require__(727);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




// pages


let GlideraPage = class GlideraPage {
    constructor(externalLinkProvider, onGoingProcessProvider, glideraProvider, popupProvider, logger, navParams, navCtrl, formBuilder, modalCtrl) {
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.glideraProvider = glideraProvider;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.formBuilder = formBuilder;
        this.modalCtrl = modalCtrl;
        this.oauthCodeForm = this.formBuilder.group({
            code: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required])
            ]
        });
        this.network = this.glideraProvider.getNetwork();
        this.currency = this.glideraProvider.getCurrency();
        this.showOauthForm = false;
        this.account = {};
    }
    ionViewDidEnter() {
        if (this.navParams.data && this.navParams.data.code)
            this.submitOauthCode(this.navParams.data.code);
        else
            this.init();
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    init() {
        this.onGoingProcessProvider.set('connectingGlidera');
        this.glideraProvider.init((err, data) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Error connecting Glidera', err + '. Please re-connect to Glidera');
                return;
            }
            if (!data || (data && !data.token))
                return;
            this.account.token = data.token;
            this.account.status = data.status;
            this.account.txs = data.txs;
            this.update();
        });
    }
    update() {
        this.logger.debug('Updating Glidera...');
        this.glideraProvider.updateStatus(this.account);
    }
    getAuthenticateUrl() {
        return this.glideraProvider.getOauthCodeUrl();
    }
    submitOauthCode(code) {
        this.onGoingProcessProvider.set('connectingGlidera');
        this.glideraProvider.authorize(code, (err, data) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Authorization error', err);
                return;
            }
            this.account.token = data.token;
            this.account.status = data.status;
            this.init();
        });
    }
    openTxModal(tx) {
        this.tx = tx;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_9__glidera_tx_details_glidera_tx_details__["a" /* GlideraTxDetailsPage */], { tx: this.tx });
        modal.present();
        this.glideraProvider.getTransaction(this.account.token, tx.transactionUuid, (err, tx) => {
            if (err) {
                this.popupProvider.ionicAlert('Error getting transaction', 'Could not get transactions');
                return;
            }
            this.tx = tx;
        });
    }
    openAuthenticateWindow() {
        this.openExternalLink(this.getAuthenticateUrl());
        this.navCtrl.popToRoot();
    }
    openLoginWindow() {
        let glideraUrl = this.network === 'testnet'
            ? 'https://sandbox.glidera.io/login'
            : 'https://glidera.io/login';
        this.openExternalLink(glideraUrl);
    }
    openSupportWindow() {
        var url = this.glideraProvider.getSupportUrl();
        var optIn = true;
        var title = 'Glidera Support';
        var message = 'You can email glidera at support@glidera.io for direct support, or you can contact Glidera on Twitter.';
        var okText = 'Tweet @GlideraInc';
        var cancelText = 'Go Back';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    toggleOauthForm() {
        this.showOauthForm = !this.showOauthForm;
    }
    goToBuyGlideraPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'BuyGlideraPage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
    goToSellGlideraPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'SellGlideraPage',
            currency: this.currency,
            coin: 'btc',
            fixedUnit: true
        });
    }
};
GlideraPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-glidera',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Glidera</ion-title>\n    <ion-buttons right>\n      <button ion-button *ngIf="!account.token" (click)="toggleOauthForm()">\n        <span *ngIf="!showOauthForm">Enter Code</span>\n        <span *ngIf="showOauthForm">Restart</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div *ngIf="!account.token" class="center-header">\n    <img src="assets/img/glidera/glidera-logo.png" width="200">\n    <div padding margin *ngIf="!showOauthForm" text-wrap>Glidera\'s exchange service is available in the United States, and can take 1-2 weeks to buy or sell bastoji.\n      <a (click)="openSupportWindow()">Glidera Support</a>\n    </div>\n    <div padding margin *ngIf="showOauthForm" text-wrap>If you have trouble, contact\n      <a (click)="openSupportWindow()">Glidera support</a> for direct assistance.\n    </div>\n    <button *ngIf="!showOauthForm" ion-button outline class="button-standard" (click)="openAuthenticateWindow()">Connect to Glidera</button>\n    <div class="form-container">\n      <form *ngIf="showOauthForm" [formGroup]="oauthCodeForm" (ngSubmit)="submitOauthCode(oauthCodeForm.value.code)">\n        <ion-item>\n          <ion-label stacked>OAuth Code</ion-label>\n          <ion-input type="text" formControlName="code" [value]="oauthCodeForm.value.code" placeholder="{{\'Enter OAuth Code\'}}" required></ion-input>\n        </ion-item>\n        <button ion-button type="submit" class="button-standard" [disabled]="!oauthCodeForm.valid">Connect Glidera Account</button>\n      </form>\n    </div>\n  </div>\n  <div *ngIf="account.token && account.status && !account.status.userCanTransact" class="center-header">\n    <img src="assets/img/glidera/glidera-logo.png" width="200">\n    <div padding margin text-wrap>Please complete your account verification on Glidera\'s website. If you have trouble, contact\n      <a (click)="openSupportWindow()">Glidera support</a> for direct assistance.\n    </div>\n    <button ion-button outline class="button-standard" (click)="openLoginWindow()">Complete Glidera Setup</button>\n  </div>\n  <div *ngIf="account.token && account.status && account.status.userCanTransact">\n    <div class="main-header">\n      <img src="assets/img/glidera/glidera-logo.png" width="200" (click)="update()">\n    </div>\n    <ion-list>\n      <button ion-item *ngIf="account.status.userCanBuy" (click)="goToBuyGlideraPage()">\n        <ion-icon item-start>\n          <img src="assets/img/buy-bastoji.svg" alt="buy bastoji" class="item-img-buy">\n        </ion-icon>\n        <ion-label>Buy Bastoji</ion-label>\n        <ion-note *ngIf="account.price && account.price.buy" item-end>\n          ${{account.price.buy}}/BTJ\n        </ion-note>\n      </button>\n      <button ion-item *ngIf="account.status.userCanSell" (click)="goToSellGlideraPage()">\n        <ion-icon item-start>\n          <img src="assets/img/sell-bastoji.svg" alt="sell bastoji" class="item-img-sell">\n        </ion-icon>\n        <ion-label>Sell Bastoji</ion-label>\n        <ion-note *ngIf="account.price && account.price.sell" item-end>\n          ${{account.price.sell}}/BTJ\n        </ion-note>\n      </button>\n      <ion-item-divider>Activity</ion-item-divider>\n      <div *ngIf="account.txs && account.txs.length > 0">\n        <button ion-item *ngFor="let tx of account.txs" (click)="openTxModal(tx)">\n          <ion-icon item-start>\n            <img src="assets/img/bought.svg" alt="bought" width="39" *ngIf="tx.type == \'BUY\' && tx.status == \'COMPLETE\'">\n            <img src="assets/img/bought-pending.svg" alt="bought" width="33" *ngIf="tx.type == \'BUY\' && tx.status == \'PROCESSING\'">\n            <img src="assets/img/sold.svg" alt="bought" width="39" *ngIf="tx.type == \'SELL\' && tx.status == \'COMPLETE\'">\n            <img src="assets/img/sold-pending.svg" alt="bought" width="33" *ngIf="tx.type == \'SELL\' && tx.status == \'PROCESSING\'">\n          </ion-icon>\n          <span *ngIf="tx.type == \'BUY\'">Bought</span>\n          <span *ngIf="tx.type == \'SELL\'">Sold</span>\n          <b>{{tx.qty}}</b> BTJ\n          <div class="amount">{{tx.subtotal|currency:\'\':2}} {{tx.currency}}</div>\n          <ion-note class="details" item-end text-end>\n            <div *ngIf="tx.status == \'COMPLETE\' && tx.transactionDate">\n              <time>{{tx.transactionDate | amTimeAgo}}</time>\n            </div>\n            <div *ngIf="tx.status == \'PROCESSING\'">\n              Processing\n            </div>\n          </ion-note>\n        </button>\n      </div>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__["a" /* GlideraProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */]])
], GlideraPage);

//# sourceMappingURL=glidera.js.map

/***/ }),

/***/ 190:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookAddPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__validators_address__ = __webpack_require__(1188);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__scan_scan__ = __webpack_require__(367);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers



// validators


let AddressbookAddPage = class AddressbookAddPage {
    constructor(navCtrl, navParams, events, alertCtrl, bwc, ab, formBuilder, logger) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.events = events;
        this.alertCtrl = alertCtrl;
        this.bwc = bwc;
        this.ab = ab;
        this.formBuilder = formBuilder;
        this.logger = logger;
        this.submitAttempt = false;
        this.addressBookAdd = this.formBuilder.group({
            name: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([
                    __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required,
                    __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].pattern('[a-zA-Z0-9 ]*')
                ])
            ],
            email: ['', this.emailOrEmpty],
            address: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([
                    __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required,
                    new __WEBPACK_IMPORTED_MODULE_6__validators_address__["a" /* AddressValidator */](this.bwc).isValid
                ])
            ]
        });
        if (this.navParams.data.addressbookEntry) {
            this.addressBookAdd.controls['address'].setValue(this.navParams.data.addressbookEntry);
        }
        this.events.subscribe('update:address', data => {
            let address = data.value.replace(/^bastoji(cash)?:/, '');
            this.addressBookAdd.controls['address'].setValue(address);
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AddressbookAddPage');
    }
    emailOrEmpty(control) {
        return control.value === '' ? null : __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].email(control);
    }
    save() {
        this.submitAttempt = true;
        if (this.addressBookAdd.valid) {
            this.ab
                .add(this.addressBookAdd.value)
                .then(() => {
                this.navCtrl.pop();
                this.submitAttempt = false;
            })
                .catch(err => {
                let opts = {
                    title: err,
                    buttons: [
                        {
                            text: 'OK',
                            handler: () => {
                                this.navCtrl.pop();
                            }
                        }
                    ]
                };
                this.alertCtrl.create(opts).present();
                this.submitAttempt = false;
            });
        }
        else {
            let opts = {
                title: 'Error',
                message: 'Could not save the contact',
                buttons: [
                    {
                        text: 'OK',
                        handler: () => {
                            this.navCtrl.pop();
                        }
                    }
                ]
            };
            this.alertCtrl.create(opts).present();
            this.submitAttempt = false;
        }
    }
    openScanner() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__scan_scan__["a" /* ScanPage */], { fromAddressbook: true });
    }
};
AddressbookAddPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-addressbook-add',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/add/add.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>{{ \'Add Contact\' | translate }}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n\n  <form [formGroup]="addressBookAdd">\n    <ion-item>\n      <ion-label stacked>{{ \'Name\' | translate }}</ion-label>\n      <ion-input formControlName="name" type="text"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{ \'Email\' | translate }}</ion-label>\n      <ion-input formControlName="email" type="email"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{\'Bastoji Address\' | translate }}</ion-label>\n      <ion-input formControlName="address" type="text" [value]="addressBookAdd.value.address" address-validator></ion-input>\n\n      <ion-icon *ngIf="addressBookAdd.controls.address.status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n      <ion-icon *ngIf="addressBookAdd.value.address && addressBookAdd.controls.address.status == \'INVALID\'" class="check fail"\n        name="ios-close-circle" item-right></ion-icon>\n\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n  </form>\n\n  <button ion-button class="button-standard" (click)="save()" [disabled]="addressBookAdd.invalid || submitAttempt">\n    {{\'Save\' | translate}}\n  </button>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/add/add.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */]])
], AddressbookAddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 21:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_text_encoding__ = __webpack_require__(216);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_text_encoding___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_text_encoding__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__filter_filter__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__language_language__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__rate_rate__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__tx_format_tx_format__ = __webpack_require__(47);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






// Providers












let WalletProvider = class WalletProvider {
    /* TODO: update on progress
    private updateOnProgress = {}
     */
    constructor(logger, bwcProvider, txFormatProvider, configProvider, persistenceProvider, bwcErrorProvider, rateProvider, filter, languageProvider, popupProvider, onGoingProcessProvider, touchidProvider, events, feeProvider, translate) {
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.txFormatProvider = txFormatProvider;
        this.configProvider = configProvider;
        this.persistenceProvider = persistenceProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.rateProvider = rateProvider;
        this.filter = filter;
        this.languageProvider = languageProvider;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.touchidProvider = touchidProvider;
        this.events = events;
        this.feeProvider = feeProvider;
        this.translate = translate;
        // Ratio low amount warning (fee/amount) in incoming TX
        this.LOW_AMOUNT_RATIO = 0.15;
        // Ratio of "many utxos" warning in total balance (fee/amount)
        this.TOTAL_LOW_WARNING_RATIO = 0.3;
        this.WALLET_STATUS_MAX_TRIES = 7;
        this.WALLET_STATUS_DELAY_BETWEEN_TRIES = 1.4 * 1000;
        this.SOFT_CONFIRMATION_LIMIT = 12;
        this.SAFE_CONFIRMATIONS = 6;
        this.errors = this.bwcProvider.getErrors();
        this.progressFn = {};
        this.logger.info('WalletService initialized.');
        this.isPopupOpen = false;
    }
    invalidateCache(wallet) {
        if (wallet.cachedStatus)
            wallet.cachedStatus.isValid = false;
        if (wallet.completeHistory)
            wallet.completeHistory.isValid = false;
        if (wallet.cachedActivity)
            wallet.cachedActivity.isValid = false;
        if (wallet.cachedTxps)
            wallet.cachedTxps.isValid = false;
    }
    getStatus(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            var walletId = wallet.id;
            let processPendingTxps = status => {
                let txps = status.pendingTxps;
                let now = Math.floor(Date.now() / 1000);
                /* To test multiple outputs...
                var txp = {
                  message: 'test multi-output',
                  fee: 1000,
                  createdOn: new Date() / 1000,
                  outputs: []
                };
                function addOutput(n) {
                  txp.outputs.push({
                    amount: 600,
                    toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
                    message: 'output #' + (Number(n) + 1)
                  });
                };
                lodash.times(150, addOutput);
                txps.push(txp);
                */
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](txps, tx => {
                    tx = this.txFormatProvider.processTx(wallet.coin, tx, this.useLegacyAddress());
                    // no future transactions...
                    if (tx.createdOn > now)
                        tx.createdOn = now;
                    tx.wallet = wallet;
                    if (!tx.wallet) {
                        this.logger.error('no wallet at txp?');
                        return;
                    }
                    let action = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](tx.actions, {
                        copayerId: tx.wallet.copayerId
                    });
                    if (!action && tx.status == 'pending') {
                        tx.pendingForUs = true;
                    }
                    if (action && action.type == 'accept') {
                        tx.statusForUs = 'accepted';
                    }
                    else if (action && action.type == 'reject') {
                        tx.statusForUs = 'rejected';
                    }
                    else {
                        tx.statusForUs = 'pending';
                    }
                    if (!tx.deleteLockTime)
                        tx.canBeRemoved = true;
                });
                wallet.pendingTxps = txps;
            };
            let get = () => {
                return new Promise((resolve, reject) => {
                    wallet.getStatus({
                        twoStep: true
                    }, (err, ret) => {
                        if (err) {
                            if (err instanceof this.errors.NOT_AUTHORIZED) {
                                return reject('WALLET_NOT_REGISTERED');
                            }
                            return reject(err);
                        }
                        return resolve(ret);
                    });
                });
            };
            let cacheBalance = (wallet, balance) => {
                if (!balance)
                    return;
                let configGet = this.configProvider.get();
                let config = configGet.wallet;
                let cache = wallet.cachedStatus;
                // Address with Balance
                cache.balanceByAddress = balance.byAddress;
                // Total wallet balance is same regardless of 'spend unconfirmed funds' setting.
                cache.totalBalanceSat = balance.totalAmount;
                // Spend unconfirmed funds
                if (config.spendUnconfirmed) {
                    cache.lockedBalanceSat = balance.lockedAmount;
                    cache.availableBalanceSat = balance.availableAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendMax;
                    cache.pendingAmount = 0;
                    cache.spendableAmount = balance.totalAmount - balance.lockedAmount;
                }
                else {
                    cache.lockedBalanceSat = balance.lockedConfirmedAmount;
                    cache.availableBalanceSat = balance.availableConfirmedAmount;
                    cache.totalBytesToSendMax = balance.totalBytesToSendConfirmedMax;
                    cache.pendingAmount =
                        balance.totalAmount - balance.totalConfirmedAmount;
                    cache.spendableAmount =
                        balance.totalConfirmedAmount - balance.lockedAmount;
                }
                // Selected unit
                cache.unitToSatoshi = config.settings.unitToSatoshi;
                cache.satToUnit = 1 / cache.unitToSatoshi;
                // STR
                cache.totalBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.totalBalanceSat);
                cache.lockedBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.lockedBalanceSat);
                cache.availableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.availableBalanceSat);
                cache.spendableBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.spendableAmount);
                cache.pendingBalanceStr = this.txFormatProvider.formatAmountStr(wallet.coin, cache.pendingAmount);
                cache.alternativeName = config.settings.alternativeName;
                cache.alternativeIsoCode = config.settings.alternativeIsoCode;
                // Check address
                this.isAddressUsed(wallet, balance.byAddress)
                    .then(used => {
                    if (used) {
                        this.logger.debug('Address used. Creating new');
                        // Force new address
                        this.getAddress(wallet, true)
                            .then(addr => {
                            this.logger.debug('New address: ', addr);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    }
                })
                    .catch(err => {
                    return reject(err);
                });
                this.rateProvider
                    .whenRatesAvailable(wallet.coin)
                    .then(() => {
                    let totalBalanceAlternative = this.rateProvider.toFiat(cache.totalBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    let pendingBalanceAlternative = this.rateProvider.toFiat(cache.pendingAmount, cache.alternativeIsoCode, wallet.coin);
                    let lockedBalanceAlternative = this.rateProvider.toFiat(cache.lockedBalanceSat, cache.alternativeIsoCode, wallet.coin);
                    let spendableBalanceAlternative = this.rateProvider.toFiat(cache.spendableAmount, cache.alternativeIsoCode, wallet.coin);
                    let alternativeConversionRate = this.rateProvider.toFiat(100000000, cache.alternativeIsoCode, wallet.coin);
                    cache.totalBalanceAlternative = this.filter.formatFiatAmount(totalBalanceAlternative);
                    cache.pendingBalanceAlternative = this.filter.formatFiatAmount(pendingBalanceAlternative);
                    cache.lockedBalanceAlternative = this.filter.formatFiatAmount(lockedBalanceAlternative);
                    cache.spendableBalanceAlternative = this.filter.formatFiatAmount(spendableBalanceAlternative);
                    cache.alternativeConversionRate = this.filter.formatFiatAmount(alternativeConversionRate);
                    cache.alternativeBalanceAvailable = true;
                    cache.isRateAvailable = true;
                })
                    .catch(err => {
                    this.logger.warn('Could not get rates: ', err);
                });
            };
            let isStatusCached = () => {
                return wallet.cachedStatus && wallet.cachedStatus.isValid;
            };
            let cacheStatus = (status) => {
                if (status.wallet && status.wallet.scanStatus == 'running')
                    return;
                wallet.cachedStatus = status || {};
                let cache = wallet.cachedStatus;
                cache.statusUpdatedOn = Date.now();
                cache.isValid = true;
                cache.email = status.preferences ? status.preferences.email : null;
                cacheBalance(wallet, status.balance);
            };
            let walletStatusHash = status => {
                return status ? status.balance.totalAmount : wallet.totalBalanceSat;
            };
            let _getStatus = (initStatusHash, tries) => {
                return new Promise((resolve, reject) => {
                    if (isStatusCached() && !opts.force) {
                        this.logger.debug('Wallet status cache hit:' + wallet.id);
                        cacheStatus(wallet.cachedStatus);
                        processPendingTxps(wallet.cachedStatus);
                        return resolve(wallet.cachedStatus);
                    }
                    tries = tries || 0;
                    this.logger.debug('Updating Status:', wallet.credentials.walletName, tries);
                    get()
                        .then(status => {
                        let currentStatusHash = walletStatusHash(status);
                        this.logger.debug('Status update. hash:' + currentStatusHash + ' Try:' + tries);
                        if (opts.untilItChanges &&
                            initStatusHash == currentStatusHash &&
                            tries < this.WALLET_STATUS_MAX_TRIES &&
                            walletId == wallet.credentials.walletId) {
                            return setTimeout(() => {
                                this.logger.debug('Retrying update... ' + walletId + ' Try:' + tries);
                                return _getStatus(initStatusHash, ++tries);
                            }, this.WALLET_STATUS_DELAY_BETWEEN_TRIES * tries);
                        }
                        processPendingTxps(status);
                        this.logger.debug('Got Wallet Status for:' + wallet.credentials.walletName);
                        cacheStatus(status);
                        wallet.scanning =
                            status.wallet && status.wallet.scanStatus == 'running';
                        return resolve(status);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                });
            };
            _getStatus(walletStatusHash(null), 0)
                .then(status => {
                resolve(status);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // Check address
    isAddressUsed(wallet, byAddress) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getLastAddress(wallet.id)
                .then(addr => {
                let used = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](byAddress, {
                    address: addr
                });
                return resolve(used);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    useLegacyAddress() {
        let config = this.configProvider.get();
        let walletSettings = config.wallet;
        return walletSettings.useLegacyAddress;
    }
    getAddressView(wallet, address) {
        if (wallet.coin != 'bch' || this.useLegacyAddress())
            return address;
        return this.txFormatProvider.toCashAddress(address);
    }
    getProtoAddress(wallet, address) {
        let proto = this.getProtocolHandler(wallet.coin, wallet.network);
        let protoAddr = proto + ':' + address;
        if (wallet.coin != 'bch' || this.useLegacyAddress()) {
            return protoAddr;
        }
        else {
            return protoAddr.toUpperCase();
        }
    }
    getAddress(wallet, forceNew) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getLastAddress(wallet.id)
                .then(addr => {
                if (!forceNew && addr)
                    return resolve(addr);
                if (!wallet.isComplete())
                    return reject(this.bwcErrorProvider.msg('WALLET_NOT_COMPLETE'));
                if (wallet.needsBackup) {
                    return reject(this.bwcErrorProvider.msg('WALLET_NEEDS_BACKUP'));
                }
                this.createAddress(wallet)
                    .then(_addr => {
                    this.persistenceProvider
                        .storeLastAddress(wallet.id, _addr)
                        .then(() => {
                        return resolve(_addr);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    createAddress(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Creating address for wallet:', wallet.id);
            wallet.createAddress({}, (err, addr) => {
                if (err) {
                    let prefix = this.translate.instant('Could not create address');
                    if (err instanceof this.errors.MAIN_ADDRESS_GAP_REACHED ||
                        (err.message && err.message == 'MAIN_ADDRESS_GAP_REACHED')) {
                        this.logger.warn(this.bwcErrorProvider.msg(err, 'Server Error'));
                        prefix = null;
                        if (!this.isPopupOpen) {
                            this.isPopupOpen = true;
                            this.popupProvider
                                .ionicAlert(null, this.bwcErrorProvider.msg('MAIN_ADDRESS_GAP_REACHED'))
                                .then(() => {
                                this.isPopupOpen = false;
                            });
                        }
                        wallet.getMainAddresses({
                            reverse: true,
                            limit: 1
                        }, (err, addr) => {
                            if (err)
                                return reject(err);
                            return resolve(addr[0].address);
                        });
                    }
                    else {
                        this.bwcErrorProvider.cb(err, prefix).then(msg => {
                            return reject(msg);
                        });
                    }
                }
                else
                    return resolve(addr.address);
            });
        });
    }
    getSavedTxs(walletId) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxHistory(walletId)
                .then(txs => {
                let localTxs = [];
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txs)) {
                    return resolve(localTxs);
                }
                localTxs = txs;
                return resolve(__WEBPACK_IMPORTED_MODULE_3_lodash__["compact"](localTxs));
            })
                .catch((err) => {
                return reject(err);
            });
        });
    }
    getTxsFromServer(wallet, skip, endingTxid, limit) {
        return new Promise((resolve, reject) => {
            let res = [];
            let result = {
                res,
                shouldContinue: res.length >= limit
            };
            wallet.getTxHistory({
                skip,
                limit
            }, (err, txsFromServer) => {
                if (err)
                    return reject(err);
                if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txsFromServer))
                    return resolve(result);
                res = __WEBPACK_IMPORTED_MODULE_3_lodash__["takeWhile"](txsFromServer, tx => {
                    return tx.txid != endingTxid;
                });
                result.res = res;
                result.shouldContinue = res.length >= limit;
                return resolve(result);
            });
        });
    }
    updateLocalTxHistory(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            let FIRST_LIMIT = 5;
            let LIMIT = 50;
            let requestLimit = FIRST_LIMIT;
            let walletId = wallet.credentials.walletId;
            this.progressFn[walletId] = opts.progressFn || (() => { });
            let foundLimitTx = [];
            let fixTxsUnit = (txs) => {
                if (!txs || !txs[0] || !txs[0].amountStr)
                    return;
                let cacheCoin = txs[0].amountStr.split(' ')[1];
                if (cacheCoin == 'bits') {
                    this.logger.debug('Fixing Tx Cache Unit to: ' + wallet.coin);
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](txs, tx => {
                        tx.amountStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.amount);
                        tx.feeStr = this.txFormatProvider.formatAmountStr(wallet.coin, tx.fees);
                    });
                }
            };
            /* TODO: update on progress
            if (updateOnProgress[wallet.id]) {
              $log.warn('History update already on progress for: '+ wallet.credentials.walletName);
      
              if (opts.progressFn) {
                $log.debug('Rewriting progressFn');
                progressFn[walletId] = opts.progressFn;
              }
              updateOnProgress[wallet.id].push(cb);
              return; // no callback call yet.
            }
      
            updateOnProgress[walletId] = [cb];
             */
            this.getSavedTxs(walletId)
                .then(txsFromLocal => {
                fixTxsUnit(txsFromLocal);
                let confirmedTxs = this.removeAndMarkSoftConfirmedTx(txsFromLocal);
                let endingTxid = confirmedTxs[0] ? confirmedTxs[0].txid : null;
                let endingTs = confirmedTxs[0] ? confirmedTxs[0].time : null;
                // First update
                this.progressFn[walletId](txsFromLocal, 0);
                wallet.completeHistory = txsFromLocal;
                let getNewTxs = (newTxs, skip) => {
                    return new Promise((resolve, reject) => {
                        this.getTxsFromServer(wallet, skip, endingTxid, requestLimit)
                            .then(result => {
                            let res = result.res;
                            let shouldContinue = result.shouldContinue
                                ? result.shouldContinue
                                : false;
                            newTxs = newTxs.concat(this.processNewTxs(wallet, __WEBPACK_IMPORTED_MODULE_3_lodash__["compact"](res)));
                            this.progressFn[walletId](newTxs.concat(txsFromLocal), newTxs.length);
                            skip = skip + requestLimit;
                            this.logger.debug('Syncing TXs. Got:' + newTxs.length + ' Skip:' + skip, ' EndingTxid:', endingTxid, ' Continue:', shouldContinue);
                            // TODO Dirty <HACK>
                            // do not sync all history, just looking for a single TX.
                            if (opts.limitTx) {
                                foundLimitTx = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](newTxs, {
                                    txid: opts.limitTx
                                });
                                if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](foundLimitTx)) {
                                    this.logger.debug('Found limitTX: ' + opts.limitTx);
                                    return resolve([foundLimitTx]);
                                }
                            }
                            // </HACK>
                            if (!shouldContinue) {
                                this.logger.debug('Finished Sync: New / soft confirmed Txs: ' +
                                    newTxs.length);
                                return resolve(newTxs);
                            }
                            requestLimit = LIMIT;
                            getNewTxs(newTxs, skip).then(txs => {
                                resolve(txs);
                            });
                        })
                            .catch(err => {
                            if (err instanceof this.errors.CONNECTION_ERROR ||
                                (err.message && err.message.match(/5../))) {
                                this.logger.info('Retrying history download in 5 secs...');
                                return reject(setTimeout(() => {
                                    return getNewTxs(newTxs, skip);
                                }, 5000));
                            }
                            return reject(err);
                        });
                    });
                };
                getNewTxs([], 0)
                    .then(txs => {
                    let array = __WEBPACK_IMPORTED_MODULE_3_lodash__["compact"](txs.concat(confirmedTxs));
                    let newHistory = __WEBPACK_IMPORTED_MODULE_3_lodash__["uniqBy"](array, x => {
                        return x.txid;
                    });
                    let updateNotes = () => {
                        return new Promise((resolve, reject) => {
                            if (!endingTs)
                                return resolve();
                            this.logger.debug('Syncing notes from: ' + endingTs);
                            wallet.getTxNotes({
                                minTs: endingTs
                            }, (err, notes) => {
                                if (err) {
                                    this.logger.warn('Could not get TxNotes: ', err);
                                    return reject(err);
                                }
                                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](notes, note => {
                                    this.logger.debug('Note for ' + note.txid);
                                    __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](newHistory, (tx) => {
                                        if (tx.txid == note.txid) {
                                            this.logger.debug('...updating note for ' + note.txid);
                                            tx.note = note;
                                        }
                                    });
                                });
                                return resolve();
                            });
                        });
                    };
                    let updateLowAmount = txs => {
                        if (!opts.lowAmount)
                            return;
                        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](txs, tx => {
                            tx.lowAmount = tx.amount < opts.lowAmount;
                        });
                    };
                    this.getLowAmount(wallet).then(fee => {
                        opts.lowAmount = fee;
                        updateLowAmount(txs);
                    });
                    updateNotes()
                        .then(() => {
                        // <HACK>
                        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](foundLimitTx)) {
                            this.logger.debug('Tx history read until limitTx: ' + opts.limitTx);
                            return resolve(newHistory);
                        }
                        // </HACK>
                        var historyToSave = JSON.stringify(newHistory);
                        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](txs, tx => {
                            tx.recent = true;
                        });
                        this.logger.debug('Tx History synced. Total Txs: ' + newHistory.length);
                        // Final update
                        if (walletId == wallet.credentials.walletId) {
                            wallet.completeHistory = newHistory;
                        }
                        return this.persistenceProvider
                            .setTxHistory(walletId, historyToSave)
                            .then(() => {
                            this.logger.debug('Tx History saved.');
                            return resolve();
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    /* TODO: update on progress
                lodash.each(this.updateOnProgress[walletId], function(x) {
                  x.apply(this,err);
                });
                this.updateOnProgress[walletId] = false;
                 */
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    processNewTxs(wallet, txs) {
        let now = Math.floor(Date.now() / 1000);
        let txHistoryUnique = {};
        let ret = [];
        wallet.hasUnsafeConfirmed = false;
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](txs, tx => {
            tx = this.txFormatProvider.processTx(wallet.coin, tx, this.useLegacyAddress());
            // no future transactions...
            if (tx.time > now)
                tx.time = now;
            if (tx.confirmations >= this.SAFE_CONFIRMATIONS) {
                tx.safeConfirmed = this.SAFE_CONFIRMATIONS + '+';
            }
            else {
                tx.safeConfirmed = false;
                wallet.hasUnsafeConfirmed = true;
            }
            if (tx.note) {
                delete tx.note.encryptedEditedByName;
                delete tx.note.encryptedBody;
            }
            if (!txHistoryUnique[tx.txid]) {
                ret.push(tx);
                txHistoryUnique[tx.txid] = true;
            }
            else {
                this.logger.debug('Ignoring duplicate TX in history: ' + tx.txid);
            }
        });
        return ret;
    }
    removeAndMarkSoftConfirmedTx(txs) {
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](txs, tx => {
            if (tx.confirmations >= this.SOFT_CONFIRMATION_LIMIT)
                return tx;
            tx.recent = true;
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getLowAmount(wallet) {
        return new Promise((resolve, reject) => {
            this.getMinFee(wallet)
                .then(fee => {
                let minFee = fee;
                return resolve(minFee / this.LOW_AMOUNT_RATIO);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // Approx utxo amount, from which the uxto is economically redeemable
    getMinFee(wallet, nbOutputs) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeLevels(wallet.coin)
                .then(data => {
                let normalLevelRate = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](data.levels[wallet.network], level => {
                    return level.level === 'normal';
                });
                let lowLevelRate = (normalLevelRate.feePerKb / 1000).toFixed(0);
                let size = this.getEstimatedTxSize(wallet, nbOutputs);
                return resolve(size * parseInt(lowLevelRate, 10));
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    // These 2 functions were taken from
    // https://github.com/bitpay/bitcore-wallet-service/blob/master/lib/model/txproposal.js#L243
    getEstimatedSizeForSingleInput(wallet) {
        switch (wallet.credentials.addressType) {
            case 'P2PKH':
                return 147;
            default:
            case 'P2SH':
                return wallet.m * 72 + wallet.n * 36 + 44;
        }
    }
    getEstimatedTxSize(wallet, nbOutputs) {
        // Note: found empirically based on all multisig P2SH inputs and within m & n allowed limits.
        nbOutputs = nbOutputs ? nbOutputs : 2; // Assume 2 outputs
        let safetyMargin = 0.02;
        let overhead = 4 + 4 + 9 + 9;
        let inputSize = this.getEstimatedSizeForSingleInput(wallet);
        let outputSize = 34;
        let nbInputs = 1; // Assume 1 input
        let size = overhead + inputSize * nbInputs + outputSize * nbOutputs;
        return parseInt((size * (1 + safetyMargin)).toFixed(0), 10);
    }
    getTxNote(wallet, txid) {
        return new Promise((resolve, reject) => {
            wallet.getTxNote({
                txid
            }, (err, note) => {
                if (err)
                    return reject(err);
                return resolve(note);
            });
        });
    }
    editTxNote(wallet, args) {
        return new Promise((resolve, reject) => {
            wallet.editTxNote(args, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getTxp(wallet, txpid) {
        return new Promise((resolve, reject) => {
            wallet.getTx(txpid, (err, txp) => {
                if (err)
                    return reject(err);
                return resolve(txp);
            });
        });
    }
    getTx(wallet, txid) {
        return new Promise((resolve, reject) => {
            let finish = list => {
                let tx = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](list, {
                    txid
                });
                if (!tx)
                    return reject('Could not get transaction');
                return tx;
            };
            if (wallet.completeHistory && wallet.completeHistory.isValid) {
                let tx = finish(wallet.completeHistory);
                return resolve(tx);
            }
            else {
                let opts = {
                    force: true
                };
                this.getTxHistory(wallet, opts)
                    .then(txHistory => {
                    let tx = finish(txHistory);
                    return resolve(tx);
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    getTxHistory(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts ? opts : {};
            if (!wallet.isComplete())
                return resolve();
            let isHistoryCached = () => {
                return wallet.completeHistory && wallet.completeHistory.isValid;
            };
            if (isHistoryCached() && !opts.force)
                return resolve(wallet.completeHistory);
            this.logger.debug('Updating Transaction History');
            this.updateLocalTxHistory(wallet, opts)
                .then(txs => {
                if (opts.limitTx) {
                    return resolve(txs);
                }
                wallet.completeHistory.isValid = true;
                return resolve(wallet.completeHistory);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    isEncrypted(wallet) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
            return undefined;
        let isEncrypted = wallet.isPrivKeyEncrypted();
        if (isEncrypted)
            this.logger.debug('Wallet is encrypted');
        return isEncrypted;
    }
    createTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.createTxProposal(txp, (err, createdTxp) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction created');
                    return resolve(createdTxp);
                }
            });
        });
    }
    publishTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.publishTxProposal({
                txp
            }, (err, publishedTx) => {
                if (err)
                    return reject(err);
                else {
                    this.logger.debug('Transaction published');
                    return resolve(publishedTx);
                }
            });
        });
    }
    signTx(wallet, txp, password) {
        return new Promise((resolve, reject) => {
            if (!wallet || !txp)
                return reject('MISSING_PARAMETER');
            try {
                wallet.signTxProposal(txp, password, (err, signedTxp) => {
                    if (err) {
                        this.logger.error('Transaction signed err: ', err);
                        return reject(err);
                    }
                    return resolve(signedTxp);
                });
            }
            catch (e) {
                this.logger.error('Error at signTxProposal:', e);
                return reject(e);
            }
        });
    }
    broadcastTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            if (txp.status != 'accepted')
                return reject('TX_NOT_ACCEPTED');
            wallet.broadcastTxProposal(txp, (err, broadcastedTxp, memo) => {
                if (err) {
                    if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isArrayBuffer"](err)) {
                        const enc = new __WEBPACK_IMPORTED_MODULE_4_text_encoding___default.a.TextDecoder();
                        err = enc.decode(err);
                        this.removeTx(wallet, txp);
                        return reject(err);
                    }
                    else {
                        return reject(err);
                    }
                }
                this.logger.debug('Transaction broadcasted');
                if (memo)
                    this.logger.info('Memo: ', memo);
                return resolve(broadcastedTxp);
            });
        });
    }
    rejectTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.rejectTxProposal(txp, null, (err, rejectedTxp) => {
                if (err)
                    return reject(err);
                this.logger.debug('Transaction rejected');
                return resolve(rejectedTxp);
            });
        });
    }
    removeTx(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](txp) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                return reject('MISSING_PARAMETER');
            wallet.removeTxProposal(txp, err => {
                this.logger.debug('Transaction removed');
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', wallet.id);
                return resolve(err);
            });
        });
    }
    updateRemotePreferences(clients, prefs) {
        return new Promise((resolve, reject) => {
            prefs = prefs ? prefs : {};
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isArray"](clients))
                clients = [clients];
            let updateRemotePreferencesFor = (clients, prefs) => {
                return new Promise((resolve, reject) => {
                    let wallet = clients.shift();
                    if (!wallet)
                        return resolve();
                    this.logger.debug('Saving remote preferences', wallet.credentials.walletName, prefs);
                    wallet.savePreferences(prefs, err => {
                        if (err) {
                            this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not save preferences on the server')));
                            return reject(err);
                        }
                        updateRemotePreferencesFor(clients, prefs)
                            .then(() => {
                            return resolve();
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                });
            };
            // Update this JIC.
            let config = this.configProvider.get();
            // Get email from local config
            prefs.email = config.emailNotifications.email;
            // Get current languge
            prefs.language = this.languageProvider.getCurrent();
            // Set OLD wallet in bits to btc
            prefs.unit = 'btc'; // DEPRECATED
            updateRemotePreferencesFor(__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](clients), prefs)
                .then(() => {
                this.logger.debug('Remote preferences saved for' +
                    __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](clients, (x) => {
                        return x.credentials.walletId;
                    })
                        .join(','));
                __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](clients, c => {
                    c.preferences = __WEBPACK_IMPORTED_MODULE_3_lodash__["assign"](prefs, c.preferences);
                });
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    recreate(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Recreating wallet:', wallet.id);
            wallet.recreateWallet(err => {
                wallet.notAuthorized = false;
                if (err)
                    return reject(err);
                return resolve();
            });
        });
    }
    startScan(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Scanning wallet ' + wallet.id);
            if (!wallet.isComplete())
                return reject();
            wallet.scanning = true;
            wallet.startScan({
                includeCopayerBranches: true
            }, err => {
                if (err)
                    return reject(err);
                return resolve();
            });
        });
    }
    clearTxHistory(wallet) {
        this.invalidateCache(wallet);
        this.persistenceProvider.removeTxHistory(wallet.id);
    }
    expireAddress(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Cleaning Address ' + wallet.id);
            this.persistenceProvider
                .clearLastAddress(wallet.id)
                .then(() => {
                return resolve();
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getMainAddresses(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.reverse = true;
            wallet.getMainAddresses(opts, (err, addresses) => {
                if (err)
                    return reject(err);
                return resolve(addresses);
            });
        });
    }
    getBalance(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getBalance(opts, (err, resp) => {
                if (err)
                    return reject(err);
                return resolve(resp);
            });
        });
    }
    getLowUtxos(wallet) {
        return new Promise((resolve, reject) => {
            wallet.getUtxos({
                coin: wallet.coin
            }, (err, resp) => {
                if (err || !resp || !resp.length)
                    return reject(err);
                this.getMinFee(wallet, resp.length).then(fee => {
                    let minFee = fee;
                    let balance = __WEBPACK_IMPORTED_MODULE_3_lodash__["sumBy"](resp, 'satoshis');
                    // for 2 outputs
                    this.getLowAmount(wallet).then(fee => {
                        let lowAmount = fee;
                        let lowUtxos = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](resp, x => {
                            return x.satoshis < lowAmount;
                        });
                        let totalLow = __WEBPACK_IMPORTED_MODULE_3_lodash__["sumBy"](lowUtxos, 'satoshis');
                        return resolve({
                            allUtxos: resp || [],
                            lowUtxos: lowUtxos || [],
                            totalLow,
                            warning: minFee / balance > this.TOTAL_LOW_WARNING_RATIO,
                            minFee
                        });
                    });
                });
            });
        });
    }
    // An alert dialog
    askPassword(warnMsg, title) {
        return new Promise(resolve => {
            let opts = {
                type: 'password',
                useDanger: true
            };
            this.popupProvider.ionicPrompt(title, warnMsg, opts).then(res => {
                return resolve(res);
            });
        });
    }
    encrypt(wallet) {
        return new Promise((resolve, reject) => {
            var title = this.translate.instant('Enter a new encrypt password');
            var warnMsg = this.translate.instant('Your wallet key will be encrypted. The encrypt password cannot be recovered. Be sure to write it down.');
            this.askPassword(warnMsg, title)
                .then((password) => {
                if (!password)
                    return reject(this.translate.instant('no password'));
                title = this.translate.instant('Confirm your new encrypt password');
                this.askPassword(warnMsg, title)
                    .then((password2) => {
                    if (!password2 || password != password2)
                        return reject(this.translate.instant('password mismatch'));
                    wallet.encryptPrivateKey(password);
                    return resolve();
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    decrypt(wallet) {
        return new Promise((resolve, reject) => {
            this.logger.debug('Disabling private key encryption for' + wallet.name);
            this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
                if (!password)
                    return reject(this.translate.instant('no password'));
                try {
                    wallet.decryptPrivateKey(password);
                }
                catch (e) {
                    return reject(e);
                }
                return resolve();
            });
        });
    }
    handleEncryptedWallet(wallet) {
        return new Promise((resolve, reject) => {
            if (!this.isEncrypted(wallet))
                return resolve();
            this.askPassword(null, this.translate.instant('Enter encrypt password')).then((password) => {
                if (!password)
                    return reject(this.translate.instant('No password'));
                if (!wallet.checkPassword(password))
                    return reject(this.translate.instant('Wrong password'));
                return resolve(password);
            });
        });
    }
    reject(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.rejectTx(wallet, txp)
                .then(txpr => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', wallet.id);
                return resolve(txpr);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    onlyPublish(wallet, txp) {
        return new Promise((resolve, reject) => {
            this.publishTx(wallet, txp)
                .then(() => {
                this.invalidateCache(wallet);
                this.events.publish('Local/TxAction', wallet.id);
                return resolve();
            })
                .catch(err => {
                return reject(this.bwcErrorProvider.msg(err));
            });
        });
    }
    prepare(wallet) {
        return new Promise((resolve, reject) => {
            this.touchidProvider
                .checkWallet(wallet)
                .then(() => {
                this.handleEncryptedWallet(wallet)
                    .then((password) => {
                    return resolve(password);
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    signAndBroadcast(wallet, publishedTxp, password) {
        return new Promise((resolve, reject) => {
            this.onGoingProcessProvider.set('signingTx');
            this.signTx(wallet, publishedTxp, password)
                .then(signedTxp => {
                this.invalidateCache(wallet);
                if (signedTxp.status == 'accepted') {
                    this.onGoingProcessProvider.set('broadcastingTx');
                    this.broadcastTx(wallet, signedTxp)
                        .then(broadcastedTxp => {
                        this.events.publish('Local/TxAction', wallet.id);
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(this.bwcErrorProvider.msg(err));
                    });
                }
                else {
                    this.events.publish('Local/TxAction', wallet.id);
                    return resolve(signedTxp);
                }
            })
                .catch(err => {
                let msg = err && err.message
                    ? err.message
                    : this.translate.instant('The payment was created but could not be completed. Please try again from home screen');
                this.logger.debug('Sign error: ' + msg);
                this.events.publish('Local/TxAction', wallet.id);
                return reject(msg);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            // Already published?
            if (txp.status == 'pending') {
                this.prepare(wallet)
                    .then((password) => {
                    this.signAndBroadcast(wallet, txp, password)
                        .then(broadcastedTxp => {
                        return resolve(broadcastedTxp);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
            else {
                this.prepare(wallet)
                    .then((password) => {
                    this.onGoingProcessProvider.set('sendingTx');
                    this.publishTx(wallet, txp)
                        .then(publishedTxp => {
                        this.signAndBroadcast(wallet, publishedTxp, password)
                            .then(broadcastedTxp => {
                            return resolve(broadcastedTxp);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            }
        });
    }
    getEncodedWalletInfo(wallet, password) {
        return new Promise((resolve, reject) => {
            let derivationPath = wallet.credentials.getBaseAddressDerivationPath();
            let encodingType = {
                mnemonic: 1,
                xpriv: 2,
                xpub: 3
            };
            let info = {};
            // not supported yet
            if (wallet.credentials.derivationStrategy != 'BIP44' || !wallet.canSign())
                return reject(this.translate.instant('Exporting via QR not supported for this wallet'));
            var keys = this.getKeysWithPassword(wallet, password);
            if (keys.mnemonic) {
                info = {
                    type: encodingType.mnemonic,
                    data: keys.mnemonic
                };
            }
            else {
                info = {
                    type: encodingType.xpriv,
                    data: keys.xPrivKey
                };
            }
            return resolve(info.type +
                '|' +
                info.data +
                '|' +
                wallet.credentials.network.toLowerCase() +
                '|' +
                derivationPath +
                '|' +
                wallet.credentials.mnemonicHasPassphrase +
                '|' +
                wallet.coin);
        });
    }
    getKeysWithPassword(wallet, password) {
        try {
            return wallet.getKeys(password);
        }
        catch (e) {
            this.logger.debug(e);
        }
    }
    setTouchId(wallet, enabled) {
        return new Promise((resolve, reject) => {
            let opts = {
                touchIdFor: {}
            };
            opts.touchIdFor[wallet.id] = enabled;
            this.touchidProvider
                .checkWallet(wallet)
                .then(() => {
                this.configProvider.set(opts);
                return resolve();
            })
                .catch(err => {
                opts.touchIdFor[wallet.id] = !enabled;
                this.logger.debug('Error with fingerprint:' + err);
                this.configProvider.set(opts);
                return reject(err);
            });
        });
    }
    getKeys(wallet) {
        return new Promise((resolve, reject) => {
            this.prepare(wallet)
                .then((password) => {
                let keys;
                try {
                    keys = wallet.getKeys(password);
                }
                catch (e) {
                    return reject(e);
                }
                return resolve(keys);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getSendMaxInfo(wallet, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            wallet.getSendMaxInfo(opts, (err, res) => {
                if (err)
                    return reject(err);
                return resolve(res);
            });
        });
    }
    getProtocolHandler(coin, network) {
        if (coin == 'bch') {
            return network == 'testnet' ? 'bchtest' : 'bastojicash';
        }
        else {
            return 'bastoji';
        }
    }
    copyCopayers(wallet, newWallet) {
        return new Promise((resolve, reject) => {
            let walletPrivKey = this.bwcProvider
                .getBitcore()
                .PrivateKey.fromString(wallet.credentials.walletPrivKey);
            let copayer = 1;
            let i = 0;
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](wallet.credentials.publicKeyRing, item => {
                let name = item.copayerName || 'copayer ' + copayer++;
                newWallet._doJoinWallet(newWallet.credentials.walletId, walletPrivKey, item.xPubKey, item.requestPubKey, name, {
                    coin: newWallet.credentials.coin
                }, err => {
                    // Ignore error is copayer already in wallet
                    if (err && !(err instanceof this.errors.COPAYER_IN_WALLET))
                        return reject(err);
                    if (++i == wallet.credentials.publicKeyRing.length)
                        return resolve();
                });
            });
        });
    }
};
WalletProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_17__tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_8__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_13__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_6__bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_15__rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_10__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_11__language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_14__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_12__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_16__touchid_touchid__["b" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_9__fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], WalletProvider);

//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ 218:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppIdentityProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitauth__ = __webpack_require__(643);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_bitauth___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_bitauth__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers



let AppIdentityProvider = class AppIdentityProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.info('AppIdentityProvider initialized.');
    }
    getIdentity(network, cb) {
        let pubkey;
        let isNew;
        this.persistenceProvider.getAppIdentity(network).then(data => {
            let appIdentity = data || {};
            if (__WEBPACK_IMPORTED_MODULE_4_lodash__["isEmpty"](appIdentity) || (appIdentity && !appIdentity.priv)) {
                isNew = true;
                appIdentity = __WEBPACK_IMPORTED_MODULE_3_bitauth__["generateSin"]();
            }
            try {
                pubkey = __WEBPACK_IMPORTED_MODULE_3_bitauth__["getPublicKeyFromPrivateKey"](appIdentity.priv);
                __WEBPACK_IMPORTED_MODULE_3_bitauth__["getSinFromPublicKey"](pubkey);
                if (isNew)
                    this.persistenceProvider.setAppIdentity(network, appIdentity);
            }
            catch (e) {
                return cb(e);
            }
            return cb(null, appIdentity);
        });
    }
};
AppIdentityProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__["a" /* PersistenceProvider */]])
], AppIdentityProvider);

//# sourceMappingURL=app-identity.js.map

/***/ }),

/***/ 22:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ExternalLinkProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_webkit_node_webkit__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers



let ExternalLinkProvider = class ExternalLinkProvider {
    constructor(popupProvider, logger, platformProvider, nodeWebkitProvider) {
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.nodeWebkitProvider = nodeWebkitProvider;
        this.logger.info('ExternalLinkProvider initialized.');
    }
    restoreHandleOpenURL(old) {
        setTimeout(() => {
            window.handleOpenURL = old;
        }, 500);
    }
    open(url, optIn, title, message, okText, cancelText) {
        return new Promise(resolve => {
            if (optIn) {
                this.popupProvider
                    .ionicConfirm(title, message, okText, cancelText)
                    .then((res) => {
                    this.openBrowser(res, url);
                    resolve();
                });
            }
            else {
                this.openBrowser(true, url);
                resolve();
            }
        });
    }
    openBrowser(res, url) {
        let old = window.handleOpenURL;
        window.handleOpenURL = url => {
            // Ignore external URLs
            this.logger.debug('Skip: ' + url);
        };
        if (res)
            this.platformProvider.isNW
                ? this.nodeWebkitProvider.openExternalLink(url)
                : window.open(url, '_system');
        this.restoreHandleOpenURL(old);
    }
};
ExternalLinkProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__node_webkit_node_webkit__["a" /* NodeWebkitProvider */]])
], ExternalLinkProvider);

//# sourceMappingURL=external-link.js.map

/***/ }),

/***/ 237:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FilterProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let FilterProvider = class FilterProvider {
    constructor(decimalPipe, logger) {
        this.decimalPipe = decimalPipe;
        this.logger = logger;
        this.logger.info('FilterProvider initialized');
        this.formats = {
            CURRENCY_SYM: '$',
            DECIMAL_SEP: '.',
            GROUP_SEP: ','
        };
    }
    formatFiatAmount(amount) {
        let value;
        let sep;
        let group;
        let intValue;
        let floatValue;
        let finalValue;
        value = this.decimalPipe.transform(amount);
        if (!value)
            return 0;
        sep = value.indexOf(this.formats.DECIMAL_SEP);
        group = value.indexOf(this.formats.GROUP_SEP);
        if (amount >= 0) {
            if (group > 0) {
                if (sep < 0) {
                    return value;
                }
                intValue = value.substring(0, sep);
                floatValue = parseFloat(value.substring(sep));
                floatValue = floatValue.toFixed(2);
                floatValue = floatValue.toString().substring(1);
                finalValue = intValue + floatValue;
                return finalValue;
            }
            else {
                value = parseFloat(value);
                return value.toFixed(2);
            }
        }
        return 0;
    }
};
FilterProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common__["d" /* DecimalPipe */], __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], FilterProvider);

//# sourceMappingURL=filter.js.map

/***/ }),

/***/ 238:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IncomingDataProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__paypro_paypro__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




let IncomingDataProvider = class IncomingDataProvider {
    constructor(events, bwcProvider, payproProvider, popupProvider, logger, appProvider, translate) {
        this.events = events;
        this.bwcProvider = bwcProvider;
        this.payproProvider = payproProvider;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.appProvider = appProvider;
        this.translate = translate;
        this.logger.info('IncomingDataProvider initialized.');
    }
    showMenu(data) {
        this.events.publish('showIncomingDataMenuEvent', data);
    }
    redir(data, activePage) {
        // data extensions for Payment Protocol with non-backwards-compatible request
        if (/^bastoji(cash)?:\?r=[\w+]/.exec(data)) {
            this.logger.debug('Handling Payment Protocol with non-backwards-compatible request');
            let coin = data.indexOf('bastojicash') === 0 ? 'bch' : 'btc';
            data = decodeURIComponent(data.replace(/bastoji(cash)?:\?r=/, ''));
            this.payproProvider
                .getPayProDetails(data, coin)
                .then(details => {
                this.handlePayPro(details, coin);
            })
                .catch(err => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
            });
            return true;
        }
        data = this.sanitizeUri(data);
        let amount;
        let message;
        let addr;
        let parsed;
        let coin;
        // Bastoji  URL
        if (this.bwcProvider.getBitcore().URI.isValid(data)) {
            this.logger.debug('Handling Bastoji URI');
            coin = 'btc';
            parsed = this.bwcProvider.getBitcore().URI(data);
            addr = parsed.address ? parsed.address.toString() : '';
            message = parsed.message;
            amount = parsed.amount ? parsed.amount : '';
            if (parsed.r) {
                this.payproProvider
                    .getPayProDetails(parsed.r, coin)
                    .then(details => {
                    this.handlePayPro(details, coin);
                })
                    .catch((err) => {
                    if (addr && amount)
                        this.goSend(addr, amount, message, coin);
                    else
                        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                });
            }
            else {
                this.goSend(addr, amount, message, coin);
            }
            return true;
            // Cash URI
        }
        else if (this.bwcProvider.getBitcoreCash().URI.isValid(data)) {
            this.logger.debug('Handling Bastoji Cash URI');
            coin = 'bch';
            parsed = this.bwcProvider.getBitcoreCash().URI(data);
            addr = parsed.address ? parsed.address.toString() : '';
            // keep address in original format
            if (parsed.address && data.indexOf(addr) < 0) {
                addr = parsed.address.toCashAddress();
            }
            message = parsed.message;
            amount = parsed.amount ? parsed.amount : '';
            if (parsed.r) {
                this.payproProvider
                    .getPayProDetails(parsed.r, coin)
                    .then(details => {
                    this.handlePayPro(details, coin);
                })
                    .catch((err) => {
                    if (addr && amount)
                        this.goSend(addr, amount, message, coin);
                    else
                        this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                });
            }
            else {
                this.goSend(addr, amount, message, coin);
            }
            return true;
            // Cash URI with bastoji core address version number?
        }
        else if (this.bwcProvider
            .getBitcore()
            .URI.isValid(data.replace(/^bastojicash:/, 'bastoji:'))) {
            this.logger.debug('Handling Bastoji Cash URI with legacy address');
            coin = 'bch';
            parsed = this.bwcProvider
                .getBitcore()
                .URI(data.replace(/^bastojicash:/, 'bastoji:'));
            let oldAddr = parsed.address ? parsed.address.toString() : '';
            if (!oldAddr)
                return false;
            addr = '';
            let a = this.bwcProvider
                .getBitcore()
                .Address(oldAddr)
                .toObject();
            addr = this.bwcProvider
                .getBitcoreCash()
                .Address.fromObject(a)
                .toString();
            // Translate address
            this.logger.debug('address transalated to:' + addr);
            let title = this.translate.instant('Bastoji cash Payment');
            let msg = this.translate.instant('Payment address was translated to new Bastoji Cash address format: {{addr}}', { addr });
            this.popupProvider.ionicConfirm(title, msg).then((res) => {
                if (!res)
                    return false;
                message = parsed.message;
                amount = parsed.amount ? parsed.amount : '';
                if (parsed.r) {
                    this.payproProvider
                        .getPayProDetails(parsed.r, coin)
                        .then(details => {
                        this.handlePayPro(details, coin);
                    })
                        .catch(err => {
                        if (addr && amount)
                            this.goSend(addr, amount, message, coin);
                        else
                            this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    });
                }
                else {
                    this.goSend(addr, amount, message, coin);
                }
                return undefined;
            });
            return true;
        }
        else if (/^https?:\/\//.test(data)) {
            // Plain URL
            this.logger.debug('Handling Plain URL');
            let coin = 'btc'; // Assume BTJ
            this.payproProvider
                .getPayProDetails(data, coin, true)
                .then(details => {
                this.handlePayPro(details, coin);
            })
                .catch(() => {
                this.showMenu({
                    data,
                    type: 'url'
                });
            });
            return true;
            // Plain Address
        }
        else if (this.bwcProvider.getBitcore().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcore().Address.isValid(data, 'testnet')) {
            this.logger.debug('Handling Bastoji Plain Address');
            if (activePage === 'ScanPage') {
                this.showMenu({
                    data,
                    type: 'bastojiAddress',
                    coin: 'btc'
                });
            }
            else {
                let coin = 'btc';
                this.goToAmountPage(data, coin);
            }
            return true;
        }
        else if (this.bwcProvider.getBitcoreCash().Address.isValid(data, 'livenet') ||
            this.bwcProvider.getBitcoreCash().Address.isValid(data, 'testnet')) {
            this.logger.debug('Handling Bastoji Cash Plain Address');
            if (activePage === 'ScanPage') {
                this.showMenu({
                    data,
                    type: 'bastojiAddress',
                    coin: 'bch'
                });
            }
            else {
                let coin = 'bch';
                this.goToAmountPage(data, coin);
            }
            return true;
        }
        else if (data &&
            data.indexOf(this.appProvider.info.name + '://glidera') === 0) {
            this.logger.debug('Handling Glidera URL');
            let code = this.getParameterByName('code', data);
            let stateParams = { code };
            let nextView = {
                name: 'GlideraPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
            return true;
        }
        else if (data &&
            data.indexOf(this.appProvider.info.name + '://coinbase') === 0) {
            this.logger.debug('Handling Coinbase URL');
            let code = this.getParameterByName('code', data);
            let stateParams = { code };
            let nextView = {
                name: 'CoinbasePage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
            return true;
            // BitPayCard Authentication
        }
        else if (data && data.indexOf(this.appProvider.info.name + '://') === 0) {
            this.logger.debug('Handling BitPayCard URL');
            // Disable BitPay Card
            if (!this.appProvider.info._enabledExtensions.debitcard)
                return false;
            let secret = this.getParameterByName('secret', data);
            let email = this.getParameterByName('email', data);
            let otp = this.getParameterByName('otp', data);
            let reason = this.getParameterByName('r', data);
            switch (reason) {
                default:
                case '0':
                    /* For BitPay card binding */
                    let stateParams = { secret, email, otp };
                    let nextView = {
                        name: 'BitPayCardIntroPage',
                        params: stateParams
                    };
                    this.events.publish('IncomingDataRedir', nextView);
                    break;
            }
            return true;
            // Join
        }
        else if (data && data.match(/^copay:[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
            this.logger.debug('Handling Join Wallet');
            let stateParams = { url: data, fromScan: true };
            let nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
            return true;
            // Old join
        }
        else if (data && data.match(/^[0-9A-HJ-NP-Za-km-z]{70,80}$/)) {
            this.logger.debug('Handling Old Join Wallet');
            let stateParams = { url: data, fromScan: true };
            let nextView = {
                name: 'JoinWalletPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
            return true;
        }
        else if (data &&
            (data.substring(0, 2) == '6P' || this.checkPrivateKey(data))) {
            this.logger.debug('Handling private key');
            this.showMenu({
                data,
                type: 'privateKey'
            });
            return true;
        }
        else if (data &&
            (data.substring(0, 2) == '1|' ||
                data.substring(0, 2) == '2|' ||
                data.substring(0, 2) == '3|')) {
            this.logger.debug('Handling QR Code Export feature');
            let stateParams = { code: data, fromScan: true };
            let nextView = {
                name: 'ImportWalletPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
            return true;
        }
        else {
            if (activePage === 'ScanPage') {
                this.logger.debug('Handling plain text');
                this.showMenu({
                    data,
                    type: 'text'
                });
                return true;
            }
        }
        return false;
    }
    sanitizeUri(data) {
        // Fixes when a region uses comma to separate decimals
        let regex = /[\?\&]amount=(\d+([\,\.]\d+)?)/i;
        let match = regex.exec(data);
        if (!match || match.length === 0) {
            return data;
        }
        let value = match[0].replace(',', '.');
        let newUri = data.replace(regex, value);
        // mobile devices, uris like copay://glidera
        newUri.replace('://', ':');
        return newUri;
    }
    getParameterByName(name, url) {
        if (!url)
            return undefined;
        name = name.replace(/[\[\]]/g, '\\$&');
        let regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'), results = regex.exec(url);
        if (!results)
            return null;
        if (!results[2])
            return '';
        return decodeURIComponent(results[2].replace(/\+/g, ' '));
    }
    checkPrivateKey(privateKey) {
        try {
            this.bwcProvider.getBitcore().PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    goSend(addr, amount, message, coin) {
        if (amount) {
            let stateParams = {
                amount,
                toAddress: addr,
                description: message,
                coin
            };
            let nextView = {
                name: 'ConfirmPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
        }
        else {
            let stateParams = {
                toAddress: addr,
                description: message,
                coin
            };
            let nextView = {
                name: 'AmountPage',
                params: stateParams
            };
            this.events.publish('IncomingDataRedir', nextView);
        }
    }
    goToAmountPage(toAddress, coin) {
        let stateParams = {
            toAddress,
            coin
        };
        let nextView = {
            name: 'AmountPage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
    handlePayPro(payProDetails, coin) {
        if (!payProDetails) {
            this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('No wallets available'));
            return;
        }
        const stateParams = {
            amount: payProDetails.amount,
            toAddress: payProDetails.toAddress,
            description: payProDetails.memo,
            paypro: payProDetails,
            coin,
            requiredFeeRate: payProDetails.requiredFeeRate
                ? Math.ceil(payProDetails.requiredFeeRate * 1024)
                : undefined
        };
        const nextView = {
            name: 'ConfirmPage',
            params: stateParams
        };
        this.events.publish('IncomingDataRedir', nextView);
    }
};
IncomingDataProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_6__paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_7__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], IncomingDataProvider);

//# sourceMappingURL=incoming-data.js.map

/***/ }),

/***/ 239:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NodeWebkitProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let NodeWebkitProvider = class NodeWebkitProvider {
    constructor(logger) {
        this.logger = logger;
        this.logger.info('NodeWebkitProvider initialized.');
    }
    readFromClipboard() {
        let gui = window.require('nw.gui');
        let clipboard = gui.Clipboard.get();
        return clipboard.get();
    }
    writeToClipboard(text) {
        let gui = window.require('nw.gui');
        let clipboard = gui.Clipboard.get();
        return clipboard.set(text);
    }
    openExternalLink(url) {
        let gui = window.require('nw.gui');
        return gui.Shell.openExternal(url);
    }
};
NodeWebkitProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */]])
], NodeWebkitProvider);

//# sourceMappingURL=node-webkit.js.map

/***/ }),

/***/ 240:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DerivationPathHelperProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let DerivationPathHelperProvider = class DerivationPathHelperProvider {
    constructor() {
        this.default = "m/44'/0'/0'";
        this.defaultTestnet = "m/44'/1'/0'";
    }
    parse(str) {
        var arr = str.split('/');
        var ret = {
            derivationStrategy: '',
            networkName: '',
            account: 0
        };
        if (arr[0] != 'm')
            return false;
        switch (arr[1]) {
            case "44'":
                ret.derivationStrategy = 'BIP44';
                break;
            case "45'":
                return {
                    derivationStrategy: 'BIP45',
                    networkName: 'livenet',
                    account: 0
                };
            case "48'":
                ret.derivationStrategy = 'BIP48';
                break;
            default:
                return false;
        }
        switch (arr[2]) {
            case "0'":
                ret.networkName = 'livenet';
                break;
            case "1'":
                ret.networkName = 'testnet';
                break;
            default:
                return false;
        }
        var match = arr[3].match(/(\d+)'/);
        if (!match)
            return false;
        ret.account = +match[1];
        return ret;
    }
};
DerivationPathHelperProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [])
], DerivationPathHelperProvider);

//# sourceMappingURL=derivation-path-helper.js.map

/***/ }),

/***/ 241:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ImportWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__tabs_tabs__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Pages


// Providers









let ImportWalletPage = class ImportWalletPage {
    constructor(app, navCtrl, navParams, form, bwcProvider, derivationPathHelperProvider, walletProvider, configProvider, popupProvider, platformProvider, logger, onGoingProcessProvider, profileProvider, translate, events, pushNotificationsProvider) {
        this.app = app;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.form = form;
        this.bwcProvider = bwcProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.walletProvider = walletProvider;
        this.configProvider = configProvider;
        this.popupProvider = popupProvider;
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.reader = new FileReader();
        this.defaults = this.configProvider.getDefaults();
        this.errors = bwcProvider.getErrors();
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
        this.importErr = false;
        this.fromOnboarding = this.navParams.data.fromOnboarding;
        this.code = this.navParams.data.code;
        this.selectedTab = 'words';
        this.derivationPathByDefault = this.derivationPathHelperProvider.default;
        this.derivationPathForTestnet = this.derivationPathHelperProvider.defaultTestnet;
        this.showAdvOpts = false;
        this.formFile = null;
        this.importForm = this.form.group({
            words: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            backupText: [null],
            passphrase: [null],
            file: [null],
            filePassword: [null],
            derivationPath: [this.derivationPathByDefault, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            testnetEnabled: [false],
            bwsURL: [this.defaults.bws.url],
            coin: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]
        });
    }
    ionViewWillEnter() {
        if (this.code) {
            this.processWalletInfo(this.code);
        }
    }
    selectTab(tab) {
        this.selectedTab = tab;
        switch (tab) {
            case 'words':
                this.file = null;
                this.formFile = null;
                this.importForm.get('words').setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
                this.importForm.get('coin').setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
                this.importForm.get('filePassword').clearValidators();
                if (this.isCordova || this.isSafari)
                    this.importForm.get('backupText').clearValidators();
                else
                    this.importForm.get('file').clearValidators();
                break;
            case 'file':
                if (this.isCordova || this.isSafari)
                    this.importForm
                        .get('backupText')
                        .setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
                else
                    this.importForm.get('file').setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
                this.importForm
                    .get('filePassword')
                    .setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
                this.importForm.get('words').clearValidators();
                this.importForm.get('coin').clearValidators();
                break;
            default:
                this.importForm.get('words').clearValidators();
                this.importForm.get('file').clearValidators();
                this.importForm.get('filePassword').clearValidators();
                break;
        }
        this.importForm.get('words').updateValueAndValidity();
        this.importForm.get('file').updateValueAndValidity();
        this.importForm.get('filePassword').updateValueAndValidity();
        this.importForm.get('backupText').updateValueAndValidity();
        this.importForm.get('coin').updateValueAndValidity();
    }
    normalizeMnemonic(words) {
        if (!words || !words.indexOf)
            return words;
        var isJA = words.indexOf('\u3000') > -1;
        var wordList = words.split(/[\u3000\s]+/);
        return wordList.join(isJA ? '\u3000' : ' ');
    }
    processWalletInfo(code) {
        if (!code)
            return;
        this.importErr = false;
        let parsedCode = code.split('|');
        let info = {
            type: parsedCode[0],
            data: parsedCode[1],
            network: parsedCode[2],
            derivationPath: parsedCode[3],
            hasPassphrase: parsedCode[4] == 'true' ? true : false,
            coin: parsedCode[5]
        };
        if (info.type == '1' && info.hasPassphrase) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Password required. Make sure to enter your password in advanced options');
            this.popupProvider.ionicAlert(title, subtitle);
        }
        let isTestnet = info.network == 'testnet' ? true : false;
        this.importForm.controls['testnetEnabled'].setValue(isTestnet);
        this.importForm.controls['derivationPath'].setValue(info.derivationPath);
        this.importForm.controls['words'].setValue(info.data);
        this.importForm.controls['coin'].setValue(info.coin);
    }
    setDerivationPath() {
        let path = this.importForm.value.testnetEnabled
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.importForm.controls['derivationPath'].setValue(path);
    }
    importBlob(str, opts) {
        let str2;
        let err = null;
        try {
            str2 = this.bwcProvider
                .getSJCL()
                .decrypt(this.importForm.value.filePassword, str);
        }
        catch (e) {
            err = this.translate.instant('Could not decrypt file, check your password');
            this.logger.error('Import: could not decrypt file', e);
        }
        if (err) {
            let title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        }
        this.onGoingProcessProvider.set('importingWallet');
        opts.compressed = null;
        opts.password = null;
        setTimeout(() => {
            this.profileProvider
                .importWallet(str2, opts)
                .then(wallet => {
                this.onGoingProcessProvider.clear();
                this.finish(wallet);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                let title = this.translate.instant('Error');
                this.popupProvider.ionicAlert(title, err);
                return;
            });
        }, 100);
    }
    finish(wallet) {
        this.walletProvider
            .updateRemotePreferences(wallet)
            .then(() => {
            this.profileProvider.setBackupFlag(wallet.credentials.walletId);
            this.events.publish('status:updated');
            this.pushNotificationsProvider.updateSubscription(wallet);
            if (this.fromOnboarding) {
                this.profileProvider.setOnboardingCompleted();
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */]);
            }
            else {
                this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_6__tabs_tabs__["a" /* TabsPage */]);
            }
        })
            .catch(err => {
            this.logger.error('Import: could not updateRemotePreferences', err);
        });
    }
    importExtendedPrivateKey(xPrivKey, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        setTimeout(() => {
            this.profileProvider
                .importExtendedPrivateKey(xPrivKey, opts)
                .then(wallet => {
                this.onGoingProcessProvider.clear();
                this.finish(wallet);
            })
                .catch(err => {
                if (err instanceof this.errors.NOT_AUTHORIZED) {
                    this.importErr = true;
                }
                else {
                    let title = this.translate.instant('Error');
                    this.popupProvider.ionicAlert(title, err);
                }
                this.onGoingProcessProvider.clear();
                return;
            });
        }, 100);
    }
    importMnemonic(words, opts) {
        this.onGoingProcessProvider.set('importingWallet');
        setTimeout(() => {
            this.profileProvider
                .importMnemonic(words, opts)
                .then(wallet => {
                this.onGoingProcessProvider.clear();
                this.finish(wallet);
            })
                .catch(err => {
                if (err instanceof this.errors.NOT_AUTHORIZED) {
                    this.importErr = true;
                }
                else {
                    let title = this.translate.instant('Error');
                    this.popupProvider.ionicAlert(title, err);
                }
                this.onGoingProcessProvider.clear();
                return;
            });
        }, 100);
    }
    import() {
        if (this.selectedTab === 'file') {
            this.importFromFile();
        }
        else {
            this.importFromMnemonic();
        }
    }
    importFromFile() {
        if (!this.importForm.valid) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        let backupFile = this.file;
        let backupText = this.importForm.value.backupText;
        if (!backupFile && !backupText) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Please, select your backup file');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        if (backupFile) {
            this.reader.readAsBinaryString(backupFile);
        }
        else {
            let opts = {};
            opts.bwsurl = this.importForm.value.bwsURL;
            opts.coin = this.importForm.value.coin;
            this.importBlob(backupText, opts);
        }
    }
    importFromMnemonic() {
        if (!this.importForm.valid) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('There is an error in the form');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        let opts = {};
        if (this.importForm.value.bwsURL)
            opts.bwsurl = this.importForm.value.bwsURL;
        let pathData = this.derivationPathHelperProvider.parse(this.importForm.value.derivationPath);
        if (!pathData) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Invalid derivation path');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        opts.account = pathData.account;
        opts.networkName = pathData.networkName;
        opts.derivationStrategy = pathData.derivationStrategy;
        opts.coin = this.importForm.value.coin;
        let words = this.importForm.value.words || null;
        if (!words) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Please enter the recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        else if (words.indexOf('xprv') == 0 || words.indexOf('tprv') == 0) {
            return this.importExtendedPrivateKey(words, opts);
        }
        else {
            let wordList = words.split(/[\u3000\s]+/);
            if (wordList.length % 3 != 0) {
                let title = this.translate.instant('Error');
                let subtitle = this.translate.instant('Wrong number of recovery words:');
                this.popupProvider.ionicAlert(title, subtitle + ' ' + wordList.length);
                return;
            }
        }
        opts.passphrase = this.importForm.value.passphrase || null;
        this.importMnemonic(words, opts);
    }
    toggleShowAdvOpts() {
        this.showAdvOpts = !this.showAdvOpts;
    }
    fileChangeEvent($event) {
        this.file = $event.target
            ? $event.target.files[0]
            : $event.srcElement.files[0];
        this.formFile = $event.target.value;
        // Most browsers return `C:\fakepath\FILENAME`
        this.prettyFileName = this.formFile.split('\\').pop();
        this.getFile();
    }
    getFile() {
        // If we use onloadend, we need to check the readyState.
        this.reader.onloadend = () => {
            if (this.reader.readyState === 2) {
                // DONE === 2
                let opts = {};
                opts.bwsurl = this.importForm.value.bwsURL;
                opts.coin = this.importForm.value.coin;
                this.importBlob(this.reader.result, opts);
            }
        };
    }
    openScanner() {
        if (this.navParams.data.fromScan) {
            this.navCtrl.popToRoot({ animate: false });
        }
        else {
            this.navCtrl.popToRoot({ animate: false }).then(() => {
                this.navCtrl.parent.select(2);
            });
        }
    }
};
ImportWalletPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-import-wallet',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/add/import-wallet/import-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Import wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div [attr.padding]="isIOS ? \'\' : null">\n    <ion-segment [(ngModel)]="selectedTab" color="primary" (ionChange)="selectTab(selectedTab)">\n      <ion-segment-button value="words">\n        {{ \'Recovery Phrase\' | translate }}\n      </ion-segment-button>\n      <ion-segment-button value="file">\n        {{ \'File/Text\' | translate }}\n      </ion-segment-button>\n    </ion-segment>\n  </div>\n\n  <ion-card *ngIf="importErr" (click)="importErr = false">\n    <ion-item class="assertive">\n      <div translate>Could not access the wallet at the server. Please check:</div>\n      <ul>\n        <li translate>The password of the recovery phrase (if set)</li>\n        <li translate>The derivation path</li>\n        <li translate>The Wallet Service URL</li>\n      </ul>\n      <small>\n        <span translate>NOTE: To import a wallet from a 3rd party software, please go to Add Wallet, Create Wallet, and specify the Recovery Phrase there.</span>\n      </small>\n    </ion-item>\n  </ion-card>\n\n  <form [formGroup]="importForm" (ngSubmit)="import()">\n    <ion-item *ngIf="selectedTab == \'words\'">\n      <ion-label stacked>{{\'Type the recovery phrase (usually 12 words)\' | translate}}</ion-label>\n      <ion-textarea formControlName="words" [value]="importForm.value.words" autocapitalize="none"></ion-textarea>\n      <ion-icon *ngIf="!fromOnboarding" class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n\n    <div *ngIf="selectedTab == \'file\'">\n      <ion-item class="hide-validation" *ngIf="!isSafari && !isCordova">\n        <ion-input class="upload-hidden" type="file" accept="json" [(ngModel)]="formFile" (change)="fileChangeEvent($event)" formControlName="file"></ion-input>\n        <div item-content class="upload-ui">\n          <div class="empty-message">{{\'Choose a backup file from your computer\' | translate}}&hellip;</div>\n          <div class="filled-message">{{prettyFileName}}</div>\n        </div>\n      </ion-item>\n\n      <ion-item *ngIf="isSafari || isCordova">\n        <ion-label stacked>{{\'Paste the backup plain text code\' | translate}}</ion-label>\n        <ion-textarea formControlName="backupText" rows="5" [value]="importForm.value.backupText"></ion-textarea>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Password\' | translate}}</ion-label>\n        <ion-input type="password" formControlName="filePassword"></ion-input>\n      </ion-item>\n    </div>\n\n    <ion-item *ngIf="selectedTab != \'file\'">\n      <ion-label stacked>{{\'Coin\' | translate}}</ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" placeholder="{{\'Select a coin\' | translate}}" formControlName="coin">\n        <ion-option value="btc">Bastoji (BTJ)</ion-option>\n        <ion-option value="bch">Bastoji Cash (BCH)</ion-option>\n      </ion-select>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item (click)="toggleShowAdvOpts()">\n      <ion-label *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</ion-label>\n      <ion-label *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</ion-label>\n      <div item-end>\n        <ion-icon color="grey" *ngIf="!showAdvOpts" name="ios-arrow-down-outline"></ion-icon>\n        <ion-icon color="grey" *ngIf="showAdvOpts" name="ios-arrow-up-outline"></ion-icon>\n      </div>\n    </ion-item>\n\n    <div *ngIf="showAdvOpts">\n      <div *ngIf="selectedTab == \'words\'">\n        <ion-item>\n          <ion-label stacked>{{\'Password\' | translate}} *</ion-label>\n          <ion-input type="password" formControlName="passphrase"></ion-input>\n        </ion-item>\n\n        <ion-item>\n          <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n          <ion-input type="text" formControlName="derivationPath" [value]="importForm.value.derivationPath"></ion-input>\n        </ion-item>\n\n        <ion-item>\n          <ion-label>Testnet</ion-label>\n          <ion-toggle formControlName="testnetEnabled" (ionChange)="setDerivationPath()"></ion-toggle>\n        </ion-item>\n\n        <ion-item *ngIf="importForm.value.testnetEnabled">\n          <div class="warning-container">\n            <ion-icon name="ios-warning-outline"></ion-icon>\n            <span translate>WARNING: The testnet is an alternative Bastoji block chain, to be used for testing. Testnet coins are separate and distinct from actual bastojis, and do not have any value. This allows application developers or bastoji testers to experiment, without having to use real bastojis.</span>\n          </div>\n        </ion-item>\n\n      </div>\n\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <ion-item-divider>\n        <span class="info-message" translate>* This field is only for users who, in previous versions (it\'s not supported anymore), set a password to protect their recovery phrase. This field is not for your encrypt password.</span>\n      </ion-item-divider>\n\n    </div>\n  </form>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <button ion-button full class="button-footer" (click)="import()" [disabled]="!importForm.valid">\n      {{\'Import wallet\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/add/import-wallet/import-wallet.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_14__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], ImportWalletPage);

//# sourceMappingURL=import-wallet.js.map

/***/ }),

/***/ 242:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_bitpay__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_time_time__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_11_moment__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Pages

// providers







let BitPayCardPage = class BitPayCardPage {
    constructor(translate, bitPayProvider, bitPayCardProvider, logger, popupProvider, timeProvider, externalLinkProvider, navParams, navCtrl) {
        this.translate = translate;
        this.bitPayProvider = bitPayProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.timeProvider = timeProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.dateRange = {
            value: 'last30Days'
        };
        this.network = this.bitPayProvider.getEnvironment().network;
        this.cardId = this.navParams.data.id;
        if (!this.cardId)
            this.navCtrl.pop();
        this.bitPayCardProvider.get({
            cardId: this.cardId,
            noRefresh: true
        }, (_, cards) => {
            if (cards && cards[0]) {
                this.lastFourDigits = cards[0].lastFourDigits;
                this.balance = cards[0].balance;
                this.currencySymbol = cards[0].currencySymbol;
                this.updatedOn = cards[0].updatedOn;
                this.currency = cards[0].currency;
            }
            this.update();
        });
    }
    setDateRange(preset) {
        let startDate;
        let endDate;
        preset = preset || 'last30Days';
        switch (preset) {
            case 'last30Days':
                startDate = __WEBPACK_IMPORTED_MODULE_11_moment__()
                    .subtract(30, 'days')
                    .toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_11_moment__().toISOString();
                break;
            case 'lastMonth':
                startDate = __WEBPACK_IMPORTED_MODULE_11_moment__()
                    .startOf('month')
                    .subtract(1, 'month')
                    .toISOString();
                endDate = __WEBPACK_IMPORTED_MODULE_11_moment__()
                    .startOf('month')
                    .toISOString();
                break;
            case 'all':
                startDate = null;
                endDate = null;
                break;
            default:
                return undefined;
        }
        return {
            startDate,
            endDate
        };
    }
    setGetStarted(history, cb) {
        // Is the card new?
        if (!__WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](history.transactionList))
            return cb();
        let dateRange = this.setDateRange('all');
        this.bitPayCardProvider.getHistory(this.cardId, dateRange, (err, history) => {
            if (!err && __WEBPACK_IMPORTED_MODULE_10_lodash__["isEmpty"](history.transactionList))
                this.getStarted = true;
            return cb();
        });
    }
    update() {
        let dateRange = this.setDateRange(this.dateRange.value);
        this.loadingHistory = true;
        this.bitPayCardProvider.getHistory(this.cardId, dateRange, (err, history) => {
            this.loadingHistory = false;
            if (err) {
                this.logger.error(err);
                this.bitpayCardTransactionHistoryCompleted = null;
                this.bitpayCardTransactionHistoryConfirming = null;
                this.bitpayCardTransactionHistoryPreAuth = null;
                this.balance = null;
                this.popupProvider.ionicAlert('Error', this.translate.instant('Could not get transactions'));
                return;
            }
            this.setGetStarted(history, () => {
                let txs = __WEBPACK_IMPORTED_MODULE_10_lodash__["clone"](history.txs);
                this.setDateTime(txs);
                this.bitpayCardTransactionHistoryConfirming = this.bitPayCardProvider.filterTransactions('confirming', txs);
                this.bitpayCardTransactionHistoryCompleted = this.bitPayCardProvider.filterTransactions('completed', txs);
                this.bitpayCardTransactionHistoryPreAuth = this.bitPayCardProvider.filterTransactions('preAuth', txs);
                this.balance = history.currentCardBalance;
                this.updatedOn = null;
                if (this.dateRange.value == 'last30Days') {
                    // TODO?
                    // $log.debug('BitPay Card: storing cache history');
                    // let cacheHistory = {
                    //   balance: history.currentCardBalance,
                    //   transactions: history.txs
                    // };
                    // this.bitPayCardProvider.setHistory($scope.cardId, cacheHistory, {}, (err) => {
                    //   if (err) $log.error(err);
                    //   $scope.historyCached = true;
                    // });
                }
            });
        });
    }
    setDateTime(txs) {
        let txDate, txDateUtc;
        let newDate;
        for (let i = 0; i < txs.length; i++) {
            txDate = new Date(txs[i].date);
            txDateUtc = new Date(txs[i].date.replace('Z', ''));
            let amTime = this.createdWithinPastDay(txs[i]);
            newDate = amTime
                ? __WEBPACK_IMPORTED_MODULE_11_moment__(txDateUtc).fromNow()
                : __WEBPACK_IMPORTED_MODULE_11_moment__(txDate)
                    .utc()
                    .format('MMM D, YYYY');
            txs[i].date = newDate;
        }
    }
    createdWithinPastDay(tx) {
        let result = false;
        if (tx.date) {
            result = this.timeProvider.withinPastDay(tx.date);
        }
        return result;
    }
    openExternalLink(url) {
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    viewOnBlockchain(transactionId) {
        let url = 'https://insight.bitpay.com/tx/' + transactionId;
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Transaction on Insight');
        let okText = this.translate.instant('Open Insight');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    topUp() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__send_amount_amount__["a" /* AmountPage */], {
            id: this.cardId,
            nextPage: 'BitPayCardTopUpPage',
            currency: this.currency
        });
    }
};
BitPayCardPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-bitpay-card',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card.html"*/'<ion-header no-border>\n  <ion-navbar>\n    <ion-title>BitPay Visa\n      <sup>&reg;</sup> Card ({{lastFourDigits}})</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="balance-card">\n    <div class="balance-header">\n      <div (tap)="update()" class="balance-str" *ngIf="balance">\n        {{balance | currency:currencySymbol:2 }}\n      </div>\n      <button ion-button color="primary" (click)="topUp()" *ngIf="balance" no-low-fee>\n        <span translate>Add funds</span> &rarr;\n      </button>\n\n      <div class="card-info">\n        <ion-spinner *ngIf="!balance || loadingHistory"></ion-spinner>\n      </div>\n\n    </div>\n  </div>\n\n  <div *ngIf="getStarted" class="initial-message">\n    <h1 translate>Get started</h1>\n    <div translate>\n      Your BitPay Card is ready. Add funds to your card to start using it at stores and ATMs worldwide.\n    </div>\n  </div>\n\n  <ion-list *ngIf="!getStarted">\n    <ion-item-divider>\n      <ion-label>\n        <span translate>Activity</span>\n      </ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" padding-horizontal [(ngModel)]="dateRange.value" (ionChange)="update()">\n        <ion-option value="last30Days" selected>Recent</ion-option>\n        <ion-option value="lastMonth">Last Month</ion-option>\n        <ion-option value="all">All</ion-option>\n      </ion-select>\n    </ion-item-divider>\n\n    <ion-item-divider *ngIf="bitpayCardTransactionHistoryConfirming && bitpayCardTransactionHistoryConfirming[0]">\n      <ion-icon item-end (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/115003014526-Why-do-you-require-one-blockchain-confirmation-for-BitPay-Card-loads-\')">\n        <img src="assets/img/icon-help-support.svg" />\n      </ion-icon>\n      <span translate>Confirming</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryConfirming">\n        <page-card-item [card]="card" [currencySymbol]="currencySymbol"></page-card-item>\n      </div>\n    </ion-list>\n\n    <ion-item-divider *ngIf="bitpayCardTransactionHistoryPreAuth && bitpayCardTransactionHistoryPreAuth[0]">\n      <ion-icon item-end (click)="openExternalLink(\'https://support.bitpay.com/hc/en-us/articles/115003003563-Why-was-I-overcharged-on-my-BitPay-Card-account-Why-is-there-a-hold-on-my-account-\')">\n        <img src="assets/img/icon-help-support.svg" />\n      </ion-icon>\n      <span translate>Pre-Auth Holds</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryPreAuth">\n        <page-card-item [card]="card" [currencySymbol]="currencySymbol"></page-card-item>\n      </div>\n    </ion-list>\n\n    <ion-item-divider *ngIf="(bitpayCardTransactionHistoryPreAuth && bitpayCardTransactionHistoryPreAuth[0]) || (bitpayCardTransactionHistoryConfirming && bitpayCardTransactionHistoryConfirming[0])">\n      <span translate>Completed</span>\n    </ion-item-divider>\n    <ion-list>\n      <div *ngFor="let card of bitpayCardTransactionHistoryCompleted">\n        <page-card-item [card]="card" [currencySymbol]="currencySymbol"></page-card-item>\n      </div>\n    </ion-list>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */]])
], BitPayCardPage);

//# sourceMappingURL=bitpay-card.js.map

/***/ }),

/***/ 243:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(356);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





// Providers









let TxDetailsPage = class TxDetailsPage {
    constructor(addressBookProvider, configProvider, events, externalLinkProvider, logger, navCtrl, navParams, onGoingProcess, popupProvider, profileProvider, txConfirmNotificationProvider, txFormatProvider, walletProvider, translate) {
        this.addressBookProvider = addressBookProvider;
        this.configProvider = configProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcess = onGoingProcess;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.updateTxDebounced = __WEBPACK_IMPORTED_MODULE_3_lodash__["debounce"](this.updateTx, 1000);
    }
    ionViewDidLoad() {
        this.config = this.configProvider.get();
        this.txId = this.navParams.data.txid;
        this.title = this.translate.instant('Transaction');
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.color = this.wallet.color;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.txsUnsubscribedForNotifications = this.config.confirmedTxsNotifications
            ? !this.config.confirmedTxsNotifications.enabled
            : true;
        let defaults = this.configProvider.getDefaults();
        this.blockexplorerUrl =
            this.wallet.coin === 'bch'
                ? defaults.blockExplorerUrl.bch
                : defaults.blockExplorerUrl.btc;
        this.txConfirmNotificationProvider.checkIfEnabled(this.txId).then(res => {
            this.txNotification = {
                value: res
            };
        });
        this.updateTx();
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', (_, type, n) => {
            if (type == 'NewBlock' && n && n.data && n.data.network == 'livenet')
                this.updateTxDebounced({ hideLoading: true });
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    readMore() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/115004497783-What-does-the-BitPay-wallet-s-warning-amount-too-low-to-spend-mean-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Read more in our support page');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    updateMemo() {
        this.walletProvider
            .getTxNote(this.wallet, this.btx.txid)
            .then(note => {
            if (!note || note.body == '')
                return;
            this.btx.note = note;
        })
            .catch(err => {
            this.logger.warn('Could not fetch transaction note: ' + err);
            return;
        });
    }
    initActionList() {
        this.actionList = [];
        if ((this.btx.action != 'sent' && this.btx.action != 'moved') ||
            !this.isShared)
            return;
        let actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.btx.createdOn,
            description: actionDescriptions.created,
            by: this.btx.creatorName
        });
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](this.btx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        this.actionList.push({
            type: 'broadcasted',
            time: this.btx.time,
            description: actionDescriptions.broadcasted
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    updateTx(opts) {
        opts = opts ? opts : {};
        if (!opts.hideLoading)
            this.onGoingProcess.set('loadingTxInfo');
        this.walletProvider
            .getTx(this.wallet, this.txId)
            .then(tx => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.btx = this.txFormatProvider.processTx(this.wallet.coin, tx, this.walletProvider.useLegacyAddress());
            this.btx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, tx.fees);
            this.btx.feeRateStr =
                ((this.btx.fees / (this.btx.amount + this.btx.fees)) * 100).toFixed(2) + '%';
            if (!this.btx.note) {
                this.txMemo = this.btx.message;
            }
            if (this.btx.note && this.btx.note.body) {
                this.txMemo = this.btx.note.body;
            }
            if (this.btx.action != 'invalid') {
                if (this.btx.action == 'sent')
                    this.title = this.translate.instant('Sent Funds');
                if (this.btx.action == 'received')
                    this.title = this.translate.instant('Received Funds');
                if (this.btx.action == 'moved')
                    this.title = this.translate.instant('Moved Funds');
            }
            this.updateMemo();
            this.initActionList();
            this.contact();
            this.walletProvider
                .getLowAmount(this.wallet)
                .then((amount) => {
                this.btx.lowAmount = tx.amount < amount;
            })
                .catch(err => {
                this.logger.warn('Error getting low amounts: ' + err);
                return;
            });
        })
            .catch(err => {
            if (!opts.hideLoading)
                this.onGoingProcess.clear();
            this.logger.warn('Error getting transaction: ' + err);
            this.navCtrl.pop();
            return this.popupProvider.ionicAlert('Error', this.translate.instant('Transaction not available at this time'));
        });
    }
    saveMemoInfo(memo) {
        return __awaiter(this, void 0, void 0, function* () {
            this.btx.note = {
                body: memo
            };
            this.logger.debug('Saving memo');
            let args = {
                txid: this.btx.txid,
                body: memo
            };
            yield this.walletProvider
                .editTxNote(this.wallet, args)
                .catch((err) => {
                this.logger.debug('Could not save tx comment ' + err);
            });
            this.logger.info('Tx Note edited');
        });
    }
    viewOnBlockchain() {
        let btx = this.btx;
        let url = 'https://' +
            (this.getShortNetworkName() == 'test' ? 'test-' : '') +
            this.blockexplorerUrl +
            '/tx/' +
            btx.txid;
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Transaction on Insight');
        let okText = this.translate.instant('Open Insight');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    getShortNetworkName() {
        let n = this.wallet.credentials.network;
        return n.substring(0, 4);
    }
    txConfirmNotificationChange() {
        if (this.txNotification.value) {
            this.txConfirmNotificationProvider.subscribe(this.wallet, {
                txid: this.txId
            });
        }
        else {
            this.txConfirmNotificationProvider.unsubscribe(this.wallet, this.txId);
        }
    }
    contact() {
        let addr = this.btx.addressTo;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                let name = __WEBPACK_IMPORTED_MODULE_3_lodash__["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
};
TxDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-tx-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/tx-details/tx-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list *ngIf="btx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label" *ngIf="btx.confirmations > 0">\n          <img class="sending-img" src="assets/img/tx-action/icon-sent.svg" width="40" *ngIf="btx.action === \'sent\'">\n          <img class="sending-img" src="assets/img/tx-action/icon-received.svg" width="40" *ngIf="btx.action === \'received\'">\n          <img class="sending-img" src="assets/img/tx-action/icon-moved.svg" width="40" *ngIf="btx.action === \'moved\'">\n          <span *ngIf="btx.action === \'sent\'" translate>Sent</span>\n          <span *ngIf="btx.action === \'received\'" translate>Received</span>\n          <span *ngIf="btx.action === \'moved\'" translate>Moved</span>\n        </div>\n        <div class="sending-label" *ngIf="btx.confirmations === 0">\n          <img class="sending-img" src="assets/img/tx-action/icon-confirming.svg">\n          <span *ngIf="btx.action == \'sent\' || btx.action == \'moved\'" translate>Sending</span>\n          <span *ngIf="btx.action == \'received\'" translate>Receiving</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">{{btx.amountValueStr}}\n            <span class="unit">{{btx.amountUnitStr}}</span>\n          </div>\n          <div class="alternative">\n            <span>{{btx.alternativeAmountStr}}</span>\n          </div>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item class="low-fees" *ngIf="btx.action == \'received\' && btx.lowFees">\n      <img src="assets/img/icon-warning.png" width="20">\n      <ion-note>\n        <span translate>\n          This transaction could take a long time to confirm or could be dropped due to the low fees set by the sender\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item class="low-fees" *ngIf="btx.lowAmount">\n      <img src="assets/img/icon-warning.png" width="20">\n      <ion-note>\n        <span translate>\n          This transaction amount is too small compared to current Bastoji network fees. Spending these funds will need a Bastoji network\n          fee cost comparable to the funds itself.\n        </span>\n      </ion-note>\n      <a (click)="readMore()" translate>Learn more</a>\n    </ion-item>\n\n    <ion-item class="item-fee" *ngIf="btx && btx.feeStr && btx.action != \'received\'">\n      <div class="fee-title">\n        {{\'Fee\' | translate}}\n      </div>\n      <ion-note>\n        <span class="fee-amount">{{btx.feeStr}}</span>\n        <div class="fee-details">\n          {{btx.feeFiatStr}} &middot;\n          <span *ngIf="btx.feeRateStr" translate>{{btx.feeRateStr}} of the total amount</span>\n        </div>\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item *ngIf="btx.action === \'sent\'" class="container-to">\n      <span translate>To</span>\n      <div class="payment-to">\n        <img class="icon-bastoji" *ngIf="!cardId" src="assets/img/icon-bastoji-small.svg">\n        <img class="icon-bastoji" *ngIf="cardId" src="assets/img/icon-card.svg" width="34">\n        <div class="ellipsis" copy-to-clipboard="{{ btx.addressTo ? btx.addressTo : btx.outputs[0].address }}">\n          <span *ngIf="!contactName && !btx.addressTo">{{ btx.outputs[0].address }}</span>\n          <span *ngIf="!contactName && btx.addressTo">{{ btx.addressTo }}</span>\n          <span *ngIf="contactName">{{ contactName }}</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item class="container-from">\n      <span *ngIf="btx.action === \'sent\'" translate>From</span>\n      <span *ngIf="btx.action !== \'sent\'" translate>To</span>\n      <div class="wallet" *ngIf="wallet">\n        <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg"\n          class="icon-wallet" />\n        <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg"\n          class="icon-wallet" />\n        <div>{{wallet.name}}</div>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="btx.action != \'received\' && isShared">\n      <ion-label>{{\'Created by\' | translate}}</ion-label>\n      <ion-note item-end>\n        {{btx.creatorName}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="btx.ts || btx.createdOn || btx.time">\n      <ion-label>{{\'Date\' | translate}}</ion-label>\n      <ion-note item-end>\n        <time>{{ (btx.ts || btx.createdOn || btx.time) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      <ion-label>{{\'Confirmations\' | translate}}</ion-label>\n      <ion-note item-end>\n        <span *ngIf="!btx.confirmations || btx.confirmations == 0" translate>\n          Unconfirmed\n        </span>\n        <span *ngIf="btx.confirmations>0 && !btx.safeConfirmed">\n          {{btx.confirmations}}\n        </span>\n        <span *ngIf="btx.safeConfirmed">\n          {{btx.safeConfirmed}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <editable-item (valChange)="saveMemoInfo($event)" [value]="txMemo" [itemPlaceholder]="\'Enter a transaction memo\' | translate">\n      <span item-label translate>Memo</span>\n    </editable-item>\n\n    <ion-item class="container-tx-id">\n      <span translate>Transaction ID</span>\n      <div class="tx-id">\n        <div class="ellipsis id" copy-to-clipboard="{{ btx.txid }}">\n          <span>{{ btx.txid }}</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="txsUnsubscribedForNotifications">\n      <ion-label>{{\'Notify me if confirmed\' | translate}}</ion-label>\n      <ion-toggle checked="false" *ngIf="!btx.confirmations || btx.confirmations == 0" [(ngModel)]="txNotification.value" (ionChange)="txConfirmNotificationChange()"></ion-toggle>\n    </ion-item>\n\n    <div *ngIf="actionList && actionList[0]">\n      <ion-item-divider>{{\'Timeline\' | translate}}</ion-item-divider>\n      <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\'}"\n        *ngFor="let a of actionList; let i = index">\n        <div class="timeline-content">\n          <div class="timeline-content-icon">\n            <div class="rejected" *ngIf="a.type === \'reject\'">!</div>\n            <img src="assets/img/icon-broadcasted.svg" *ngIf="a.type === \'broadcasted\'">\n            <div class="line" *ngIf="a.type !== \'reject\' && a.type !== \'broadcasted\'">{{actionList.length - i}}</div>\n          </div>\n          <div class="timeline-content-label">\n            <div class="action">{{a.description}}</div>\n            <div class="name">{{a.by}}</div>\n          </div>\n          <ion-note class="ellipsis">\n            <time>{{ a.time * 1000 | amTimeAgo}}</time>\n          </ion-note>\n        </div>\n      </div>\n    </div>\n\n    <div text-center padding>\n      <button ion-button clear (click)="viewOnBlockchain()">\n        {{\'View on blockchain\' | translate}}\n      </button>\n    </div>\n\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/tx-details/tx-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], TxDetailsPage);

//# sourceMappingURL=tx-details.js.map

/***/ }),

/***/ 244:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxpDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_15_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers










// pages


let TxpDetailsPage = class TxpDetailsPage {
    constructor(navParams, platformProvider, feeProvider, events, logger, popupProvider, bwcError, walletProvider, onGoingProcessProvider, viewCtrl, configProvider, profileProvider, txFormatProvider, translate, modalCtrl, addressBookProvider) {
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.events = events;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.bwcError = bwcError;
        this.walletProvider = walletProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.viewCtrl = viewCtrl;
        this.configProvider = configProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.addressBookProvider = addressBookProvider;
        this.showMultiplesOutputs = false;
        let config = this.configProvider.get().wallet;
        this.tx = this.navParams.data.tx;
        this.wallet = this.tx.wallet
            ? this.tx.wallet
            : this.profileProvider.getWallet(this.tx.walletId);
        this.tx = this.txFormatProvider.processTx(this.wallet.coin, this.tx, this.walletProvider.useLegacyAddress());
        if (!this.tx.toAddress)
            this.tx.toAddress = this.tx.outputs[0].toAddress;
        this.isGlidera = this.navParams.data.isGlidera;
        this.GLIDERA_LOCK_TIME = 6 * 60 * 60;
        this.currentSpendUnconfirmed = config.spendUnconfirmed;
        this.loading = false;
        this.isCordova = this.platformProvider.isCordova;
        this.copayers = this.wallet.status.wallet.copayers;
        this.copayerId = this.wallet.credentials.copayerId;
        this.isShared = this.wallet.credentials.n > 1;
        this.canSign = this.wallet.canSign() || this.wallet.isPrivKeyExternal();
        this.color = this.wallet.color;
        this.contact();
        // To test multiple outputs...
        // var txp = {
        //   message: 'test multi-output',
        //   fee: 1000,
        //   createdOn: Math.floor(Date.now() / 1000),
        //   outputs: [],
        // };
        // for (let i = 0; i < 15; i++) {
        //   txp.outputs.push({
        //     amountStr: "600 BTJ",
        //     toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
        //     message: 'output #' + (Number(i) + 1)
        //   });
        // };
        // this.tx = _.merge(this.tx, txp);
        // this.tx.hasMultiplesOutputs = true;
    }
    ionViewWillEnter() {
        this.displayFeeValues();
        this.initActionList();
        this.checkPaypro();
        this.applyButtonText();
        // ToDo: use tx.customData instead of tx.message
        if (this.tx.message === 'Glidera transaction' && this.isGlidera) {
            this.tx.isGlidera = true;
            if (this.tx.canBeRemoved) {
                this.tx.canBeRemoved =
                    Date.now() / 1000 - (this.tx.ts || this.tx.createdOn) >
                        this.GLIDERA_LOCK_TIME;
            }
        }
        this.events.subscribe('bwsEvent', (walletId, type) => {
            __WEBPACK_IMPORTED_MODULE_15_lodash__["each"]([
                'TxProposalRejectedBy',
                'TxProposalAcceptedBy',
                'transactionProposalRemoved',
                'TxProposalRemoved',
                'NewOutgoingTx',
                'UpdateTx'
            ], (eventName) => {
                if (walletId == this.wallet.id && type == eventName) {
                    this.updateTxInfo(eventName);
                }
            });
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    displayFeeValues() {
        this.tx.feeFiatStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, this.tx.fee);
        this.tx.feeRateStr =
            ((this.tx.fee / (this.tx.amount + this.tx.fee)) * 100).toFixed(2) + '%';
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelStr = feeOpts[this.tx.feeLevel];
    }
    applyButtonText() {
        var lastSigner = __WEBPACK_IMPORTED_MODULE_15_lodash__["filter"](this.tx.actions, {
            type: 'accept'
        }).length ==
            this.tx.requiredSignatures - 1;
        if (lastSigner) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText = this.translate.instant('Payment Accepted');
        }
    }
    initActionList() {
        this.actionList = [];
        if (!this.isShared)
            return;
        var actionDescriptions = {
            created: this.translate.instant('Proposal Created'),
            accept: this.translate.instant('Accepted'),
            reject: this.translate.instant('Rejected'),
            broadcasted: this.translate.instant('Broadcasted')
        };
        this.actionList.push({
            type: 'created',
            time: this.tx.createdOn,
            description: actionDescriptions['created'],
            by: this.tx.creatorName
        });
        __WEBPACK_IMPORTED_MODULE_15_lodash__["each"](this.tx.actions, action => {
            this.actionList.push({
                type: action.type,
                time: action.createdOn,
                description: actionDescriptions[action.type],
                by: action.copayerName
            });
        });
        setTimeout(() => {
            this.actionList.reverse();
        }, 10);
    }
    checkPaypro() {
        if (this.tx.payProUrl) {
            this.wallet.fetchPayPro({
                payProUrl: this.tx.payProUrl
            }, (err, paypro) => {
                if (err) {
                    this.logger.error(err);
                    this.paymentExpired = true;
                    this.popupProvider.ionicAlert(null, this.translate.instant('Could not fetch the invoice'));
                    return;
                }
                this.tx.paypro = paypro;
                this.paymentTimeControl(this.tx.paypro.expires);
            });
        }
    }
    paymentTimeControl(expirationTime) {
        let setExpirationTime = () => {
            let now = Math.floor(Date.now() / 1000);
            if (now > expirationTime) {
                this.paymentExpired = true;
                if (this.countDown)
                    clearInterval(this.countDown);
                return;
            }
            let totalSecs = expirationTime - now;
            let m = Math.floor(totalSecs / 60);
            let s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        };
        this.paymentExpired = false;
        setExpirationTime();
        this.countDown = setInterval(() => {
            setExpirationTime();
        }, 1000);
    }
    setError(err, prefix) {
        this.loading = false;
        this.popupProvider.ionicAlert(this.translate.instant('Error'), this.bwcError.msg(err, prefix));
    }
    sign() {
        this.loading = true;
        this.walletProvider
            .publishAndSign(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.setError(err, 'Could not send payment');
        });
    }
    reject() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to reject this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.loading = true;
            this.onGoingProcessProvider.set('rejectTx');
            this.walletProvider
                .reject(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.setError(err, this.translate.instant('Could not reject payment'));
            });
        });
    }
    remove() {
        let title = this.translate.instant('Warning!');
        let msg = this.translate.instant('Are you sure you want to remove this transaction?');
        this.popupProvider
            .ionicConfirm(title, msg, null, null)
            .then((res) => {
            if (!res)
                return;
            this.onGoingProcessProvider.set('removeTx');
            this.walletProvider
                .removeTx(this.wallet, this.tx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.close();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                if (err && !(err.message && err.message.match(/Unexpected/))) {
                    this.setError(err, this.translate.instant('Could not delete payment proposal'));
                }
            });
        });
    }
    broadcast() {
        this.loading = true;
        this.onGoingProcessProvider.set('broadcastingTx');
        this.walletProvider
            .broadcastTx(this.wallet, this.tx)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.setError(err, 'Could not broadcast payment');
            this.logger.error('Could not broadcast: ', this.tx.coin, this.tx.network, this.tx.raw);
        });
    }
    getShortNetworkName() {
        return this.wallet.credentials.networkName.substring(0, 4);
    }
    updateTxInfo(eventName) {
        this.walletProvider
            .getTxp(this.wallet, this.tx.id)
            .then(tx => {
            let action = __WEBPACK_IMPORTED_MODULE_15_lodash__["find"](tx.actions, {
                copayerId: this.wallet.credentials.copayerId
            });
            this.tx = this.txFormatProvider.processTx(this.wallet.coin, tx, this.walletProvider.useLegacyAddress());
            if (!action && tx.status == 'pending')
                this.tx.pendingForUs = true;
            this.updateCopayerList();
            this.initActionList();
        })
            .catch(err => {
            if (err.message &&
                err.message == 'Transaction proposal not found' &&
                (eventName == 'transactionProposalRemoved' ||
                    eventName == 'TxProposalRemoved')) {
                this.tx.removed = true;
                this.tx.canBeRemoved = false;
                this.tx.pendingForUs = false;
            }
        });
    }
    updateCopayerList() {
        __WEBPACK_IMPORTED_MODULE_15_lodash__["map"](this.copayers, (cp) => {
            __WEBPACK_IMPORTED_MODULE_15_lodash__["each"](this.tx.actions, ac => {
                if (cp.id == ac.copayerId) {
                    cp.action = ac.type;
                }
            });
        });
    }
    onConfirm() {
        this.sign();
    }
    close() {
        this.loading = false;
        this.viewCtrl.dismiss();
    }
    openFinishModal() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_14__finish_finish__["a" /* FinishModalPage */], { finishText: this.successText }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.close();
        });
    }
    contact() {
        let addr = this.tx.toAddress;
        this.addressBookProvider
            .get(addr)
            .then(ab => {
            if (ab) {
                let name = __WEBPACK_IMPORTED_MODULE_15_lodash__["isObject"](ab) ? ab.name : ab;
                this.contactName = name;
            }
        })
            .catch(err => {
            this.logger.warn(err);
        });
    }
};
TxpDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-txp-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/txp-details/txp-details.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      {{\'Payment Proposal\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content no-bounce [ngClass]="{\'margin-bottom\':(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired)}">\n  <ion-list *ngIf="tx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label">\n          <img class="sending-img" src="assets/img/icon-tx-sent-outline.svg">\n          <span translate>Sending</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">{{tx.amountStr}}</div>\n          <div class="alternative" *ngIf="tx.alternativeAmountStr">{{tx.alternativeAmountStr}}</div>\n        </div>\n      </div>\n    </ion-item>\n    <div *ngIf="tx && tx.removed" class="box-notification no-margin warn" text-wrap>\n      <span translate>The payment was removed by creator</span>\n    </div>\n    <div *ngIf="!currentSpendUnconfirmed && tx && tx.hasUnconfirmedInputs" class="box-notification no-margin warn" text-wrap>\n      <span translate>Warning: this transaction has unconfirmed inputs</span>\n    </div>\n\n    <div *ngIf="tx && tx.status != \'pending\'">\n      <div text-center *ngIf="tx && tx.status == \'accepted\' && !tx.isGlidera">\n        <div class="box-notification no-margin notice" text-wrap translate>Payment accepted, but not yet broadcasted</div>\n        <button margin ion-button outline small icon-left (click)="broadcast(tx)" [disabled]="loading">\n          <ion-icon name="cloud-upload"></ion-icon>\n          <span translate>Broadcast Payment</span>\n        </button>\n      </div>\n      <div class="box-notification no-margin notice" *ngIf="tx && tx.status == \'accepted\' && tx.isGlidera" text-wrap padding>\n        <span translate>Payment accepted. It will be broadcasted by Glidera. In case there is a problem, it can be deleted 6 hours after it was created.</span>\n      </div>\n      <div class="box-notification no-margin success" *ngIf="tx && tx.status == \'broadcasted\'" translate>\n        Payment Sent\n      </div>\n      <div class="box-notification no-margin warn" *ngIf="tx && tx.status ==\'rejected\'" translate>\n        Payment Rejected\n      </div>\n    </div>\n\n    <ion-item class="item-fee" *ngIf="tx && tx.feeStr">\n      <div class="fee-title">\n        {{\'Fee\' | translate}} {{tx.feeLevelStr}}\n      </div>\n      <ion-note>\n        <span class="fee-amount">{{tx.feeStr}}</span>\n        <div class="fee-details">\n          {{tx.feeFiatStr}} &middot;\n          <span *ngIf="tx.feeRateStr" translate>{{tx.feeRateStr}} of the total amount</span>\n        </div>\n      </ion-note>\n    </ion-item>\n\n    <div padding class="proposal-rejection" *ngIf="(tx && !tx.removed) && isShared && (tx && tx.pendingForUs) && !paymentExpired">\n      <button ion-button clear color="danger" (click)="reject()" [disabled]="loading">\n        {{\'Reject Payment Proposal\'| translate}}\n      </button>\n    </div>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item class="container-to" (click)="showMultiplesOutputs = !showMultiplesOutputs" copy-to-clipboard="{{ tx.toAddress && !tx.hasMultiplesOutputs ? tx.toAddress : tx.outputs[0].address }}">\n      <span translate>To</span>\n      <div class="wallet">\n        <ion-icon item-start>\n          <img class="icon-bastoji" src="assets/img/icon-bastoji-small.svg" />\n        </ion-icon>\n        <!-- <contact ng-if="!tx.hasMultiplesOutputs" class="ellipsis" address="{{tx.toAddress}}"></contact>  TODO -->\n        <div class="output-info">\n          <span *ngIf="!contactName && !tx.toAddress && !tx.hasMultiplesOutputs">{{ tx.outputs[0].address }}</span>\n          <span *ngIf="!contactName && tx.toAddress && !tx.hasMultiplesOutputs">{{ tx.toAddress }}</span>\n          <span *ngIf="contactName && !tx.hasMultiplesOutputs">{{ contactName }}</span>\n          <span *ngIf="tx && tx.hasMultiplesOutputs">\n            <span translate>Multiple recipients</span>\n            <span>{{tx.recipientCount}}</span>\n          </span>\n        </div>\n        <div class="last-item" *ngIf="tx && tx.hasMultiplesOutputs" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="showMultiplesOutputs" name="ios-arrow-up-outline"></ion-icon>\n            <ion-icon *ngIf="!showMultiplesOutputs" name="ios-arrow-down-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-list detail-none *ngIf="tx && tx.hasMultiplesOutputs && showMultiplesOutputs">\n      <ion-item class="proposal-container" *ngFor="let output of tx.outputs" copy-to-clipboard="{{output.toAddress}}">\n        <div item-left>\n          <h2>\n            <span translate>To</span>:\n          </h2>\n          <h3>\n            <span translate>Amount</span>:\n          </h3>\n          <p>\n            <span translate>Note</span>:\n          </p>\n        </div>\n        <ion-note item-right text-end col-11>\n          <h2 class="output-info">{{output.toAddress || output.address}}</h2>\n          <h3 class="output-info">{{output.amountStr}}\n            <span *ngIf="output.alternativeAmountStr">({{output.alternativeAmountStr}})</span>\n          </h3>\n          <p class="output-info output-note">{{output.message}}</p>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <ion-item class="container-from">\n      <span translate>From</span>\n      <div class="wallet" *ngIf="wallet">\n        <ion-icon item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n        </ion-icon>\n        <div>{{wallet.name}}</div>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="isShared">\n      <ion-label>\n        <span translate>Created by</span>\n      </ion-label>\n      <ion-note item-end>\n        <span>{{tx.creatorName}}</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx && tx.ts || tx.createdOn">\n      <ion-label>\n        <span translate>Date</span>\n      </ion-label>\n      <ion-note item-end>\n        <time>{{ (tx.ts || tx.createdOn ) * 1000 | amDateFormat:\'MM/DD/YYYY hh:mm a\'}}</time>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx && tx.message">\n      <span translate>Memo</span>\n      <div class="item-memo" text-wrap>\n        <ion-note>{{tx.message}}</ion-note>\n      </div>\n    </ion-item>\n\n    <div *ngIf="tx && tx.paypro">\n      <ion-item-divider>{{\'Payment request\' | translate}}</ion-item-divider>\n      <ion-item>\n        <span>{{\'Pay To\'|translate}}</span>\n        <ion-note item-end>\n          {{tx.paypro.domain}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span translate>Certified by</span>\n        <div class="item-memo" text-wrap>\n          <ion-note *ngIf="tx.paypro.caTrusted" icon-start item-end>\n            <ion-icon *ngIf="tx.paypro.verified" color="success" name="lock"></ion-icon>\n            <ion-icon *ngIf="!tx.paypro.verified" color="warning" name="unlock"></ion-icon>\n            {{tx.paypro.caName}} {{\'(Trusted)\' | translate}}\n          </ion-note>\n          <ion-note *ngIf="!tx.paypro.caTrusted" icon-start item-end>\n            <span *ngIf="tx.paypro.selfSigned">\n              <ion-icon color="danger" name="unlock"></ion-icon>\n              <span translate>Self-signed Certificate</span>\n            </span>\n            <span *ngIf="!tx.paypro.selfSigned">\n              <ion-icon color="warning" name="lock"></ion-icon>\n              {{tx.paypro.caName}}\n              <br>\n              <span translate>WARNING: UNTRUSTED CERTIFICATE</span>\n            </span>\n          </ion-note>\n        </div>\n      </ion-item>\n      <ion-item *ngIf="paymentExpired">\n        <ion-label>\n          {{\'Expired\'|translate}}\n        </ion-label>\n        <ion-note color="danger" item-end>\n          <time>{{tx.paypro.expires * 1000 | amTimeAgo }}</time>\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="!paymentExpired">\n        <ion-label>\n          {{\'Expires\'|translate}}\n        </ion-label>\n        <ion-note item-end>\n          <time>{{expires}}</time>\n        </ion-note>\n      </ion-item>\n      <ion-item *ngIf="tx.paypro.memo">\n        <span translate>Merchant Message</span>\n        <div class="item-memo" *ngIf="tx.paypro.memo" text-wrap>\n          <ion-note>{{tx.paypro.memo}}</ion-note>\n        </div>\n      </ion-item>\n    </div>\n\n    <div *ngIf="actionList && actionList[0]">\n      <ion-item-divider>{{\'Timeline\' | translate}}</ion-item-divider>\n      <div class="timeline-item" [ngClass]="{\'action-created\' : a.type == \'created\' || a.type == \'accept\', \'action-rejected\' : a.type == \'reject\'}" *ngFor="let a of actionList; let i = index">\n        <div class="timeline-content">\n          <div class="timeline-content-icon">\n            <div class="rejected" *ngIf="a.type === \'reject\'">!</div>\n            <div class="line" *ngIf="a.type !== \'reject\'">{{actionList.length - i}}</div>\n          </div>\n          <div class="timeline-content-label">\n            <div class="action">{{a.description}}</div>\n            <div class="name">{{a.by}}</div>\n          </div>\n          <ion-note class="ellipsis">\n            <time>{{ a.time * 1000 | amTimeAgo}}</time>\n          </ion-note>\n        </div>\n      </div>\n      <ion-item-divider></ion-item-divider>\n    </div>\n\n    <div padding class="proposal-deletion" *ngIf="((tx && !tx.removed) && (tx && tx.canBeRemoved)) || (tx && tx.status == \'accepted\' && !tx.broadcastedOn)">\n      <div class="proposal-deletion-help" *ngIf="!tx.isGlidera && isShared" translate>\n        * A payment proposal can be deleted if 1) you are the creator, and no other sqoiner has signed, or 2) 10 minutes have passed since the proposal was created.\n      </div>\n      <button ion-button clear color="danger" (click)="remove()" [disabled]="loading">\n        {{\'Delete Payment Proposal\' | translate}}\n      </button>\n    </div>\n\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && isCordova" [buttonText]="buttonText" (slideDone)="onConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="(tx && !tx.removed) && (tx && tx.pendingForUs && canSign && !paymentExpired) && !isCordova">\n    <button ion-button full class="button-footer" (click)="onConfirm()">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/txp-details/txp-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */]])
], TxpDetailsPage);

//# sourceMappingURL=txp-details.js.map

/***/ }),

/***/ 245:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers


let FeedbackProvider = class FeedbackProvider {
    constructor(http, logger, appProvider) {
        this.http = http;
        this.logger = logger;
        this.appProvider = appProvider;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.feedbackSheetURL
                ? this.appProvider.servicesInfo.feedbackSheetURL
                : null;
    }
    send(dataSrc) {
        return new Promise((resolve, reject) => {
            if (!this.URL)
                return resolve();
            const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
                'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
            });
            const urlSearchParams = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["d" /* HttpParams */]()
                .set('Email', dataSrc.email)
                .set('Feedback', dataSrc.feedback)
                .set('Score', dataSrc.score)
                .set('AppVersion', dataSrc.appVersion)
                .set('Platform', dataSrc.platform)
                .set('DeviceVersion', dataSrc.deviceVersion);
            this.http
                .post(this.URL, null, {
                params: urlSearchParams,
                headers
            })
                .subscribe(() => {
                this.logger.info('SUCCESS: Feedback sent');
                return resolve();
            }, err => {
                this.logger.info('ERROR: Feedback sent anyway.');
                return reject(err);
            });
        });
    }
    isVersionUpdated(currentVersion, savedVersion) {
        let verifyTagFormat = tag => {
            let regex = /^v?\d+\.\d+\.\d+$/i;
            return regex.exec(tag);
        };
        let formatTagNumber = tag => {
            let formattedNumber = tag.replace(/^v/i, '').split('.');
            return {
                major: +formattedNumber[0],
                minor: +formattedNumber[1],
                patch: +formattedNumber[2]
            };
        };
        if (!verifyTagFormat(currentVersion)) {
            return 'Cannot verify the format of version tag: ' + currentVersion;
        }
        if (!verifyTagFormat(savedVersion)) {
            return ('Cannot verify the format of the saved version tag: ' + savedVersion);
        }
        let current = formatTagNumber(currentVersion);
        let saved = formatTagNumber(savedVersion);
        if (saved.major == current.major && saved.minor == current.minor) {
            return true;
        }
        return false;
    }
};
FeedbackProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__providers_app_app__["a" /* AppProvider */]])
], FeedbackProvider);

//# sourceMappingURL=feedback.js.map

/***/ }),

/***/ 254:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_bwc_bwc__ = __webpack_require__(39);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

// Providers

let AddressProvider = class AddressProvider {
    constructor(bwcProvider) {
        this.bwcProvider = bwcProvider;
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.Bitcore = {
            btc: {
                lib: this.bitcore,
                translateTo: 'bch'
            },
            bch: {
                lib: this.bitcoreCash,
                translateTo: 'btc'
            }
        };
    }
    getCoin(address) {
        try {
            new this.Bitcore['btc'].lib.Address(address);
            return 'btc';
        }
        catch (e) {
            try {
                new this.Bitcore['bch'].lib.Address(address);
                return 'bch';
            }
            catch (e) {
                return null;
            }
        }
    }
    translateAddress(address) {
        var origCoin = this.getCoin(address);
        if (!origCoin)
            return undefined;
        var origAddress = new this.Bitcore[origCoin].lib.Address(address);
        var origObj = origAddress.toObject();
        var resultCoin = this.Bitcore[origCoin].translateTo;
        var resultAddress = this.Bitcore[resultCoin].lib.Address.fromObject(origObj);
        return {
            origCoin,
            origAddress: address,
            resultCoin,
            resultAddress: resultAddress.toString()
        };
    }
    validateAddress(address) {
        let Address = this.bitcore.Address;
        let AddressCash = this.bitcoreCash.Address;
        let isLivenet = Address.isValid(address, 'livenet');
        let isTestnet = Address.isValid(address, 'testnet');
        let isLivenetCash = AddressCash.isValid(address, 'livenet');
        let isTestnetCash = AddressCash.isValid(address, 'testnet');
        return {
            address,
            isValid: isLivenet || isTestnet || isLivenetCash || isTestnetCash,
            network: isTestnet || isTestnetCash ? 'testnet' : 'livenet',
            coin: this.getCoin(address),
            translation: this.translateAddress(address)
        };
    }
};
AddressProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_bwc_bwc__["a" /* BwcProvider */]])
], AddressProvider);

//# sourceMappingURL=address.js.map

/***/ }),

/***/ 255:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PaperWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// pages

// providers









let PaperWalletPage = class PaperWalletPage {
    constructor(navCtrl, navParams, bwcProvider, onGoingProcessProvider, popupProvider, logger, walletProvider, feeProvider, profileProvider, events, modalCtrl, translate, platformProvider, bwcErrorProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.bwcProvider = bwcProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.feeProvider = feeProvider;
        this.profileProvider = profileProvider;
        this.events = events;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.balances = [];
        this.bitcore = this.bwcProvider.getBitcore();
        this.isCordova = this.platformProvider.isCordova;
        this.isOpenSelector = false;
        this.scannedKey = this.navParams.data.privateKey;
        this.isPkEncrypted = this.scannedKey
            ? this.scannedKey.substring(0, 2) == '6P'
            : null;
        this.error = false;
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: 'livenet'
        });
        this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.wallets), wallet => {
            return !wallet.needsBackup;
        });
        this.coins = __WEBPACK_IMPORTED_MODULE_3_lodash__["uniq"](__WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.wallets, (wallet) => wallet.coin));
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
    }
    ionViewDidEnter() {
        if (!this.wallets || !this.wallets.length) {
            this.noMatchingWallet = true;
            return;
        }
        this.wallet = this.wallets[0];
        if (!this.wallet)
            return;
        if (!this.isPkEncrypted)
            this.scanFunds();
        else {
            let message = this.translate.instant('Private key encrypted. Enter password');
            let opts = {
                type: 'password',
                enableBackdropDismiss: false
            };
            this.popupProvider.ionicPrompt(null, message, opts).then(res => {
                this.passphrase = res;
                setTimeout(() => {
                    this.scanFunds();
                }, 200);
            });
        }
    }
    getPrivateKey(scannedKey, privateKeyIsEncrypted, passphrase, cb) {
        if (!privateKeyIsEncrypted) {
            return cb(null, scannedKey);
        }
        this.wallet.decryptBIP38PrivateKey(scannedKey, passphrase, null, cb);
    }
    getBalance(privateKey, coin, cb) {
        this.wallet.getBalanceFromPrivateKey(privateKey, coin, cb);
    }
    checkPrivateKey(privateKey) {
        try {
            new this.bitcore.PrivateKey(privateKey, 'livenet');
        }
        catch (err) {
            return false;
        }
        return true;
    }
    _scanFunds(coin) {
        return new Promise((resolve, reject) => {
            this.getPrivateKey(this.scannedKey, this.isPkEncrypted, this.passphrase, (err, privateKey) => {
                if (err)
                    return reject(err);
                if (!this.checkPrivateKey(privateKey))
                    return reject(new Error('Invalid private key'));
                this.getBalance(privateKey, coin, (err, balance) => {
                    if (err)
                        return reject(err);
                    return resolve({ privateKey, coin, balance });
                });
            });
        });
    }
    scanFunds() {
        this.onGoingProcessProvider.set('scanning');
        let scans = __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.coins, (coin) => this._scanFunds(coin));
        Promise.all(scans)
            .then(data => {
            this.onGoingProcessProvider.clear();
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](data, d => {
                this.balances.push(d);
            });
            let available = {};
            this.balances = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.balances), b => {
                let nonzero = b.balance > 0;
                available[b.coin] = nonzero;
                return nonzero;
            });
            this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](this.wallets), w => available[w.coin]);
            this.wallet = this.wallets[0];
            if (this.balances.length == 0) {
                this.popupProvider.ionicAlert('Error', this.translate.instant('No funds found'));
                this.navCtrl.pop();
            }
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider.ionicAlert(this.translate.instant('Error scanning funds:'), this.bwcErrorProvider.msg(err));
            this.navCtrl.pop();
        });
    }
    _sweepWallet() {
        return new Promise((resolve, reject) => {
            let balanceToSweep = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.balances, b => {
                return b.coin === this.wallet.coin;
            })[0];
            this.walletProvider
                .getAddress(this.wallet, true)
                .then((destinationAddress) => {
                let opts = {};
                opts.coin = balanceToSweep.coin;
                this.wallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, testTx) => {
                    if (err)
                        return reject(err);
                    let rawTxLength = testTx.serialize().length;
                    this.feeProvider
                        .getCurrentFeeRate(balanceToSweep.coin, 'livenet')
                        .then((feePerKb) => {
                        opts.fee = Math.round((feePerKb * rawTxLength) / 2000);
                        this.wallet.buildTxFromPrivateKey(balanceToSweep.privateKey, destinationAddress, opts, (err, tx) => {
                            if (err)
                                return reject(err);
                            this.wallet.broadcastRawTx({
                                rawTx: tx.serialize(),
                                network: 'livenet',
                                coin: balanceToSweep.coin
                            }, (err, txid) => {
                                if (err)
                                    return reject(err);
                                return resolve({ destinationAddress, txid });
                            });
                        });
                    });
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    sweepWallet() {
        this.onGoingProcessProvider.set('sweepingWallet');
        this._sweepWallet()
            .then(data => {
            this.onGoingProcessProvider.clear();
            this.logger.debug('Success sweep. Destination address:' +
                data.destinationAddress +
                ' - transaction id: ' +
                data.txid);
            this.openFinishModal();
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
            this.popupProvider.ionicAlert(this.translate.instant('Error sweeping wallet:'), this.bwcErrorProvider.msg(err));
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Transfer to');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishComment = this.translate.instant('Check the transaction on your wallet details');
        let finishText = this.translate.instant('Sweep Completed');
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => {
            this.navCtrl.pop();
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], PaperWalletPage.prototype, "slideButton", void 0);
PaperWalletPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-paper-wallet',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/paper-wallet/paper-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Sweep paper wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="message" *ngIf="noMatchingWallet">\n    <span translate>No wallets available to receive funds</span>\n  </div>\n  <div *ngIf="!noMatchingWallet">\n    <h4 class="title">\n      <span translate>Funds found</span>:\n      <span *ngFor="let b of balances">\n        {{b.balance | satToUnit: b.coin}}\n      </span>\n      <span *ngIf="balances.length == 0">...</span>\n    </h4>\n    <ion-item-divider>{{\'Funds will be transferred to\' | translate}}</ion-item-divider>\n    <button ion-item *ngIf="wallet" detail-none (click)="showWallets()">\n      <ion-icon item-start>\n        <img src="assets/img/icon-wallet.svg" class="icon-wallet" />\n      </ion-icon>\n      <h2>{{wallet.name}}\n        <span *ngIf="wallet.credentials.m > 1">{{wallet.credentials.m}}-{{wallet.credentials.n}}</span>\n      </h2>\n      <span *ngIf="!wallet.balanceHidden"> {{wallet.status.totalBalanceStr}} </span>\n      <span *ngIf="wallet.balanceHidden" translate>[Balance Hidden]</span>\n      <span class="assertive" *ngIf="error">{{error}}</span>\n      <div item-end>\n        <button ion-button clear color="grey" icon-only>\n          <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n          <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n        </button>\n      </div>\n    </button>\n  </div>\n</ion-content>\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="sending || balances.length == 0 || noMatchingWallet" buttonText="{{\'Sweep\' | translate}}" (slideDone)="sweepWallet()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button block class="button-footer" (click)="sweepWallet()" [disabled]="sending || balances.length == 0 || noMatchingWallet">\n      {{\'Sweep\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/paper-wallet/paper-wallet.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */]])
], PaperWalletPage);

//# sourceMappingURL=paper-wallet.js.map

/***/ }),

/***/ 256:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackCompletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// native

// providers






let FeedbackCompletePage = class FeedbackCompletePage {
    constructor(navCtrl, navParams, viewCtrl, logger, platformProvider, persistenceProvider, socialSharing, appProvider, configProvider, replaceParametersProvider, translate, popupProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.persistenceProvider = persistenceProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.score = this.navParams.data.score;
        this.skipped = this.navParams.data.skipped;
        this.rated = this.navParams.data.rated;
        this.fromSettings = this.navParams.data.fromSettings;
        this.isCordova = this.platformProvider.isCordova;
        this.title = this.replaceParametersProvider.replace(this.translate.instant('Share {{appName}}'), { appName: this.appProvider.info.nameCase });
        let defaults = this.configProvider.getDefaults();
        this.downloadUrl =
            this.appProvider.info.name == 'Sqoin'
                ? defaults.download.copay.url
                : defaults.download.bitpay.url;
    }
    ionViewWillLeave() {
        if (!this.fromSettings) {
            this.navCtrl.swipeBackEnabled = true;
        }
    }
    ionViewWillEnter() {
        if (!this.fromSettings) {
            this.viewCtrl.showBackButton(false);
            this.navCtrl.swipeBackEnabled = false;
        }
        this.persistenceProvider.getFeedbackInfo().then(info => {
            let feedbackInfo = info;
            feedbackInfo.sent = true;
            this.persistenceProvider.setFeedbackInfo(feedbackInfo);
        });
        if (!this.isCordova)
            return;
        this.socialSharing
            .canShareVia('com.apple.social.facebook', 'msg', null, null, null)
            .then(() => {
            this.shareFacebookVia = 'com.apple.social.facebook';
            this.facebook = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.facebook.katana', 'msg', null, null, null)
                .then(() => {
                this.shareFacebookVia = 'com.facebook.katana';
                this.facebook = true;
            })
                .catch(e => {
                this.logger.debug('facebook error: ' + e);
                this.facebook = false;
            });
        });
        this.socialSharing
            .canShareVia('com.apple.social.twitter', 'msg', null, null, null)
            .then(() => {
            this.shareTwitterVia = 'com.apple.social.twitter';
            this.twitter = true;
        })
            .catch(() => {
            this.socialSharing
                .canShareVia('com.twitter.android', 'msg', null, null, null)
                .then(() => {
                this.shareTwitterVia = 'com.twitter.android';
                this.twitter = true;
            })
                .catch(e => {
                this.logger.debug('twitter error: ' + e);
                this.twitter = false;
            });
        });
        this.socialSharing
            .canShareVia('whatsapp', 'msg', null, null, null)
            .then(() => {
            this.whatsapp = true;
        })
            .catch(e => {
            this.logger.debug('whatsapp error: ' + e);
            this.whatsapp = false;
        });
    }
    shareFacebook() {
        if (!this.facebook) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareFacebookVia, null, null, null, this.downloadUrl);
    }
    shareTwitter() {
        if (!this.twitter) {
            this.showError();
            return;
        }
        this.socialSharing.shareVia(this.shareTwitterVia, null, null, null, this.downloadUrl);
    }
    shareWhatsapp() {
        if (!this.whatsapp) {
            this.showError();
            return;
        }
        this.socialSharing.shareViaWhatsApp(this.downloadUrl);
    }
    showError() {
        let msg = this.translate.instant('This app is not available for your device.');
        this.popupProvider.ionicAlert(this.translate.instant('Error'), msg);
    }
    close() {
        this.navCtrl.popToRoot({ animate: false });
    }
};
FeedbackCompletePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-feedback-complete',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/feedback/feedback-complete/feedback-complete.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title}}</ion-title>\n    <ion-buttons right>\n      <button ion-button clear *ngIf="!fromSettings" (click)="close()">\n        <span translate>Finish</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <div class="share-image-container" *ngIf="fromSettings">\n    <div>\n      <div class="share-the-love">\n        <img src="assets/img/ico-positive-feedback.svg" class="share-the-love-illustration" />\n      </div>\n      <div class="subtitle" translate>Share the love by inviting your friends.</div>\n    </div>\n  </div>\n  <div *ngIf="!fromSettings">\n    <div class="feedback-title" translate>Thank you!</div>\n    <div class="subtitle" *ngIf="!skipped || !fromSettings" translate>A member of the team will review your feedback as soon as possible.</div>\n    <div *ngIf="score <= 3 || !isCordova">\n      <div class="subtitle" translate>If you have additional feedback, please let us know by tapping the "Send feedback" option in the Settings tab.</div>\n      <div class="illustration-send">\n        <img src="assets/img/illustration-send-feedback.png" />\n      </div>\n    </div>\n    <div class="share-image-container" *ngIf="score > 3 && isCordova">\n      <div>\n        <div class="share-the-love">\n          <img src="assets/img/ico-positive-feedback.svg" class="share-the-love-illustration" />\n        </div>\n        <div class="subtitle" translate>Share the love by inviting your friends.</div>\n      </div>\n    </div>\n  </div>\n  <div class="share-buttons" *ngIf="(score > 3 || fromSettings) && isCordova">\n    <div class="share-buttons__action" (click)="shareFacebook()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-facebook.svg" />\n      </ion-icon>\n      <div class="name">Facebook</div>\n    </div>\n    <div class="share-buttons__action" (click)="shareTwitter()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-twitter.svg" />\n      </ion-icon>\n      <div class="name">Twitter</div>\n    </div>\n    <div class="share-buttons__action" (click)="shareWhatsapp()">\n      <ion-icon>\n        <img src="assets/img/social-icons/ico-social-whatsapp.svg" />\n      </ion-icon>\n      <div class="name">Whatsapp</div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/feedback/feedback-complete/feedback-complete.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */]])
], FeedbackCompletePage);

//# sourceMappingURL=feedback-complete.js.map

/***/ }),

/***/ 257:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendFeedbackPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_feedback_feedback__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__feedback_complete_feedback_complete__ = __webpack_require__(256);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// native

// providers







// pages

let SendFeedbackPage = class SendFeedbackPage {
    constructor(configProvider, navCtrl, navParams, appProvider, onGoingProcessProvider, feedbackProvider, formBuilder, persistenceProvider, popupProvider, translate, device, replaceParametersProvider) {
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.appProvider = appProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.feedbackProvider = feedbackProvider;
        this.formBuilder = formBuilder;
        this.persistenceProvider = persistenceProvider;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.device = device;
        this.replaceParametersProvider = replaceParametersProvider;
        this.feedbackForm = this.formBuilder.group({
            comment: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required])
            ]
        });
        this.score = this.navParams.data.score;
        this.appName = this.appProvider.info.nameCase;
    }
    ionViewWillEnter() {
        this.navBar.backButtonClick = () => {
            this.persistenceProvider.getFeedbackInfo().then(info => {
                let feedbackInfo = info;
                feedbackInfo.sent = false;
                this.persistenceProvider.setFeedbackInfo(feedbackInfo);
                this.navCtrl.pop();
            });
        };
        switch (this.score) {
            case 1:
                this.reaction = this.translate.instant('Ouch!');
                this.comment = this.translate.instant("There's obviously something we're doing wrong. How could we improve your experience?");
                break;
            case 2:
                this.reaction = this.translate.instant('Oh no!');
                this.comment = this.translate.instant("There's obviously something we're doing wrong. How could we improve your experience?");
                break;
            case 3:
                this.reaction = 'Hmm...';
                this.comment = this.translate.instant("We'd love to do better. How could we improve your experience?");
                break;
            case 4:
                this.reaction = this.translate.instant('Thanks!');
                this.comment = this.translate.instant("That's exciting to hear. We'd love to earn that fifth star from you  how could we improve your experience?");
                break;
            case 5:
                this.reaction = this.translate.instant('Thank you!');
                this.comment = this.replaceParametersProvider.replace(this.translate.instant("We're always looking for ways to improve {{appName}}. Is there anything we could do better?"), { appName: this.appName });
                break;
            default:
                this.justFeedback = true;
                this.comment = this.replaceParametersProvider.replace(this.translate.instant("We're always looking for ways to improve {{appName}}. How could we improve your experience?"), { appName: this.appName });
                break;
        }
    }
    sendFeedback(feedback, goHome) {
        let config = this.configProvider.get();
        let platform = this.device.platform || 'Unknown platform';
        let version = this.device.version || 'Unknown version';
        let dataSrc = {
            email: __WEBPACK_IMPORTED_MODULE_4_lodash__["values"](config.emailFor)[0] || ' ',
            feedback: goHome ? ' ' : feedback,
            score: this.score || ' ',
            appVersion: this.appProvider.info.version,
            platform,
            deviceVersion: version
        };
        if (!goHome)
            this.onGoingProcessProvider.set('sendingFeedback');
        this.feedbackProvider
            .send(dataSrc)
            .then(() => {
            if (goHome)
                return;
            this.onGoingProcessProvider.clear();
            if (!this.score) {
                let title = this.translate.instant('Thank you!');
                let message = this.translate.instant('A member of the team will review your feedback as soon as possible.');
                let okText = this.translate.instant('Finish');
                this.popupProvider.ionicAlert(title, message, okText).then(() => {
                    this.feedback = '';
                    this.navCtrl.popToRoot({ animate: false });
                });
            }
            else {
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__feedback_complete_feedback_complete__["a" /* FeedbackCompletePage */], { score: this.score });
            }
        })
            .catch(() => {
            if (goHome)
                return;
            this.onGoingProcessProvider.clear();
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Feedback could not be submitted. Please try again later.');
            this.popupProvider.ionicAlert(title, subtitle);
        });
        if (goHome) {
            this.navCtrl.popToRoot({ animate: false });
        }
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* Navbar */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["m" /* Navbar */])
], SendFeedbackPage.prototype, "navBar", void 0);
SendFeedbackPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-send-feedback',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/feedback/send-feedback/send-feedback.html"*/'<ion-header>\n  <ion-navbar #navBar>\n    <ion-title>{{\'Send Feedback\'|translate}}</ion-title>\n    <ion-buttons left>\n      <button ion-button clear *ngIf="score" (click)="sendFeedback(null, true)">\n        <span translate>Cancel</span>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <ion-row>\n    <ion-col>\n      <div class="feedback-title" *ngIf="!justFeedback">\n        <span>{{reaction}}</span>\n      </div>\n    </ion-col>\n    <ion-col class="rating" *ngIf="score">\n      <img class="send-feedback-star" *ngIf="1 <= score" src="assets/img/ico-star-filled.svg" />\n      <img class="send-feedback-star" *ngIf="1 > score" src="assets/img/ico-star.svg" />\n      <img class="send-feedback-star" *ngIf="2 <= score" src="assets/img/ico-star-filled.svg" />\n      <img class="send-feedback-star" *ngIf="2 > score" src="assets/img/ico-star.svg" />\n      <img class="send-feedback-star" *ngIf="3 <= score" src="assets/img/ico-star-filled.svg" />\n      <img class="send-feedback-star" *ngIf="3 > score" src="assets/img/ico-star.svg" />\n      <img class="send-feedback-star" *ngIf="4 <= score" src="assets/img/ico-star-filled.svg" />\n      <img class="send-feedback-star" *ngIf="4 > score" src="assets/img/ico-star.svg" />\n      <img class="send-feedback-star" *ngIf="5 ==  score" src="assets/img/ico-star-filled.svg" />\n      <img class="send-feedback-star" *ngIf="5 > score" src="assets/img/ico-star.svg" />\n    </ion-col>\n  </ion-row>\n  <ion-item-divider>\n    <span>{{comment}}</span>\n  </ion-item-divider>\n  <form [formGroup]="feedbackForm">\n    <ion-textarea type="text" formControlName="comment" placeholder="{{\'Your ideas, feedback, or comments\' | translate}}" [value]="feedbackForm.value.comment" required padding></ion-textarea>\n  </form>\n\n  <button ion-button class="button-standard" (click)="sendFeedback(feedbackForm.value.comment)" [disabled]="!feedbackForm.valid">\n    {{\'Send\' | translate}}\n  </button>\n\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/feedback/send-feedback/send-feedback.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_10__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_12__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */]])
], SendFeedbackPage);

//# sourceMappingURL=send-feedback.js.map

/***/ }),

/***/ 258:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PinModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_status_bar__ = __webpack_require__(331);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_vibration__ = __webpack_require__(830);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};








let PinModalPage = class PinModalPage {
    constructor(configProvider, logger, platform, navCtrl, navParams, persistenceProvider, statusBar, vibration, viewCtrl) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.platform = platform;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.persistenceProvider = persistenceProvider;
        this.statusBar = statusBar;
        this.vibration = vibration;
        this.viewCtrl = viewCtrl;
        this.ATTEMPT_LIMIT = 3;
        this.ATTEMPT_LOCK_OUT_TIME = 5 * 60;
        this.currentAttempts = 0;
        this.currentPin = '';
        this.firstPinEntered = '';
        this.confirmingPin = false;
        this.action = '';
        this.disableButtons = false;
        this.expires = '';
        this.incorrect = false;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.action = this.navParams.get('action');
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            this.persistenceProvider.getLockStatus().then((isLocked) => {
                if (!isLocked)
                    return;
                if (this.action === 'checkPin') {
                    this.showLockTimer();
                    this.setLockRelease();
                }
            });
        }
    }
    ionViewWillEnter() {
        if (this.platform.is('ios')) {
            this.statusBar.styleDefault();
        }
    }
    ionViewWillLeave() {
        if (this.platform.is('ios')) {
            this.statusBar.styleLightContent();
        }
    }
    close(cancelClicked) {
        if (this.countDown) {
            clearInterval(this.countDown);
        }
        this.unregister();
        if (this.action === 'lockSetUp')
            this.viewCtrl.dismiss(cancelClicked);
        else
            this.navCtrl.pop({ animate: true });
    }
    newEntry(value) {
        if (this.disableButtons)
            return;
        if (value === 'delete') {
            return this.delete();
        }
        this.incorrect = false;
        this.currentPin = this.currentPin + value;
        if (!this.isComplete())
            return;
        if (this.action === 'checkPin' || this.action === 'lockSetUp') {
            setTimeout(() => {
                this.checkIfCorrect();
            }, 100);
        }
        if (this.action === 'pinSetUp') {
            setTimeout(() => {
                if (!this.confirmingPin) {
                    this.confirmingPin = true;
                    this.firstPinEntered = this.currentPin;
                    this.currentPin = '';
                }
                else if (this.firstPinEntered === this.currentPin)
                    this.save();
                else {
                    this.firstPinEntered = this.currentPin = '';
                    this.incorrect = true;
                    this.confirmingPin = false;
                    this.shakeCode();
                }
            }, 100);
        }
    }
    checkAttempts() {
        this.currentAttempts += 1;
        this.logger.info('Attempts to unlock:', this.currentAttempts);
        this.incorrect = true;
        if (this.currentAttempts == this.ATTEMPT_LIMIT &&
            this.action !== 'lockSetUp') {
            this.currentAttempts = 0;
            this.persistenceProvider.setLockStatus('locked');
            this.showLockTimer();
            this.setLockRelease();
        }
    }
    showLockTimer() {
        this.disableButtons = true;
        let bannedUntil = Math.floor(Date.now() / 1000) + this.ATTEMPT_LOCK_OUT_TIME;
        this.countDown = setInterval(() => {
            let now = Math.floor(Date.now() / 1000);
            let totalSecs = bannedUntil - now;
            let m = Math.floor(totalSecs / 60);
            let s = totalSecs % 60;
            this.expires = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
        }, 1000);
    }
    setLockRelease() {
        setTimeout(() => {
            clearInterval(this.countDown);
            this.unlock();
        }, this.ATTEMPT_LOCK_OUT_TIME * 1000);
    }
    unlock() {
        this.expires = this.disableButtons = null;
        this.currentPin = this.firstPinEntered = '';
        this.persistenceProvider.removeLockStatus();
    }
    delete() {
        if (this.disableButtons)
            return;
        this.currentPin = this.currentPin.substring(0, this.currentPin.length - 1);
    }
    isComplete() {
        if (this.currentPin.length < 4)
            return false;
        else
            return true;
    }
    save() {
        let lock = { method: 'pin', value: this.currentPin, bannedUntil: null };
        this.configProvider.set({ lock });
        this.close();
    }
    checkIfCorrect() {
        let config = this.configProvider.get();
        let pinValue = config.lock && config.lock.value;
        if (pinValue == this.currentPin) {
            if (this.action === 'checkPin' || this.action === 'lockSetUp') {
                this.close();
            }
        }
        else {
            this.currentPin = '';
            this.checkAttempts();
            this.shakeCode();
        }
    }
    shakeCode() {
        this.pinCode.animate('shake');
        this.vibration.vibrate(100);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__["a" /* Animate */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_4__directives_animate_animate__["a" /* Animate */])
], PinModalPage.prototype, "pinCode", void 0);
PinModalPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-pin',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/pin/pin-modal/pin-modal.html"*/'<ion-header>\n  <ion-navbar transparent>\n    <ion-buttons right>\n      <button (click)="close(true)" ion-button color="primary" *ngIf="action === \'pinSetUp\' || action === \'lockSetUp\'">\n        {{\'Cancel\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce fullscreen>\n  <div class="pin-header">\n    <div class="title">\n      <div *ngIf="!disableButtons">\n        <span class="message" *ngIf="!confirmingPin && !incorrect" translate>Please enter your PIN</span>\n        <span class="message" *ngIf="confirmingPin && !incorrect" translate>Confirm your PIN</span>\n        <span class="message" *ngIf="incorrect" translate>Incorrect PIN, try again.</span>\n      </div>\n      <div *ngIf="disableButtons">\n        <span class="message" *ngIf="expires" translate>Try again in {{expires}}</span>\n      </div>\n    </div>\n    <div class="icon-container">\n      <ion-icon class="app-icon">\n        <img src="assets/img/app/icon-flat.svg" />\n      </ion-icon>\n    </div>\n  </div>\n  <div class="code-wrapper">\n    <pin-dots [pin]="currentPin" animate></pin-dots>\n    <pin-pad (keystroke)="newEntry($event)"></pin-pad>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/pin/pin-modal/pin-modal.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["n" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ionic_native_status_bar__["a" /* StatusBar */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_vibration__["a" /* Vibration */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["q" /* ViewController */]])
], PinModalPage);

//# sourceMappingURL=pin-modal.js.map

/***/ }),

/***/ 27:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_language_language__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



// providers




/* TODO: implement interface properly
interface App {
  packageName: string;
  packageDescription: string;
  packageNameId: string;
  themeColor: string;
  userVisibleName: string;
  purposeLine: string;
  bundleName: string;
  appUri: string;
  name: string;
  nameNoSpace: string;
  nameCase: string;
  nameCaseNoSpace: string;
  gitHubRepoName: string;
  gitHubRepoUrl: string;
  gitHubRepoBugs: string;
  disclaimerUrl: string;
  url: string;
  appDescription: string;
  winAppName: string;
  WindowsStoreIdentityName: string;
  WindowsStoreDisplayName: string;
  windowsAppId: string;
  pushSenderId: string;
  description: string;
  version: string;
  androidVersion: string;
  commitHash: string;
  _extraCSS: string;
  _enabledExtensions;
}*/
let AppProvider = class AppProvider {
    constructor(http, logger, language, config, persistence, platformProvider) {
        this.http = http;
        this.logger = logger;
        this.language = language;
        this.config = config;
        this.persistence = persistence;
        this.platformProvider = platformProvider;
        this.info = {};
        this.jsonPathApp = 'assets/appConfig.json';
        this.jsonPathServices = 'assets/externalServices.json';
        this.logger.info('AppProvider initialized.');
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield Promise.all([this.getInfo(), this.loadProviders()]);
            this.setCustomMenuBarNW();
        });
    }
    getInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            [this.servicesInfo, this.info] = yield Promise.all([
                this.getServicesInfo(),
                this.getAppInfo()
            ]);
        });
    }
    loadProviders() {
        return __awaiter(this, void 0, void 0, function* () {
            this.persistence.load();
            yield this.config.load();
            this.language.load();
        });
    }
    getAppInfo() {
        return this.http.get(this.jsonPathApp).toPromise();
    }
    getServicesInfo() {
        return this.http.get(this.jsonPathServices).toPromise();
    }
    setCustomMenuBarNW() {
        if (!this.platformProvider.isNW) {
            return;
        }
        let gui = window.require('nw.gui');
        let win = gui.Window.get();
        let nativeMenuBar = new gui.Menu({
            type: 'menubar'
        });
        try {
            nativeMenuBar.createMacBuiltin(this.info.nameCase);
        }
        catch (e) {
            this.logger.debug('This is not OSX');
        }
        win.menu = nativeMenuBar;
    }
};
AppProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__["a" /* PlatformProvider */]])
], AppProvider);

//# sourceMappingURL=app.js.map

/***/ }),

/***/ 29:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PersistenceProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__ = __webpack_require__(332);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__storage_file_storage__ = __webpack_require__(1008);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__storage_local_storage__ = __webpack_require__(1009);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







const Keys = {
    ADDRESS_BOOK: network => 'addressbook-' + network,
    AGREE_DISCLAIMER: 'agreeDisclaimer',
    AMAZON_GIFT_CARDS: network => 'amazonGiftCards-' + network,
    APP_IDENTITY: network => 'appIdentity-' + network,
    BACKUP: walletId => 'backup-' + walletId,
    BALANCE_CACHE: cardId => 'balanceCache-' + cardId,
    BITPAY_ACCOUNTS_V2: network => 'bitpayAccounts-v2-' + network,
    CLEAN_AND_SCAN_ADDRESSES: 'CleanAndScanAddresses',
    COINBASE_REFRESH_TOKEN: network => 'coinbaseRefreshToken-' + network,
    COINBASE_TOKEN: network => 'coinbaseToken-' + network,
    COINBASE_TXS: network => 'coinbaseTxs-' + network,
    CONFIG: 'config',
    FEEDBACK: 'feedback',
    FOCUSED_WALLET_ID: 'focusedWalletId',
    GLIDERA_PERMISSIONS: network => 'glideraPermissions-' + network,
    GLIDERA_STATUS: network => 'glideraStatus-' + network,
    GLIDERA_TOKEN: network => 'glideraToken-' + network,
    GLIDERA_TXS: network => 'glideraTxs-' + network,
    HIDE_BALANCE: walletId => 'hideBalance-' + walletId,
    HOME_TIP: 'homeTip',
    LAST_ADDRESS: walletId => 'lastAddress-' + walletId,
    LAST_CURRENCY_USED: 'lastCurrencyUsed',
    MERCADO_LIBRE: network => 'MercadoLibreGiftCards-' + network,
    ONBOARDING_COMPLETED: 'onboardingCompleted',
    PROFILE: 'profile',
    REMOTE_PREF_STORED: 'remotePrefStored',
    TX_CONFIRM_NOTIF: txid => 'txConfirmNotif-' + txid,
    TX_HISTORY: walletId => 'txsHistory-' + walletId,
    ORDER_WALLET: walletId => 'order-' + walletId
};
let PersistenceProvider = class PersistenceProvider {
    constructor(logger, platform, file) {
        this.logger = logger;
        this.platform = platform;
        this.file = file;
        this.logger.info('PersistenceProvider initialized.');
    }
    load() {
        this.storage = this.platform.isCordova
            ? new __WEBPACK_IMPORTED_MODULE_5__storage_file_storage__["a" /* FileStorage */](this.file, this.logger)
            : new __WEBPACK_IMPORTED_MODULE_6__storage_local_storage__["a" /* LocalStorage */](this.platform, this.logger);
    }
    storeNewProfile(profile) {
        return this.storage.create(Keys.PROFILE, profile);
    }
    storeProfile(profile) {
        return this.storage.set(Keys.PROFILE, profile);
    }
    getProfile() {
        return new Promise(resolve => {
            this.storage.get(Keys.PROFILE).then(profile => {
                resolve(profile);
            });
        });
    }
    deleteProfile() {
        return this.storage.remove(Keys.PROFILE);
    }
    setFeedbackInfo(feedbackValues) {
        return this.storage.set(Keys.FEEDBACK, feedbackValues);
    }
    getFeedbackInfo() {
        return this.storage.get(Keys.FEEDBACK);
    }
    storeFocusedWalletId(walletId) {
        return this.storage.set(Keys.FOCUSED_WALLET_ID, walletId || '');
    }
    getFocusedWalletId() {
        return this.storage.get(Keys.FOCUSED_WALLET_ID);
    }
    getLastAddress(walletId) {
        return this.storage.get(Keys.LAST_ADDRESS(walletId));
    }
    storeLastAddress(walletId, address) {
        return this.storage.set(Keys.LAST_ADDRESS(walletId), address);
    }
    clearLastAddress(walletId) {
        return this.storage.remove(Keys.LAST_ADDRESS(walletId));
    }
    setBackupFlag(walletId) {
        return this.storage.set(Keys.BACKUP(walletId), Date.now());
    }
    getBackupFlag(walletId) {
        return this.storage.get(Keys.BACKUP(walletId));
    }
    clearBackupFlag(walletId) {
        return this.storage.remove(Keys.BACKUP(walletId));
    }
    setCleanAndScanAddresses(walletId) {
        return this.storage.set(Keys.CLEAN_AND_SCAN_ADDRESSES, walletId);
    }
    getCleanAndScanAddresses() {
        return this.storage.get(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    removeCleanAndScanAddresses() {
        return this.storage.remove(Keys.CLEAN_AND_SCAN_ADDRESSES);
    }
    getConfig() {
        return this.storage.get(Keys.CONFIG);
    }
    storeConfig(config) {
        return this.storage.set(Keys.CONFIG, config);
    }
    clearConfig() {
        return this.storage.remove(Keys.CONFIG);
    }
    getHomeTipAccepted() {
        return this.storage.get(Keys.HOME_TIP);
    }
    setHomeTipAccepted(homeTip) {
        return this.storage.set(Keys.HOME_TIP, homeTip);
    }
    setHideBalanceFlag(walletId, val) {
        return this.storage.set(Keys.HIDE_BALANCE(walletId), val);
    }
    getHideBalanceFlag(walletId) {
        return this.storage.get(Keys.HIDE_BALANCE(walletId));
    }
    setDisclaimerAccepted() {
        return this.storage.set(Keys.AGREE_DISCLAIMER, true);
    }
    setOnboardingCompleted() {
        return this.storage.set(Keys.ONBOARDING_COMPLETED, true);
    }
    // for compatibility
    getCopayDisclaimerFlag() {
        return this.storage.get(Keys.AGREE_DISCLAIMER);
    }
    getCopayOnboardingFlag() {
        return this.storage.get(Keys.ONBOARDING_COMPLETED);
    }
    setRemotePrefsStoredFlag() {
        return this.storage.set(Keys.REMOTE_PREF_STORED, true);
    }
    getRemotePrefsStoredFlag() {
        return this.storage.get(Keys.REMOTE_PREF_STORED);
    }
    setGlideraToken(network, token) {
        return this.storage.set(Keys.GLIDERA_TOKEN(network), token);
    }
    getGlideraToken(network) {
        return this.storage.get(Keys.GLIDERA_TOKEN(network));
    }
    removeGlideraToken(network) {
        return this.storage.remove(Keys.GLIDERA_TOKEN(network));
    }
    setGlideraPermissions(network, permissions) {
        return this.storage.set(Keys.GLIDERA_PERMISSIONS(network), permissions);
    }
    getGlideraPermissions(network) {
        return this.storage.get(Keys.GLIDERA_PERMISSIONS(network));
    }
    removeGlideraPermissions(network) {
        return this.storage.remove(Keys.GLIDERA_PERMISSIONS(network));
    }
    setGlideraStatus(network, status) {
        return this.storage.set(Keys.GLIDERA_STATUS(network), status);
    }
    getGlideraStatus(network) {
        return this.storage.get(Keys.GLIDERA_STATUS(network));
    }
    removeGlideraStatus(network) {
        return this.storage.remove(Keys.GLIDERA_STATUS(network));
    }
    setGlideraTxs(network, txs) {
        return this.storage.set(Keys.GLIDERA_TXS(network), txs);
    }
    getGlideraTxs(network) {
        return this.storage.get(Keys.GLIDERA_TXS(network));
    }
    removeGlideraTxs(network) {
        return this.storage.remove(Keys.GLIDERA_TXS(network));
    }
    setCoinbaseToken(network, token) {
        return this.storage.set(Keys.COINBASE_TOKEN(network), token);
    }
    getCoinbaseToken(network) {
        return this.storage.get(Keys.COINBASE_TOKEN(network));
    }
    removeCoinbaseToken(network) {
        return this.storage.remove(Keys.COINBASE_TOKEN(network));
    }
    setCoinbaseRefreshToken(network, token) {
        return this.storage.set(Keys.COINBASE_REFRESH_TOKEN(network), token);
    }
    getCoinbaseRefreshToken(network) {
        return this.storage.get(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    removeCoinbaseRefreshToken(network) {
        return this.storage.remove(Keys.COINBASE_REFRESH_TOKEN(network));
    }
    setCoinbaseTxs(network, ctx) {
        return this.storage.set(Keys.COINBASE_TXS(network), ctx);
    }
    getCoinbaseTxs(network) {
        return this.storage.get(Keys.COINBASE_TXS(network));
    }
    removeCoinbaseTxs(network) {
        return this.storage.remove(Keys.COINBASE_TXS(network));
    }
    setAddressBook(network, addressbook) {
        return this.storage.set(Keys.ADDRESS_BOOK(network), addressbook);
    }
    getAddressBook(network) {
        return this.storage.get(Keys.ADDRESS_BOOK(network));
    }
    removeAddressbook(network) {
        return this.storage.remove(Keys.ADDRESS_BOOK(network));
    }
    setLastCurrencyUsed(lastCurrencyUsed) {
        return this.storage.set(Keys.LAST_CURRENCY_USED, lastCurrencyUsed);
    }
    getLastCurrencyUsed() {
        return this.storage.get(Keys.LAST_CURRENCY_USED);
    }
    checkQuota() {
        let block = '';
        // 50MB
        for (let i = 0; i < 1024 * 1024; ++i) {
            block += '12345678901234567890123456789012345678901234567890';
        }
        this.storage.set('test', block).catch(err => {
            this.logger.error('CheckQuota Return:' + err);
        });
    }
    setTxHistory(walletId, txs) {
        return this.storage.set(Keys.TX_HISTORY(walletId), txs).catch(err => {
            this.logger.error('Error saving tx History. Size:' + txs.length);
            this.logger.error(err);
        });
    }
    getTxHistory(walletId) {
        return this.storage.get(Keys.TX_HISTORY(walletId));
    }
    removeTxHistory(walletId) {
        return this.storage.remove(Keys.TX_HISTORY(walletId));
    }
    setBalanceCache(cardId, data) {
        return this.storage.set(Keys.BALANCE_CACHE(cardId), data);
    }
    getBalanceCache(cardId) {
        return this.storage.get(Keys.BALANCE_CACHE(cardId));
    }
    removeBalanceCache(cardId) {
        return this.storage.remove(Keys.BALANCE_CACHE(cardId));
    }
    setAppIdentity(network, data) {
        return this.storage.set(Keys.APP_IDENTITY(network), data);
    }
    getAppIdentity(network) {
        return this.storage.get(Keys.APP_IDENTITY(network));
    }
    removeAppIdentity(network) {
        return this.storage.remove(Keys.APP_IDENTITY(network));
    }
    removeAllWalletData(walletId) {
        return this.clearLastAddress(walletId)
            .then(() => this.removeTxHistory(walletId))
            .then(() => this.clearBackupFlag(walletId))
            .then(() => this.removeWalletOrder(walletId));
    }
    // Amazon Gift Cards
    setAmazonGiftCards(network, gcs) {
        return this.storage.set(Keys.AMAZON_GIFT_CARDS(network), gcs);
    }
    getAmazonGiftCards(network) {
        return this.storage.get(Keys.AMAZON_GIFT_CARDS(network));
    }
    removeAmazonGiftCards(network) {
        return this.storage.remove(Keys.AMAZON_GIFT_CARDS(network));
    }
    setTxConfirmNotification(txid, val) {
        return this.storage.set(Keys.TX_CONFIRM_NOTIF(txid), val);
    }
    getTxConfirmNotification(txid) {
        return this.storage.get(Keys.TX_CONFIRM_NOTIF(txid));
    }
    removeTxConfirmNotification(txid) {
        return this.storage.remove(Keys.TX_CONFIRM_NOTIF(txid));
    }
    getBitpayAccounts(network) {
        return this.storage.get(Keys.BITPAY_ACCOUNTS_V2(network));
    }
    setBitpayAccount(network, data) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            let account = allAccounts[data.email] || {};
            account.token = data.token;
            account.familyName = data.familyName;
            account.givenName = data.givenName;
            allAccounts[data.email] = account;
            this.logger.info('Storing BitPay accounts with new account:' + data.email);
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    removeBitpayAccount(network, email) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            delete allAccounts[email];
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    setBitpayDebitCards(network, email, cards) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            allAccounts = allAccounts || {};
            if (!allAccounts[email])
                throw new Error('Cannot set cards for unknown account ' + email);
            allAccounts[email].cards = cards;
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    // cards: [
    //   eid: card id
    //   id: card id
    //   lastFourDigits: card number
    //   token: card token
    //   email: account email
    // ]
    getBitpayDebitCards(network) {
        return this.getBitpayAccounts(network).then(allAccounts => {
            let allCards = [];
            __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](allAccounts, (account, email) => {
                if (account.cards) {
                    // Add account's email to each card
                    var cards = __WEBPACK_IMPORTED_MODULE_2_lodash__["clone"](account.cards);
                    __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](cards, x => {
                        x.email = email;
                    });
                    allCards = allCards.concat(cards);
                }
            });
            return allCards;
        });
    }
    removeBitpayDebitCard(network, cardEid) {
        return this.getBitpayAccounts(network)
            .then(allAccounts => {
            return __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](allAccounts, account => {
                account.cards = __WEBPACK_IMPORTED_MODULE_2_lodash__["reject"](account.cards, {
                    eid: cardEid
                });
            });
        })
            .then(allAccounts => {
            return this.storage.set(Keys.BITPAY_ACCOUNTS_V2(network), allAccounts);
        });
    }
    setMercadoLibreGiftCards(network, gcs) {
        return this.storage.set(Keys.MERCADO_LIBRE(network), gcs);
    }
    getMercadoLibreGiftCards(network) {
        return this.storage.get(Keys.MERCADO_LIBRE(network));
    }
    removeMercadoLibreGiftCards(network) {
        return this.storage.remove(Keys.MERCADO_LIBRE(network));
    }
    setShapeshift(network, gcs) {
        return this.storage.set('shapeShift-' + network, gcs);
    }
    getShapeshift(network) {
        return this.storage.get('shapeShift-' + network);
    }
    removeShapeshift(network) {
        return this.storage.remove('shapeShift-' + network);
    }
    setWalletOrder(walletId, order) {
        return this.storage.set(Keys.ORDER_WALLET(walletId), order);
    }
    getWalletOrder(walletId) {
        return this.storage.get(Keys.ORDER_WALLET(walletId));
    }
    removeWalletOrder(walletId) {
        return this.storage.remove(Keys.ORDER_WALLET(walletId));
    }
    setLockStatus(isLocked) {
        return this.storage.set('lockStatus', isLocked);
    }
    getLockStatus() {
        return this.storage.get('lockStatus');
    }
    removeLockStatus() {
        return this.storage.remove('lockStatus');
    }
    setEmailLawCompliance(value) {
        return this.storage.set('emailLawCompliance', value);
    }
    getEmailLawCompliance() {
        return this.storage.get('emailLawCompliance');
    }
    removeEmailLawCompliance() {
        return this.storage.remove('emailLawCompliance');
    }
    setShowAmazonJapanAnnouncement(value) {
        return this.storage.set('showAmazonJapanAnnouncement', value);
    }
    getShowAmazonJapanAnnouncement() {
        return this.storage.get('showAmazonJapanAnnouncement');
    }
    removeShowAmazonJapanAnnouncement() {
        return this.storage.remove('showAmazonJapanAnnouncement');
    }
};
PersistenceProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ionic_native_file__["a" /* File */]])
], PersistenceProvider);

//# sourceMappingURL=persistence.js.map

/***/ }),

/***/ 328:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__prod__ = __webpack_require__(1000);

/**
 * Environment: dev
 */
const env = Object.assign({}, __WEBPACK_IMPORTED_MODULE_0__prod__["a" /* default */], { 
    // override for development:
    name: 'development' });
/* harmony default export */ __webpack_exports__["a"] = (env);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 350:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return JoinWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Pages

// Providers







let JoinWalletPage = class JoinWalletPage {
    constructor(configProvider, form, navCtrl, navParams, derivationPathHelperProvider, onGoingProcessProvider, popupProvider, profileProvider, walletProvider, logger, translate, events, pushNotificationsProvider) {
        this.configProvider = configProvider;
        this.form = form;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.defaults = this.configProvider.getDefaults();
        this.derivationPathByDefault = this.derivationPathHelperProvider.default;
        this.derivationPathForTestnet = this.derivationPathHelperProvider.defaultTestnet;
        this.showAdvOpts = false;
        let regex = /^[0-9A-HJ-NP-Za-km-z]{70,80}$/; // For invitationCode
        this.joinForm = this.form.group({
            myName: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            invitationCode: [null, [__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].pattern(regex)]],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [this.derivationPathByDefault],
            coin: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]
        });
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad JoinWalletPage');
    }
    ionViewWillEnter() {
        if (this.navParams.data.url) {
            let data = this.navParams.data.url;
            data = data.replace('copay:', '');
            this.onQrCodeScannedJoin(data);
        }
    }
    onQrCodeScannedJoin(data) {
        // TODO
        this.joinForm.controls['invitationCode'].setValue(data);
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.joinForm.get('recoveryPhrase').setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
        }
        else {
            this.joinForm.get('recoveryPhrase').setValidators(null);
        }
        this.joinForm.controls['selectedSeed'].setValue(seed);
        this.joinForm.controls['testnet'].setValue(false);
        this.joinForm.controls['derivationPath'].setValue(this.derivationPathByDefault);
    }
    setDerivationPath() {
        let path = this.joinForm.value.testnet
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.joinForm.controls['derivationPath'].setValue(path);
    }
    setOptsAndJoin() {
        let opts = {
            secret: this.joinForm.value.invitationCode,
            myName: this.joinForm.value.myName,
            bwsurl: this.joinForm.value.bwsURL,
            coin: this.joinForm.value.coin
        };
        let setSeed = this.joinForm.value.selectedSeed == 'set';
        if (setSeed) {
            let words = this.joinForm.value.recoveryPhrase;
            if (words.indexOf(' ') == -1 &&
                words.indexOf('prv') == 1 &&
                words.length > 108) {
                opts.extendedPrivateKey = words;
            }
            else {
                opts.mnemonic = words;
            }
            let pathData = this.derivationPathHelperProvider.parse(this.joinForm.value.derivationPath);
            if (!pathData) {
                let title = this.translate.instant('Error');
                let subtitle = this.translate.instant('Invalid derivation path');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
            opts.networkName = pathData.networkName;
            opts.derivationStrategy = pathData.derivationStrategy;
        }
        if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        this.join(opts);
    }
    join(opts) {
        this.onGoingProcessProvider.set('joiningWallet');
        this.profileProvider
            .joinWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            this.events.publish('status:updated');
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            if (!wallet.isComplete()) {
                this.navCtrl.popToRoot();
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__copayers_copayers__["a" /* CopayersPage */], {
                    walletId: wallet.credentials.walletId
                });
            }
            else {
                this.navCtrl.popToRoot();
            }
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            let title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        });
    }
    openScanner() {
        if (this.navParams.data.fromScan) {
            this.navCtrl.popToRoot({ animate: false });
        }
        else {
            this.navCtrl.popToRoot({ animate: false }).then(() => {
                this.navCtrl.parent.select(2);
            });
        }
    }
};
JoinWalletPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-join-wallet',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/add/join-wallet/join-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Join wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <form [formGroup]="joinForm" (ngSubmit)="setOptsAndJoin()">\n    <ion-item>\n      <ion-label stacked>{{\'Your name\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="myName" placeholder="{{\'Enter wallet name\'| translate}}"></ion-input>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{\'Wallet invitation\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="invitationCode" placeholder="{{\'Enter wallet invitation\'| translate}}"></ion-input>\n\n      <ion-icon *ngIf="joinForm.controls.invitationCode.status == \'VALID\'" name="ios-checkmark-circle" class="check success" item-right></ion-icon>\n      <ion-icon *ngIf="joinForm.value.invitationCode && joinForm.controls.invitationCode.status == \'INVALID\'" class="check fail" name="ios-close-circle" item-right></ion-icon>\n\n      <ion-icon class="scanner-icon" name="qr-scanner" item-right (click)="openScanner()"></ion-icon>\n    </ion-item>\n\n    <ion-item>\n      <ion-label stacked>{{\'Coin\' | translate}}</ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" placeholder="{{\'Select a coin\' | translate}}" formControlName="coin">\n        <ion-option value="btc">Bastoji (BTJ)</ion-option>\n        <ion-option value="bch">Bastoji Cash (BCH)</ion-option>\n      </ion-select>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item (click)="showAdvOpts = !showAdvOpts">\n      <ion-label *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</ion-label>\n      <ion-label *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</ion-label>\n      <div item-end>\n        <ion-icon color="grey" *ngIf="!showAdvOpts" name="ios-arrow-down-outline"></ion-icon>\n        <ion-icon color="grey" *ngIf="showAdvOpts" name="ios-arrow-up-outline"></ion-icon>\n      </div>\n    </ion-item>\n\n    <div *ngIf="showAdvOpts">\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(joinForm.value.selectedSeed)">\n          <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item *ngIf="joinForm.value.selectedSeed == \'set\'">\n        <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="joinForm.value.selectedSeed == \'set\'">\n        <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="derivationPath"></ion-input>\n      </ion-item>\n    </div>\n  </form>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <button ion-button full class="button-footer" (click)="setOptsAndJoin()" [disabled]="!joinForm.valid">\n      {{\'Join wallet\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/add/join-wallet/join-wallet.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], JoinWalletPage);

//# sourceMappingURL=join-wallet.js.map

/***/ }),

/***/ 351:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmazonPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__amazon_card_details_amazon_card_details__ = __webpack_require__(737);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



// Pages


// Providers






let AmazonPage = class AmazonPage {
    constructor(amazonProvider, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, popupProvider, onGoingProcessProvider, timeProvider) {
        this.amazonProvider = amazonProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.timeProvider = timeProvider;
        this.updatePendingGiftCards = __WEBPACK_IMPORTED_MODULE_2_lodash__["debounce"](() => {
            this.updatingPending = {};
            this.updateGiftCards()
                .then(() => {
                let gcds = this.giftCards;
                __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](gcds, dataFromStorage => {
                    this.updateGiftCard = this.checkIfCardNeedsUpdate(dataFromStorage);
                    if (this.updateGiftCard) {
                        this.logger.debug('Creating / Updating gift card');
                        this.updatingPending[dataFromStorage.invoiceId] = true;
                        this.amazonProvider.createGiftCard(dataFromStorage, (err, giftCard) => {
                            this.updatingPending[dataFromStorage.invoiceId] = false;
                            if (err) {
                                this.logger.error('Error creating gift card:', err);
                                giftCard = giftCard || {};
                                giftCard['status'] = 'FAILURE';
                            }
                            if (giftCard.status != 'PENDING') {
                                let newData = {};
                                __WEBPACK_IMPORTED_MODULE_2_lodash__["merge"](newData, dataFromStorage, giftCard);
                                if (newData.status == 'expired') {
                                    this.amazonProvider.savePendingGiftCard(newData, {
                                        remove: true
                                    }, () => {
                                        this.updateGiftCards();
                                    });
                                    return;
                                }
                                this.amazonProvider.savePendingGiftCard(newData, null, () => {
                                    this.logger.debug('Amazon gift card updated');
                                    this.updateGiftCards();
                                });
                            }
                        });
                    }
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        }, 1000, {
            leading: true
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AmazonPage');
        this.network = this.amazonProvider.getNetwork();
        this.initAmazon().then(() => {
            if (this.giftCards) {
                this.updatePendingGiftCards();
            }
        });
    }
    ionViewWillEnter() {
        if (this.giftCards) {
            this.invoiceId = this.navParams.data.invoiceId;
            this.updateGiftCards()
                .then(() => {
                if (this.invoiceId) {
                    let card = __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.giftCards, {
                        invoiceId: this.invoiceId
                    });
                    if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](card)) {
                        this.popupProvider.ionicAlert(null, 'Card not found');
                        return;
                    }
                    this.updateGiftCard = this.checkIfCardNeedsUpdate(card);
                    this.invoiceId = this.navParams.data.invoiceId = null;
                    this.openCardModal(card);
                }
            })
                .catch(err => {
                this.logger.error('Amazon: could not update gift cards', err);
            });
        }
    }
    initAmazon() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.amazonProvider.currency) {
                this.onGoingProcessProvider.set('');
                yield this.amazonProvider.setCurrencyByLocation();
                this.onGoingProcessProvider.clear();
            }
            this.currency = this.amazonProvider.currency;
            this.country = this.amazonProvider.country;
            this.pageTitle = this.amazonProvider.pageTitle;
            this.onlyIntegers = this.amazonProvider.onlyIntegers;
            return new Promise(resolve => {
                this.amazonProvider.getPendingGiftCards((err, gcds) => {
                    if (err)
                        this.logger.error(err);
                    this.giftCards = gcds;
                    return resolve();
                });
            });
        });
    }
    checkIfCardNeedsUpdate(card) {
        // Continues normal flow (update card)
        if (card.status == 'PENDING' || card.status == 'invalid') {
            return true;
        }
        // Check if card status FAILURE for 24 hours
        if (card.status == 'FAILURE' &&
            this.timeProvider.withinPastDay(card.date)) {
            return true;
        }
        // Success: do not update
        return false;
    }
    updateGiftCards() {
        return new Promise((resolve, reject) => {
            this.amazonProvider.getPendingGiftCards((err, gcds) => {
                if (err) {
                    this.popupProvider.ionicAlert('Could not get gift cards', err);
                    return reject(err);
                }
                this.giftCards = gcds;
                return resolve();
            });
        });
    }
    openCardModal(card) {
        this.card = card;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__amazon_card_details_amazon_card_details__["a" /* AmazonCardDetailsPage */], {
            card: this.card,
            updateGiftCard: this.updateGiftCard
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.updatePendingGiftCards();
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    goTo(page) {
        switch (page) {
            case 'Amount':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__send_amount_amount__["a" /* AmountPage */], {
                    nextPage: 'BuyAmazonPage',
                    currency: this.currency,
                    fixedUnit: true,
                    onlyIntegers: this.onlyIntegers
                });
                break;
        }
    }
};
AmazonPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-amazon',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ pageTitle }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="container" *ngIf="!giftCards">\n    <div class="box-notification warn no-margin" *ngIf="network == \'testnet\'">\n      Sandbox version. Only for testing purpose.\n    </div>\n    <div class="center-header">\n      <div class="logo">\n        <img class="usa-logo" *ngIf="country == \'usa\'" src="assets/img/amazon/GCs-logo-cllb.png" alt="Amazon.com Gift Card">\n        <img class="japan-logo" *ngIf="country == \'japan\'" src="assets/img/amazon/japan/GCs-logo-japan-cllb.jpg" alt="Amazon.co.jp Gift Card">\n      </div>\n      <div class="description" *ngIf="country == \'usa\'" padding translate>Gift Cards are only redeemable on Amazon.com (US website).\n      </div>\n      <div class="description" *ngIf="country == \'japan\'" padding translate>Gift Cards are only redeemable on Amazon.co.jp (Japan website).\n      </div>\n      <button *ngIf="!showOauthForm" ion-button outline class="button-standard" (click)="goTo(\'Amount\')" no-low-fee>{{\'Buy a Gift Card\' | translate}}</button>\n      <button *ngIf="!showOauthForm && country == \'usa\'" ion-button clear small block color="dark" (click)="openExternalLink(\'https://www.amazon.com\')">{{\'Visit Amazon.com\' | translate}} &rarr;</button>\n      <button *ngIf="!showOauthForm && country == \'japan\'" ion-button clear small block color="dark" (click)="openExternalLink(\'https://www.amazon.co.jp\')">{{\'Visit Amazon.co.jp\' | translate}} &rarr;</button>\n      <div class="short-disclaimer">\n        <div *ngIf="country != \'japan\'">\n          * Restrictions apply, see amazon.com/gc-legal\n        </div>\n        <div *ngIf="country == \'japan\'">\n          * BitPay AmazonBitPay      \n          <br>\n          * AmazonAmazon.co.jpAmazon.com, Inc.\n          <div margin-top>\n            * Amazon.co.jp is not a sponsor of this program.\n            <br>\n            * "Amazon", "Amazon.co.jp" and their logos are registered trademarks of Amazon.com, Inc. and its affiliates.\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div class="container" *ngIf="giftCards">\n    <div class="box-notification warn no-margin" *ngIf="network == \'testnet\'">\n      Sandbox version. Only for testing purpose.\n    </div>\n\n    <div class="integration-giftCard-logo">\n      <img *ngIf="country == \'usa\'" src="assets/img/amazon/GCs-logo-cllb.png" alt="Amazon.com Gift Card">\n      <img *ngIf="country == \'japan\'" src="assets/img/amazon/japan/GCs-logo-japan-cllb.jpg" alt="Amazon.co.jp Gift Card">\n      <div *ngIf="country == \'usa\'" class="subtitle" translate>\n        Only redeemable on www.amazon.com (US website).\n      </div>\n      <div *ngIf="country == \'japan\'" class="subtitle" translate>\n        Only redeemable on www.amazon.co.jp (Japan website).\n      </div>\n      <button ion-button no-low-fee (click)="goTo(\'Amount\')">\n        {{\'Buy Gift Card\' | translate}}\n      </button>\n    </div>\n\n    <ion-list>\n      <ion-item-divider>{{\'Your Gift Cards\' | translate}}</ion-item-divider>\n      <button ion-item *ngFor="let item of (giftCards | keys : \'date\') | orderBy : [\'-order\']" (click)="openCardModal(item.value)">\n        <div class="amazon-card">\n          <img src="assets/img/amazon/icon-amazon.svg" alt="Amazon" class="avatar">\n          <div class="card-info">\n            <h2 *ngIf="item.value.amount">\n              <span *ngIf="onlyIntegers">{{item.value.amount | number : \'1.0-0\'}}</span> \n              <span *ngIf="!onlyIntegers">{{item.value.amount | number : \'1.2-2\'}}</span> \n              {{item.value.currency ? item.value.currency : currency}}\n            </h2>\n            <p>\n              <span class="text-gray">{{item.value.date | amTimeAgo}}</span>\n              <span *ngIf="updatingPending[item.value.invoiceId]">...</span>\n              <span *ngIf="!updatingPending[item.value.invoiceId]">\n                <span class="assertive" *ngIf="item.value.status == \'FAILURE\' || item.value.status == \'RESEND\'" translate>Error</span>\n                <span class="assertive" *ngIf="item.value.status == \'expired\'" translate>Expired</span>\n                <span class="assertive" *ngIf="item.value.status == \'invalid\'" translate>Still waiting confirmation (Use higher fees setting to faster delivery)\n                </span>\n                <span class="text-gray" *ngIf="item.value.status == \'PENDING\'" translate>Pending to confirmation</span>\n                <span class="assertive" *ngIf="item.value.status == \'SUCCESS\' && item.value.cardStatus == \'Canceled\'" translate>Canceled</span>\n              </span>\n            </p>\n          </div>\n        </div>\n      </button>\n      <ion-item-divider></ion-item-divider>\n    </ion-list>\n    <!-- USA -->\n    <div *ngIf="giftCards && country == \'usa\'" class="integration-giftCard-info">\n      *\n      <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> is not a sponsor of this promotion. Except as required by law,\n      <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> Gift Cards ("GCs") cannot be transferred for value or redeemed for cash. GCs may be used only for purchases of eligible goods at\n      <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> or certain of its affiliated websites. For complete terms and conditions, see\n      <a (click)="openExternalLink(\'https://www.amazon.com/gc-legal\')">www.amazon.com/gc-legal</a>. GCs are issued by ACI Gift Cards, Inc., a Washington corporation. All Amazon &reg;, &trade; &amp; &copy; are IP of\n      <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a>, Inc. or its affiliates.\n    </div>\n\n    <!-- Japan -->\n    <div *ngIf="giftCards && country == \'japan\'" class="integration-giftCard-info">\n      * Amazon Gift Cards Japan  () Amazon ()\n      <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> (PC) 10(0120-999-3731-8-1) (\n      <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/tc\')">www.amazon.co.jp/giftcard/tc</a>)\n      <br>\n      <br>* To use\n      <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> gift cards (Gift Card or Gift Cards) issued by Amazon Gift Cards Japan K.K. (Amazon GC), you need to create an account on\n      <a (click)="openExternalLink(\'http://amazon.co.jp\')">http://www.amazon.co.jp</a> (including PC and mobile sites. Amazon Sites). Gift Cards can only be redeemed through Amazon Sites, but cannot be used to purchase other Gift Cards or to pay certain membership fee available at Amazon Sites. Gift Card balance will expire at 11:59 p.m. (Japan Time) of the date specified as expiration date on each Gift Card. Gift Cards are non-refundable and non-exchangeable. Gift Card cannot be resold or transferred for value. Amazon GC or its affiliates are not responsible if Gift Card is lost, stolen, destroyed or used without your permission. If you want to know your Gift Card balance, expiration date or have any other questions regarding Gift Cards, please call Customer Service (TEL: 0120-999-373, Address: 1-8-1 Shimomeguro, Meguro-ku, Tokyo 153-0064, Japan). For more information, please read the full Terms and Conditions of Gift Cards (\n      <a (click)="openExternalLink(\'http://www.amazon.co.jp/giftcard/tc\')">http://www.amazon.co.jp/giftcard/tc</a>).\n    </div>\n  </div> \n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_5__providers_amazon_amazon__["a" /* AmazonProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_time_time__["a" /* TimeProvider */]])
], AmazonPage);

//# sourceMappingURL=amazon.js.map

/***/ }),

/***/ 352:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MercadoLibrePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__mercado_libre_card_details_mercado_libre_card_details__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Pages


// Providers




let MercadoLibrePage = class MercadoLibrePage {
    constructor(navCtrl, mercadoLibreProvider, externalLinkProvider, logger, timeProvider, modalCtrl, navParams, popupProvider) {
        this.navCtrl = navCtrl;
        this.mercadoLibreProvider = mercadoLibreProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.timeProvider = timeProvider;
        this.modalCtrl = modalCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.updatePendingGiftCards = __WEBPACK_IMPORTED_MODULE_2_lodash__["debounce"](() => {
            this.updateGiftCards()
                .then(() => {
                let gcds = this.giftCards;
                __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](gcds, dataFromStorage => {
                    this.updateGiftCard = this.checkIfCardNeedsUpdate(dataFromStorage);
                    if (this.updateGiftCard) {
                        this.logger.debug('Creating / Updating gift card');
                        this.mercadoLibreProvider.createGiftCard(dataFromStorage, (err, giftCard) => {
                            if (err) {
                                this.logger.error('Error creating gift card:', err);
                                giftCard = giftCard || {};
                                giftCard['status'] = 'FAILURE';
                            }
                            if (giftCard.status != 'PENDING') {
                                let newData = {};
                                if (!giftCard.status)
                                    dataFromStorage.status = null; // Fix error from server
                                let cardStatus = giftCard.cardStatus;
                                if (cardStatus &&
                                    (cardStatus != 'active' &&
                                        cardStatus != 'inactive' &&
                                        cardStatus != 'expired'))
                                    giftCard.status = 'FAILURE';
                                __WEBPACK_IMPORTED_MODULE_2_lodash__["merge"](newData, dataFromStorage, giftCard);
                                this.mercadoLibreProvider.savePendingGiftCard(newData, null, () => {
                                    this.logger.debug('Mercado Libre gift card updated');
                                    this.updateGiftCards();
                                });
                            }
                        });
                    }
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        }, 1000, {
            leading: true
        });
        this.showMainView = true;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad MercadoLibrePage');
        this.network = this.mercadoLibreProvider.getNetwork();
        this.init().then(() => {
            if (this.giftCards) {
                this.updatePendingGiftCards();
            }
        });
    }
    ionViewWillEnter() {
        if (this.giftCards) {
            this.invoiceId = this.navParams.data.invoiceId;
            this.updateGiftCards()
                .then(() => {
                if (this.invoiceId) {
                    let card = __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](this.giftCards, {
                        invoiceId: this.invoiceId
                    });
                    if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](card)) {
                        this.popupProvider.ionicAlert(null, 'Card not found');
                        return;
                    }
                    this.openCardModal(card);
                    this.invoiceId = this.navParams.data.invoiceId = null;
                    this.updateGiftCard = this.checkIfCardNeedsUpdate(card);
                }
            })
                .catch(err => {
                this.logger.error('Mercado Libre: could not update gift cards', err);
            });
        }
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    init() {
        return new Promise(resolve => {
            this.mercadoLibreProvider.getPendingGiftCards((err, gcds) => {
                if (err)
                    this.logger.error(err);
                this.filterArchivedGiftCards(gcds);
                resolve();
            });
        });
    }
    filterArchivedGiftCards(giftCards) {
        this.giftCards = __WEBPACK_IMPORTED_MODULE_2_lodash__["pickBy"](giftCards, gcdValue => {
            return !gcdValue.archived;
        });
        this.showMainView = __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.giftCards);
    }
    goTo(page) {
        switch (page) {
            case 'Amount':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__send_amount_amount__["a" /* AmountPage */], {
                    nextPage: 'BuyMercadoLibrePage',
                    currency: 'BRL',
                    fixedUnit: true
                });
                break;
        }
    }
    checkIfCardNeedsUpdate(card) {
        // Continues normal flow (update card)
        if (card.status == 'PENDING') {
            return true;
        }
        // Check if card status FAILURE for 24 hours
        if (card.status == 'FAILURE' &&
            this.timeProvider.withinPastDay(card.date)) {
            return true;
        }
        // Success: do not update
        return false;
    }
    updateGiftCards() {
        return new Promise((resolve, reject) => {
            this.mercadoLibreProvider.getPendingGiftCards((err, gcds) => {
                if (err) {
                    this.popupProvider.ionicAlert('Could not get gift cards', err);
                    return reject(err);
                }
                this.filterArchivedGiftCards(gcds);
                return resolve();
            });
        });
    }
    openCardModal(card) {
        this.card = card;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__mercado_libre_card_details_mercado_libre_card_details__["a" /* MercadoLibreCardDetailsPage */], {
            card: this.card
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.updatePendingGiftCards();
        });
    }
};
MercadoLibrePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-mercado-libre',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Mercado Livre Brazil Gift Cards\'|translate}}s</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="container" *ngIf="showMainView">\n    <div class="box-notification warn no-margin" *ngIf="network == \'testnet\'">\n      Sandbox version. Only for testing purpose.\n    </div>\n    <div class="center-header">\n      <div class="logo">\n        <img src="assets/img/mercado-libre/mlbr.svg" alt="Mercado Libre">\n      </div>\n      <div class="description" translate padding>\n        Only redeemable on Mercado Livre (Brazil)\n      </div>\n      <button *ngIf="!showOauthForm" ion-button outline class="button-standard" (click)="goTo(\'Amount\')" no-low-fee>\n        {{\'Buy Gift Card\' | translate}}\n      </button>\n      <button *ngIf="!showOauthForm" ion-button clear small block color="dark" (click)="openExternalLink(\'https://www.mercadolivre.com.br\')">\n        {{\'Visit mercadolivre.com.br\' | translate}} &rarr;\n      </button>\n    </div>\n  </div>\n  <div class="container" *ngIf="!showMainView">\n    <div class="box-notification warn no-margin" *ngIf="network == \'testnet\'">\n      Sandbox version. Only for testing purpose.\n    </div>\n\n    <div class="integration-giftCard-logo">\n      <img src="assets/img/mercado-libre/mlbr.svg" alt="Mercado Libre">\n      <div class="subtitle" translate>\n        Only redeemable on Mercado Livre (Brazil)\n      </div>\n      <button ion-button no-low-fee (click)="goTo(\'Amount\')">\n        <span translate>Buy Gift Card</span>\n      </button>\n    </div>\n\n    <ion-list>\n      <ion-item-divider>{{\'Your Gift Cards\'|translate}}</ion-item-divider>\n      <button ion-item *ngFor="let item of (giftCards | keys : \'date\') | orderBy : [\'-order\']" (click)="openCardModal(item.value)">\n        <div class="mercado-libre-card">\n          <img src="assets/img/mercado-libre/meli-card-24px.png" alt="" class="avatar">\n          <div class="card-info">\n            <div class="amount">\n              <h2 *ngIf="item.value.amount">\n                {{item.value.amount | currency : \'$ \' : 2}} {{item.value.currency}}\n              </h2>\n              <span>\n                <span class="assertive" *ngIf="item.value.status == \'FAILURE\'" translate>Error</span>\n                <span class="dark" *ngIf="item.value.status == \'expired\'" translate>Invoice expired</span>\n                <span class="calm" *ngIf="item.value.status == \'invalid\'" translate>Still pending</span>\n                <span class="positive" *ngIf="item.value.status == \'PENDING\'" translate>Pending</span>\n                <span class="assertive" *ngIf="item.value.cardStatus == \'inactive\'" translate>Inactive</span>\n                <span class="assertive" *ngIf="item.value.cardStatus == \'expired\'" translate>Expired</span>\n              </span>\n            </div>\n            <span class="dark">{{item.value.date | amTimeAgo}}</span>\n          </div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_mercado_libre_mercado_libre__["a" /* MercadoLibreProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */]])
], MercadoLibrePage);

//# sourceMappingURL=mercado-libre.js.map

/***/ }),

/***/ 353:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MercadoLibreCardDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Provider



let MercadoLibreCardDetailsPage = class MercadoLibreCardDetailsPage {
    constructor(mercadoLibreProvider, logger, externalLinkProvider, navParams, viewCtrl, timeProvider) {
        this.mercadoLibreProvider = mercadoLibreProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.timeProvider = timeProvider;
        this.card = this.navParams.data.card;
        this.isOldCard = !this.timeProvider.withinPastDay(this.card.date);
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad MercadoLibreCardDetailsPage');
    }
    remove() {
        this.mercadoLibreProvider.savePendingGiftCard(this.card, {
            remove: true
        }, () => {
            this.close();
        });
    }
    archive() {
        this.mercadoLibreProvider.savePendingGiftCard(this.card, {
            archived: true
        }, () => {
            this.logger.debug('Mercado Libre Gift Card archived');
            this.close();
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    openRedeemLink() {
        const url = this.mercadoLibreProvider.getNetwork() === 'testnet'
            ? 'https://beta.mercadolivre.com.br/vale-presente/resgate'
            : 'https://www.mercadolivre.com.br/vale-presente/resgate';
        this.openExternalLink(url);
    }
    openSupportWebsite() {
        let url = 'https://help.bitpay.com/requestHelp';
        let optIn = true;
        let title = null;
        let message = 'A informao de ajuda e suporte est disponvel no site.';
        let okText = 'Abrir';
        let cancelText = 'Volte';
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
MercadoLibreCardDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-mercado-libre-card-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre-card-details/mercado-libre-card-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Details</ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="header-modal">\n    <img src="assets/img/mercado-libre/giftcard-pt.svg" alt="Mercado Livre Brazil Gift Card">\n    <div class="header-modal-amount">\n      <span translate>Gift Card Amount</span>:\n      <span class="text-bold">\n        {{card.amount | currency : \'$ \' : 2}} {{card.currency}}\n      </span>\n    </div>\n    <div translate>\n      Created {{card.date | amTimeAgo}}\n    </div>\n\n    <div>\n      <div *ngIf="card.cardStatus == \'active\' && !card.archived">\n        <div *ngIf="card.pin">\n          {{\'Claim code:\' | translate}}\n          <span class="text-bold" copy-to-clipboard="{{card.pin}}">{{card.pin}}</span>\n        </div>\n        <button class="redeem" ion-button outline (click)="openRedeemLink()">\n          {{\'Redeem Now\' | translate}}\n        </button>\n      </div>\n\n      <div *ngIf="card.cardStatus == \'active\' && card.archived">\n        <span ion-text color="primary" translate>Archived</span>\n      </div>\n\n      <div *ngIf="card.cardStatus == \'inactive\'">\n        <span class="assertive" translate>Inactive</span>\n        <div class="card-status-desc" translate>Gift Card is not available to use anymore</div>\n      </div>\n\n      <div *ngIf="card.cardStatus == \'expired\'">\n        <span class="assertive" translate>Expired</span>\n        <div class="card-status-desc" translate>Gift Card is not available to use anymore</div>\n      </div>\n\n      <div *ngIf="card.status">\n        <span class="positive" *ngIf="card.status == \'PENDING\'" translate>\n          Pending\n        </span>\n        <span class="calm" *ngIf="card.status==\'invalid\'" translate>\n          Still pending\n        </span>\n        <span class="assertive" *ngIf="card.status == \'FAILURE\'" translate>\n          Error\n        </span>\n        <span class="dark" *ngIf="card.status == \'expired\'" translate>\n          Invoice expired\n        </span>\n      </div>\n    </div>\n  </div>\n\n  <ion-list>\n    <div>\n      <a translate class="energized" ion-item no-lines clear text-center (click)="openExternalLink(card.invoiceUrl)">\n        See invoice\n      </a>\n      <a translate class="energized" ion-item no-lines clear text-center (click)="openSupportWebsite()">\n        Help &amp; Support\n      </a>\n    </div>\n\n    <div *ngIf="card.cardStatus == \'inactive\' || card.cardStatus == \'expired\' || card.status == \'expired\' || (card.status == \'FAILURE\' && isOldCard) || (card.cardStatus == \'active\' && card.archived && isOldCard)">\n      <ion-item-divider></ion-item-divider>\n      <a translate class="assertive" ion-item no-lines clear text-center (click)="remove()">\n        Remove\n      </a>\n      <ion-item-divider>\n        {{\'Removing this Gift Card will remove all their data from this device.\' | translate}}\n      </ion-item-divider>\n    </div>\n\n    <div *ngIf="card.cardStatus == \'active\' && !card.archived && isOldCard">\n      <ion-item-divider></ion-item-divider>\n      <a translate class="assertive" ion-item no-lines clear text-center (click)="archive()">\n        Archive\n      </a>\n      <ion-item-divider>\n        {{\'Archiving this Gift Card will remove it from this view. You will still be able to see it in the Mercado Livre settings.\' | translate}}\n      </ion-item-divider>\n    </div>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre-card-details/mercado-libre-card-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_mercado_libre_mercado_libre__["a" /* MercadoLibreProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_time_time__["a" /* TimeProvider */]])
], MercadoLibreCardDetailsPage);

//# sourceMappingURL=mercado-libre-card-details.js.map

/***/ }),

/***/ 354:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__shapeshift_details_shapeshift_details__ = __webpack_require__(732);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__shapeshift_shift_shapeshift_shift__ = __webpack_require__(733);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_shapeshift_shapeshift__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Pages


// Providers



let ShapeshiftPage = class ShapeshiftPage {
    constructor(events, externalLinkProvider, logger, modalCtrl, navCtrl, shapeshiftProvider, timeProvider) {
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.shapeshiftProvider = shapeshiftProvider;
        this.timeProvider = timeProvider;
        this.updateShift = __WEBPACK_IMPORTED_MODULE_2_lodash__["debounce"](shifts => {
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](shifts.data))
                return;
            __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](shifts.data, dataFromStorage => {
                if (!this.checkIfShiftNeedsUpdate(dataFromStorage))
                    return;
                this.shapeshiftProvider.getStatus(dataFromStorage.address, (err, st) => {
                    if (err)
                        return;
                    this.shifts.data[st.address].status = st.status;
                    this.shifts.data[st.address].transaction = st.transaction || null;
                    this.shifts.data[st.address].incomingCoin = st.incomingCoin || null;
                    this.shifts.data[st.address].incomingType = st.incomingType || null;
                    this.shifts.data[st.address].outgoingCoin = st.outgoingCoin || null;
                    this.shifts.data[st.address].outgoingType = st.outgoingType || null;
                    this.shapeshiftProvider.saveShapeshift(this.shifts.data[st.address], null, () => {
                        this.logger.debug('Saved shift with status: ' + st.status);
                    });
                });
            });
        }, 1000, {
            leading: true
        });
        this.network = this.shapeshiftProvider.getNetwork();
        this.shifts = { data: {} };
        this.init();
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ShapeshiftPage');
    }
    ionViewWillEnter() {
        this.events.subscribe('bwsEvent', (_, type) => {
            if (type == 'NewBlock')
                this.updateShift(this.shifts);
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    checkIfShiftNeedsUpdate(shiftData) {
        // Continues normal flow (update shiftData)
        if (shiftData.status == 'received') {
            return true;
        }
        // Check if shiftData status FAILURE for 24 hours
        if ((shiftData.status == 'failed' || shiftData.status == 'no_deposits') &&
            this.timeProvider.withinPastDay(shiftData.date)) {
            return true;
        }
        // If status is complete: do not update
        // If status fails or do not receive deposits for more than 24 hours: do not update
        return false;
    }
    init() {
        this.shapeshiftProvider.getShapeshift((err, ss) => {
            if (err)
                this.logger.error(err);
            if (ss)
                this.shifts = { data: ss };
            this.updateShift(this.shifts);
        });
    }
    update() {
        this.updateShift(this.shifts);
    }
    openShiftModal(ssData) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__shapeshift_details_shapeshift_details__["a" /* ShapeshiftDetailsPage */], { ssData });
        modal.present();
        modal.onDidDismiss(() => {
            this.init();
        });
    }
    goTo(page) {
        switch (page) {
            case 'Shift':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__shapeshift_shift_shapeshift_shift__["a" /* ShapeshiftShiftPage */]);
                break;
        }
    }
};
ShapeshiftPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-shapeshift',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>ShapeShift</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="container" *ngIf="(shifts.data | json) == \'{}\'">\n    <div class="center-header">\n      <img src="assets/img/shapeshift/logo-shapeshift.svg" width="200" alt="Shapeshift">\n      <div padding>\n        <h4 translate>The Safest, Fastest Asset Exchange on Earth</h4>\n        <p translate>Trade any leading blockchain asset for any other. Protection by Design. No Account Needed.</p>\n      </div>\n      <button ion-button outline class="button-standard" color="light" no-low-fee (click)="goTo(\'Shift\')">\n        {{\'Start\' | translate}}\n      </button>\n      <button ion-button clear small color="light" (click)="openExternalLink(\'https://shapeshift.io\')">\n        {{\'Visit ShapeShift.io\' | translate}} &rarr;\n      </button>\n    </div>\n  </div>\n\n  <div class="container" *ngIf="(shifts.data | json) != \'{}\'">\n    <div class="main-header">\n      <img src="assets/img/shapeshift/logo-shapeshift.svg" width="180" (click)="update()">\n      <button ion-button clear icon-right color="light" no-low-fee (click)="goTo(\'Shift\')">\n        <span>Shift</span>\n        <ion-icon name="arrow-forward"></ion-icon>\n      </button>\n    </div>\n\n    <ion-list>\n      <ion-item-divider>{{\'Transactions\' | translate}}</ion-item-divider>\n      <button ion-item *ngFor="let item of (shifts.data | keys : \'date\') | orderBy : [\'-order\']" (click)="openShiftModal(item.value)">\n        <ion-label>\n          <div class="ellipsis">{{item.value.title || item.value.address}}</div>\n          <div class="status">\n            <span class="assertive" *ngIf="item.value.status == \'failed\'" translate>Failed</span>\n            <span class="balanced" *ngIf="item.value.status == \'complete\'" translate>Completed</span>\n            <span class="royal" *ngIf="item.value.status == \'received\'" translate>Pending</span>\n            <span class="calm" *ngIf="item.value.status == \'no_deposits\'" translate>Pending</span>\n          </div>\n        </ion-label>\n        <div item-content text-end>\n          <div class="text-bold">{{ item.value.amount }}</div>\n          <div class="date calm">{{item.value.date | amTimeAgo}}</div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar *ngIf="shifts.data">\n    <div class="shift-problems">\n      <span translate>Having problems with a ShapeShift?</span>\n      <br>\n      <a (click)="openExternalLink(\'https://shapeshift.zendesk.com/hc/en-us/requests/new\')" translate>\n        Contact the ShapeShift support team.\n      </a>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_time_time__["a" /* TimeProvider */]])
], ShapeshiftPage);

//# sourceMappingURL=shapeshift.js.map

/***/ }),

/***/ 355:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ConfirmPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__paypro_paypro__ = __webpack_require__(735);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tabs_tabs__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__choose_fee_level_choose_fee_level__ = __webpack_require__(736);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_tx_confirm_notification_tx_confirm_notification__ = __webpack_require__(356);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Pages




// Providers














let ConfirmPage = class ConfirmPage {
    constructor(app, bwcProvider, navCtrl, navParams, logger, configProvider, replaceParametersProvider, platformProvider, profileProvider, walletProvider, popupProvider, bwcErrorProvider, onGoingProcessProvider, feeProvider, txConfirmNotificationProvider, modalCtrl, txFormatProvider, events, translate, externalLinkProvider) {
        this.app = app;
        this.bwcProvider = bwcProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.platformProvider = platformProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.popupProvider = popupProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.feeProvider = feeProvider;
        this.txConfirmNotificationProvider = txConfirmNotificationProvider;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.events = events;
        this.translate = translate;
        this.externalLinkProvider = externalLinkProvider;
        this.countDown = null;
        // custom fee flag
        this.usingCustomFee = false;
        this.usingMerchantFee = false;
        this.publishAndSign = (txp, wallet) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                this.onlyPublish(txp, wallet);
                return;
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                if (this.config.confirmedTxsNotifications &&
                    this.config.confirmedTxsNotifications.enabled) {
                    this.txConfirmNotificationProvider.subscribe(wallet, {
                        txid: txp.txid
                    });
                }
                this.openFinishModal();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.setSendError(err);
                return;
            });
        };
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.CONFIRM_LIMIT_USD = 20;
        this.FEE_TOO_HIGH_LIMIT_PER = 15;
        this.config = this.configProvider.get();
        this.configFeeLevel = this.config.wallet.settings.feeLevel
            ? this.config.wallet.settings.feeLevel
            : 'normal';
        this.isCordova = this.platformProvider.isCordova;
        this.memoFocused = false;
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
        this.isOpenSelector = false;
        let B = this.navParams.data.coin == 'bch' ? this.bitcoreCash : this.bitcore;
        let networkName;
        try {
            networkName = new B.Address(this.navParams.data.toAddress).network.name;
        }
        catch (e) {
            var message = this.translate.instant('Copay only supports Bastoji Cash using new version numbers addresses');
            var backText = this.translate.instant('Go back');
            var learnText = this.translate.instant('Learn more');
            this.popupProvider
                .ionicConfirm(null, message, backText, learnText)
                .then(back => {
                if (!back) {
                    var url = 'https://support.bitpay.com/hc/en-us/articles/115004671663';
                    this.externalLinkProvider.open(url);
                }
                this.navCtrl.pop();
            });
            return;
        }
        this.tx = {
            toAddress: this.navParams.data.toAddress,
            amount: parseInt(this.navParams.data.amount, 10),
            sendMax: this.navParams.data.useSendMax ? true : false,
            description: this.navParams.data.description,
            paypro: this.navParams.data.paypro,
            spendUnconfirmed: this.config.wallet.spendUnconfirmed,
            // Vanity tx info (not in the real tx)
            recipientType: this.navParams.data.recipientType,
            name: this.navParams.data.name,
            email: this.navParams.data.email,
            color: this.navParams.data.color,
            network: networkName,
            coin: this.navParams.data.coin,
            txp: {}
        };
        this.tx.origToAddress = this.tx.toAddress;
        if (this.navParams.data.requiredFeeRate) {
            this.usingMerchantFee = true;
            this.tx.feeRate = +this.navParams.data.requiredFeeRate;
        }
        else {
            this.tx.feeLevel =
                this.tx.coin && this.tx.coin == 'bch' ? 'normal ' : this.configFeeLevel;
        }
        if (this.tx.coin && this.tx.coin == 'bch') {
            // Use legacy address
            this.tx.toAddress = this.bitcoreCash
                .Address(this.tx.toAddress)
                .toString();
        }
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.showAddress = false;
        this.walletSelectorTitle = this.translate.instant('Send from');
        this.setWalletSelector(this.tx.coin, this.tx.network, this.tx.amount)
            .then(() => {
            this.afterWalletSelectorSet();
        })
            .catch(err => {
            this.logger.error(err);
            return this.exitWithError(err);
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ConfirmPage');
    }
    afterWalletSelectorSet() {
        if (this.wallets.length > 1) {
            return this.showWallets();
        }
        else if (this.wallets.length) {
            this.setWallet(this.wallets[0]);
        }
    }
    setWalletSelector(coin, network, minAmount) {
        return new Promise((resolve, reject) => {
            // no min amount? (sendMax) => look for no empty wallets
            minAmount = minAmount ? minAmount : 1;
            let filteredWallets = [];
            let index = 0;
            let walletsUpdated = 0;
            this.wallets = this.profileProvider.getWallets({
                onlyComplete: true,
                network,
                coin
            });
            if (!this.wallets || !this.wallets.length) {
                this.setNoWallet(this.translate.instant('No wallets available'), true);
                return resolve();
            }
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](this.wallets, wallet => {
                this.walletProvider
                    .getStatus(wallet, {})
                    .then(status => {
                    walletsUpdated++;
                    wallet.status = status;
                    if (!status.availableBalanceSat) {
                        this.logger.debug('No balance available in: ' + wallet.name);
                    }
                    if (status.availableBalanceSat > minAmount) {
                        filteredWallets.push(wallet);
                    }
                    if (++index == this.wallets.length) {
                        if (!walletsUpdated)
                            return reject('Could not update any wallet');
                        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](filteredWallets)) {
                            this.setNoWallet(this.translate.instant('Insufficient funds'), true);
                            return reject('INSUFFICIENT_FUNDS');
                        }
                        this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](filteredWallets);
                        return resolve();
                    }
                })
                    .catch(err => {
                    this.logger.error(err);
                    if (++index == this.wallets.length) {
                        if (!walletsUpdated)
                            return reject('Could not update any wallet');
                        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](filteredWallets)) {
                            this.setNoWallet(this.translate.instant('Insufficient funds'), true);
                            return reject('INSUFFICIENT_FUNDS_FOR_FEE');
                        }
                        this.wallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](filteredWallets);
                        return resolve();
                    }
                });
            });
        });
    }
    setNoWallet(msg, criticalError) {
        this.wallet = null;
        this.noWalletMessage = msg;
        this.criticalError = criticalError;
        this.logger.warn('Not ready to make the payment: ' + msg);
    }
    exitWithError(err) {
        this.logger.info('Error setting wallet selector:' + err);
        this.popupProvider
            .ionicAlert('', this.bwcErrorProvider.msg(err))
            .then(() => {
            this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_7__tabs_tabs__["a" /* TabsPage */]);
        });
    }
    /* sets a wallet on the UI, creates a TXPs for that wallet */
    setWallet(wallet) {
        this.wallet = wallet;
        // If select another wallet
        this.tx.coin = this.wallet.coin;
        if (!this.usingCustomFee && !this.usingMerchantFee) {
            this.tx.feeLevel = wallet.coin == 'bch' ? 'normal' : this.configFeeLevel;
        }
        this.setButtonText(this.wallet.credentials.m > 1, !!this.tx.paypro);
        if (this.tx.paypro)
            this.paymentTimeControl(this.tx.paypro.expires);
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        this.updateTx(this.tx, this.wallet, { dryRun: true }).catch(err => {
            this.logger.warn('Error in updateTx: ', err);
        });
    }
    setButtonText(isMultisig, isPayPro) {
        if (isPayPro) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to pay')
                : this.translate.instant('Click to pay');
        }
        else if (isMultisig) {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to accept')
                : this.translate.instant('Click to accept');
            this.successText =
                this.wallet.credentials.n == 1
                    ? this.translate.instant('Payment Sent')
                    : this.translate.instant('Proposal created');
        }
        else {
            this.buttonText = this.isCordova
                ? this.translate.instant('Slide to send')
                : this.translate.instant('Click to send');
            this.successText = this.translate.instant('Payment Sent');
        }
    }
    paymentTimeControl(expirationTime) {
        this.paymentExpired = false;
        this.setExpirationTime(expirationTime);
        let countDown = setInterval(() => {
            this.setExpirationTime(expirationTime, countDown);
        }, 1000);
    }
    setExpirationTime(expirationTime, countDown) {
        let now = Math.floor(Date.now() / 1000);
        if (now > expirationTime) {
            this.paymentExpired = true;
            this.remainingTimeStr = this.translate.instant('Expired');
            if (countDown) {
                /* later */
                clearInterval(countDown);
            }
            return;
        }
        let totalSecs = expirationTime - now;
        let m = Math.floor(totalSecs / 60);
        let s = totalSecs % 60;
        this.remainingTimeStr = ('0' + m).slice(-2) + ':' + ('0' + s).slice(-2);
    }
    updateTx(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            if (opts.clearCache) {
                tx.txp = {};
            }
            this.tx = tx;
            // End of quick refresh, before wallet is selected.
            if (!wallet) {
                return resolve();
            }
            let maxAllowedMerchantFee = {
                btc: 'urgent',
                bch: 'normal'
            };
            this.onGoingProcessProvider.set('calculatingFee');
            this.feeProvider
                .getFeeRate(wallet.coin, tx.network, this.usingMerchantFee
                ? maxAllowedMerchantFee[wallet.coin]
                : this.tx.feeLevel)
                .then(feeRate => {
                let msg;
                if (this.usingCustomFee) {
                    msg = this.translate.instant('Custom');
                    tx.feeLevelName = msg;
                }
                else if (this.usingMerchantFee) {
                    let maxAllowedFee = feeRate * 2;
                    this.logger.info('Using Merchant Fee:' +
                        tx.feeRate +
                        ' vs. referent level:' +
                        maxAllowedFee);
                    if (tx.network != 'testnet' && tx.feeRate > maxAllowedFee) {
                        this.onGoingProcessProvider.set('calculatingFee');
                        this.setNoWallet(this.translate.instant('Merchant fee too high. Payment rejected'), true);
                        return reject('fee_too_high');
                    }
                    msg = this.translate.instant('Suggested by Merchant');
                    tx.feeLevelName = msg;
                }
                else {
                    const feeOpts = this.feeProvider.getFeeOpts();
                    tx.feeLevelName = feeOpts[tx.feeLevel];
                    tx.feeRate = feeRate;
                }
                // call getSendMaxInfo if was selected from amount view
                if (tx.sendMax) {
                    this.useSendMax(tx, wallet, opts)
                        .then(() => {
                        return resolve();
                    })
                        .catch(err => {
                        return reject(err);
                    });
                }
                else {
                    // txp already generated for this wallet?
                    if (tx.txp[wallet.id]) {
                        this.onGoingProcessProvider.clear();
                        return resolve();
                    }
                    this.buildTxp(tx, wallet, opts)
                        .then(() => {
                        this.onGoingProcessProvider.clear();
                        return resolve();
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        return reject(err);
                    });
                }
            })
                .catch(err => {
                this.logger.warn('Error getting fee rate', err);
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    useSendMax(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getSendMaxInfo(__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](tx), wallet)
                .then(sendMaxInfo => {
                if (sendMaxInfo) {
                    this.logger.debug('Send max info', sendMaxInfo);
                    if (sendMaxInfo.amount == 0) {
                        this.setNoWallet(this.translate.instant('Insufficient funds for fee'), false);
                        this.popupProvider
                            .ionicAlert(this.translate.instant('Error'), this.translate.instant('Not enough funds for fee'))
                            .then(() => {
                            return resolve('no_funds');
                        });
                    }
                    tx.sendMaxInfo = sendMaxInfo;
                    tx.amount = tx.sendMaxInfo.amount;
                }
                this.showSendMaxWarning(wallet, sendMaxInfo).then(() => {
                    // txp already generated for this wallet?
                    if (tx.txp[wallet.id]) {
                        return resolve();
                    }
                    this.buildTxp(tx, wallet, opts)
                        .then(() => {
                        return resolve();
                    })
                        .catch(err => {
                        return reject(err);
                    });
                });
            })
                .catch(() => {
                let msg = this.translate.instant('Error getting SendMax information');
                return reject(msg);
            });
        });
    }
    buildTxp(tx, wallet, opts) {
        return new Promise((resolve, reject) => {
            this.getTxp(__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](tx), wallet, opts.dryRun)
                .then(txp => {
                let per = (txp.fee / (txp.amount + txp.fee)) * 100;
                txp.feeRatePerStr = per.toFixed(2) + '%';
                txp.feeTooHigh = per > this.FEE_TOO_HIGH_LIMIT_PER;
                if (txp.feeTooHigh) {
                    const feeWarningModal = this.popupProvider.createMiniModal('fee-warning');
                    feeWarningModal.present();
                }
                tx.txp[wallet.id] = txp;
                this.tx = tx;
                this.logger.debug('Confirm. TX Fully Updated for wallet:' + wallet.id, JSON.stringify(tx));
                return resolve();
            })
                .catch(err => {
                if (err.message == 'Insufficient funds') {
                    this.setNoWallet(this.translate.instant('Insufficient funds'));
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('Not enough funds for fee'));
                    return reject('no_funds');
                }
                else {
                    return reject(err);
                }
            });
        });
    }
    getSendMaxInfo(tx, wallet) {
        return new Promise((resolve, reject) => {
            if (!tx.sendMax)
                return resolve();
            this.onGoingProcessProvider.set('retrievingInputs');
            this.walletProvider
                .getSendMaxInfo(wallet, {
                feePerKb: tx.feeRate,
                excludeUnconfirmedUtxos: !tx.spendUnconfirmed,
                returnInputs: true
            })
                .then(res => {
                this.onGoingProcessProvider.clear();
                return resolve(res);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.warn('Error getting send max info', err);
                return reject(err);
            });
        });
    }
    showSendMaxWarning(wallet, sendMaxInfo) {
        return new Promise(resolve => {
            if (!sendMaxInfo)
                return resolve();
            let msg = this.replaceParametersProvider.replace(this.translate.instant('{{fee}} {{coin}} will be deducted for bastoji networking fees.'), { fee: sendMaxInfo.fee / 1e8, coin: this.tx.coin.toUpperCase() });
            let warningMsg = this.verifyExcludedUtxos(wallet, sendMaxInfo);
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](warningMsg))
                msg += '\n' + warningMsg;
            this.popupProvider.ionicAlert(null, msg).then(() => {
                return resolve();
            });
        });
    }
    verifyExcludedUtxos(_, sendMaxInfo) {
        let warningMsg = [];
        if (sendMaxInfo.utxosBelowFee > 0) {
            let amountBelowFeeStr = sendMaxInfo.amountBelowFee / 1e8;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (sendMaxInfo.utxosAboveMaxSize > 0) {
            let amountAboveMaxSizeStr = sendMaxInfo.amountAboveMaxSize / 1e8;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountAboveMaxSizeStr}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { amountAboveMaxSizeStr, coin: this.tx.coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
    getTxp(tx, wallet, dryRun) {
        return new Promise((resolve, reject) => {
            // ToDo: use a credential's (or fc's) function for this
            if (tx.description && !wallet.credentials.sharedEncryptingKey) {
                let msg = this.translate.instant('Could not add message to imported wallet without shared encrypting key');
                this.setSendError(msg);
                return reject(msg);
            }
            if (tx.amount > Number.MAX_SAFE_INTEGER) {
                let msg = this.translate.instant('Amount too big');
                this.setSendError(msg);
                return reject(msg);
            }
            let txp = {};
            txp.outputs = [
                {
                    toAddress: tx.toAddress,
                    amount: tx.amount,
                    message: tx.description
                }
            ];
            if (tx.sendMaxInfo) {
                txp.inputs = tx.sendMaxInfo.inputs;
                txp.fee = tx.sendMaxInfo.fee;
            }
            else {
                if (this.usingCustomFee || this.usingMerchantFee) {
                    txp.feePerKb = tx.feeRate;
                }
                else
                    txp.feeLevel = tx.feeLevel;
            }
            txp.message = tx.description;
            if (tx.paypro) {
                txp.payProUrl = tx.paypro.url;
            }
            txp.excludeUnconfirmedUtxos = !tx.spendUnconfirmed;
            txp.dryRun = dryRun;
            if (tx.recipientType == 'wallet') {
                txp.customData = {
                    toWalletName: tx.name ? tx.name : null
                };
            }
            this.walletProvider
                .createTx(wallet, txp)
                .then(ctxp => {
                return resolve(ctxp);
            })
                .catch(err => {
                this.setSendError(err);
                return reject(err);
            });
        });
    }
    setSendError(error) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        if (error.message === __WEBPACK_IMPORTED_MODULE_19__providers_touchid_touchid__["a" /* TouchIdErrors */].fingerprintCancelled) {
            return;
        }
        this.popupProvider.ionicAlert(this.translate.instant('Error'), this.bwcErrorProvider.msg(error));
    }
    toggleAddress() {
        this.showAddress = !this.showAddress;
    }
    onWalletSelect(wallet) {
        this.setWallet(wallet);
    }
    showDescriptionPopup(tx) {
        let message = this.translate.instant('Add Memo');
        let opts = {
            defaultText: tx.description
        };
        this.popupProvider.ionicPrompt(null, message, opts).then((res) => {
            if (res) {
                tx.description = res;
            }
        });
    }
    approve(tx, wallet) {
        if (!tx || !wallet)
            return undefined;
        if (this.paymentExpired) {
            this.popupProvider.ionicAlert(null, this.translate.instant('This bastoji payment request has expired.'));
            return undefined;
        }
        this.onGoingProcessProvider.set('creatingTx');
        return this.getTxp(__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](tx), wallet, false)
            .then(txp => {
            return this.confirmTx(tx, txp, wallet).then((nok) => {
                if (nok) {
                    if (this.isCordova)
                        this.slideButton.isConfirmed(false);
                    this.onGoingProcessProvider.clear();
                    return;
                }
                this.publishAndSign(txp, wallet);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Error getting transaction proposal', err);
            return;
        });
    }
    confirmTx(_, txp, wallet) {
        return new Promise(resolve => {
            if (this.walletProvider.isEncrypted(wallet))
                return resolve();
            this.txFormatProvider.formatToUSD(wallet.coin, txp.amount).then(val => {
                let amountUsd = parseFloat(val);
                if (amountUsd <= this.CONFIRM_LIMIT_USD)
                    return resolve();
                let amount = (this.tx.amount / 1e8).toFixed(8);
                let unit = txp.coin.toUpperCase();
                let name = wallet.name;
                let message = this.replaceParametersProvider.replace(this.translate.instant('Sending {{amount}} {{unit}} from your {{name}} wallet'), { amount, unit, name });
                let okText = this.translate.instant('Confirm');
                let cancelText = this.translate.instant('Cancel');
                this.popupProvider
                    .ionicConfirm(null, message, okText, cancelText)
                    .then((ok) => {
                    return resolve(!ok);
                });
            });
        });
    }
    onlyPublish(txp, wallet) {
        this.logger.info('No signing proposal: No private key');
        this.onGoingProcessProvider.set('sendingTx');
        return this.walletProvider
            .onlyPublish(wallet, txp)
            .then(() => {
            this.onGoingProcessProvider.clear();
            this.openFinishModal(true);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.setSendError(err);
        });
    }
    openFinishModal(onlyPublish) {
        let params = {
            finishText: this.successText
        };
        if (onlyPublish) {
            let finishText = this.translate.instant('Payment Published');
            let finishComment = this.translate.instant('You could sign the transaction later in your wallet details');
            params = { finishText, finishComment };
        }
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], params, {
            showBackdrop: true,
            enableBackdropDismiss: false
        });
        modal.present();
        this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_7__tabs_tabs__["a" /* TabsPage */]);
    }
    openPPModal() {
        if (!this.wallet)
            return;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__paypro_paypro__["a" /* PayProPage */], {
            tx: this.tx,
            wallet: this.wallet
        }, {
            showBackdrop: true,
            enableBackdropDismiss: true
        });
        modal.present();
    }
    chooseFeeLevel() {
        if (this.tx.coin == 'bch')
            return;
        if (this.usingMerchantFee)
            return; // TODO: should we allow override?
        let txObject = {
            network: this.tx.network,
            feeLevel: this.tx.feeLevel,
            noSave: true,
            coin: this.tx.coin,
            customFeePerKB: this.usingCustomFee ? this.tx.feeRate : undefined,
            feePerSatByte: this.usingCustomFee ? this.tx.feeRate / 1000 : undefined
        };
        const myModal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_8__choose_fee_level_choose_fee_level__["a" /* ChooseFeeLevelPage */], txObject, {
            showBackdrop: true,
            enableBackdropDismiss: false
        });
        myModal.present();
        myModal.onDidDismiss(data => {
            this.onFeeModalDismiss(data);
        });
    }
    onFeeModalDismiss(data) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](data))
            return;
        this.logger.debug('New fee level chosen:' + data.newFeeLevel + ' was:' + this.tx.feeLevel);
        this.usingCustomFee = data.newFeeLevel == 'custom' ? true : false;
        if (this.tx.feeLevel == data.newFeeLevel && !this.usingCustomFee) {
            return;
        }
        this.tx.feeLevel = data.newFeeLevel;
        const feeOpts = this.feeProvider.getFeeOpts();
        this.tx.feeLevelName = feeOpts[this.tx.feeLevel];
        if (this.usingCustomFee)
            this.tx.feeRate = parseInt(data.customFeePerKB, 10);
        this.updateTx(this.tx, this.wallet, {
            clearCache: true,
            dryRun: true
        }).catch(err => {
            this.logger.warn('Error updateTx', err);
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, this.walletSelectorTitle);
        this.events.subscribe('selectWalletEvent', wallet => {
            this.onSelectWalletEvent(wallet);
        });
    }
    onSelectWalletEvent(wallet) {
        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
            this.onWalletSelect(wallet);
        this.events.unsubscribe('selectWalletEvent');
        this.isOpenSelector = false;
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], ConfirmPage.prototype, "slideButton", void 0);
ConfirmPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-confirm',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/send/confirm/confirm.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ \'Confirm\' | translate }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list *ngIf="tx">\n    <ion-item>\n      <div class="header-container">\n        <div class="sending-label">\n          <img class="sending-img" src="assets/img/icon-tx-sent-outline.svg">\n          <span translate *ngIf="!tx.sendMax">Sending</span>\n          <span translate *ngIf="tx.sendMax">Sending maximum amount</span>\n        </div>\n        <div class="amount-label">\n          <div class="amount">{{tx.amount | satToUnit: tx.coin}}</div>\n          <div class="alternative">{{tx.amount | satToFiat: tx.coin}}</div>\n        </div>\n      </div>\n    </ion-item>\n    <button ion-item class="item-fee" (click)="chooseFeeLevel()">\n      <div class="fee-title">\n        <span translate>Bastoji miner fee:</span> {{tx.feeLevelName | translate}}\n      </div>\n      <div class="fee-loading" *ngIf="!wallet || !tx.txp[wallet.id]">\n        <div>...</div>\n        <div>...</div>\n      </div>\n      <div *ngIf="wallet && tx.txp[wallet.id]">\n        <span class="fee-amount">{{tx.txp[wallet.id].fee | satToUnit: tx.coin}}</span>\n        <div class="fee-details">\n          {{tx.txp[wallet.id].fee | satToFiat: tx.coin}}\n          <span *ngIf="tx.txp[wallet.id].feeRatePerStr">\n            &middot;\n            <span [ngClass]="{\'warn\':tx.txp[wallet.id].feeTooHigh}">\n              <ion-icon *ngIf="tx.txp[wallet.id].feeTooHigh" name="warning"></ion-icon>\n              {{tx.txp[wallet.id].feeRatePerStr}}\n              <span translate> of total amount</span>\n            </span>\n          </span>\n        </div>\n      </div>\n    </button>\n\n    <ion-item *ngIf="tx.paypro && !criticalError">\n      <span translate>Payment Expires:</span>\n      <ion-note *ngIf="!paymentExpired" item-end>{{remainingTimeStr}}</ion-note>\n      <ion-note *ngIf="paymentExpired" [ngStyle]="{\'color\': \'red\'}" item-end>{{\'Expired\' | translate}}</ion-note>\n    </ion-item>\n\n    <ion-item class="container-to" *ngIf="!criticalError">\n      <span translate>To</span>\n\n      <div class="payment-proposal-to" *ngIf="!tx.recipientType">\n        <img class="icon-bastoji" src="assets/img/icon-bastoji-small.svg">\n        <div class="ellipsis" *ngIf="!tx.paypro" copy-to-clipboard="{{ tx.origToAddress }}">\n          <!--TODO: <contact *ngIf="tx.origToAddress && !tx.name" address="{{tx.origToAddress}}"></contact>-->\n          <span *ngIf="!tx.name">{{tx.origToAddress}}</span>\n          <span *ngIf="tx.name">{{tx.name}}</span>\n        </div>\n\n        <div class="paypro" *ngIf="tx.paypro" (click)="openPPModal(tx.paypro)">\n\n          <ion-icon *ngIf="tx.paypro.verified && tx.paypro.caTrusted" name="lock" color="success"></ion-icon>\n          <ion-icon *ngIf="!tx.paypro.verified && tx.paypro.caTrusted" name="unlock" color="warning"></ion-icon>\n          <ion-icon *ngIf="!tx.paypro.caTrusted" name="unlock" color="danger"></ion-icon>\n\n          <span [hidden]="tx.name">{{tx.paypro.domain || tx.paypro.toAddress}}</span>\n          <span [hidden]="!tx.name">{{tx.name}}</span>\n        </div>\n      </div>\n\n      <div class="wallet" *ngIf="tx.recipientType == \'wallet\'">\n        <ion-icon item-start>\n          <img *ngIf="tx.network == \'testnet\'" [ngStyle]="{\'background-color\': tx.color}" src="assets/img/icon-wallet-testnet.svg"\n            class="icon-wallet" />\n          <img *ngIf="tx.network != \'testnet\'" [ngStyle]="{\'background-color\': tx.color}" src="assets/img/icon-wallet.svg" class="icon-wallet"\n          />\n        </ion-icon>\n        <div class="ellipsis" copy-to-clipboard="{{ tx.origToAddress }}">\n          <!--TODO: <contact ng-if="tx.origToAddress && !tx.name" address="{{tx.origToAddress}}"></contact>-->\n          <span *ngIf="!tx.name">{{tx.origToAddress}}</span>\n          <span *ngIf="tx.name">{{tx.name}}</span>\n        </div>\n      </div>\n\n      <div class="wallet" *ngIf="tx.recipientType == \'contact\'" (longPress)="toggleAddress()">\n        <ion-icon class="item-gravatar" item-left>\n          <gravatar [name]="tx.name" [height]="35" [width]="35" [email]="tx.email"></gravatar>\n        </ion-icon>\n        <div class="ellipsis">\n          <span *ngIf="tx.name && !showAddress">{{tx.name}}</span>\n          <span *ngIf="tx.name && showAddress" copy-to-clipboard="{{ tx.toAddress }}">{{tx.toAddress}}</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <button class="container-from" ion-item detail-none (click)="showWallets()">\n      <span translate>From</span>\n      <div class="wallet" *ngIf="wallet">\n        <ion-icon item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg"\n            class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg"\n            class="icon-wallet" />\n        </ion-icon>\n        <div>{{wallet.name}}</div>\n        <div class="last-item" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n      <div class="wallet" *ngIf="!wallet">\n        <ion-icon item-start>\n          <img class="icon-wallet disabled" src="assets/img/icon-wallet.svg" />\n        </ion-icon>\n        <div translate>Select a wallet</div>\n        <div class="last-item" item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </div>\n    </button>\n\n    <editable-item (focus)="memoFocused = $event" (valChange)="tx.description = $event" [value]="tx.description" [itemPlaceholder]="\'Enter a transaction memo\' | translate">\n      <span item-label translate>Memo</span>\n    </editable-item>\n\n  </ion-list>\n\n\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [ngClass]="{\'slide-confirm-fast\': memoFocused, \'slide-confirm-slow\': !memoFocused, \'slide-confirm-down\': memoFocused}"\n    [disabled]="!wallet || noWalletMessage || criticalError || !tx?.txp[wallet.id]" [buttonText]="buttonText" (slideDone)="approve(tx, wallet)"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="approve(tx, wallet)" [disabled]="!wallet || noWalletMessage || criticalError || !tx.txp[wallet.id]">{{buttonText}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/send/confirm/confirm.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_tx_confirm_notification_tx_confirm_notification__["a" /* TxConfirmNotificationProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_21__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], ConfirmPage);

//# sourceMappingURL=confirm.js.map

/***/ }),

/***/ 356:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxConfirmNotificationProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__ = __webpack_require__(29);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers

let TxConfirmNotificationProvider = class TxConfirmNotificationProvider {
    constructor(logger, persistenceProvider) {
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.logger.info('TxConfirmNotificationProvider initialized.');
    }
    checkIfEnabled(txid) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getTxConfirmNotification(txid)
                .then(res => {
                return resolve(!!res);
            })
                .catch(err => {
                this.logger.error(err);
                return reject(err);
            });
        });
    }
    subscribe(client, opts) {
        client.txConfirmationSubscribe(opts, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider
                .setTxConfirmNotification(opts.txid, true)
                .catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
    unsubscribe(client, txId) {
        client.txConfirmationUnsubscribe(txId, err => {
            if (err)
                this.logger.error(err);
            this.persistenceProvider.removeTxConfirmNotification(txId).catch(err => {
                this.logger.error(err);
                return;
            });
        });
    }
};
TxConfirmNotificationProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__persistence_persistence__["a" /* PersistenceProvider */]])
], TxConfirmNotificationProvider);

//# sourceMappingURL=tx-confirm-notification.js.map

/***/ }),

/***/ 357:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardIntroPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_account_bitpay_account__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__bitpay_card__ = __webpack_require__(242);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




// pages

let BitPayCardIntroPage = class BitPayCardIntroPage {
    constructor(translate, actionSheetCtrl, navParams, bitPayAccountProvider, popupProvider, bitPayCardProvider, navCtrl, externalLinkProvider) {
        this.translate = translate;
        this.actionSheetCtrl = actionSheetCtrl;
        this.navParams = navParams;
        this.bitPayAccountProvider = bitPayAccountProvider;
        this.popupProvider = popupProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.navCtrl = navCtrl;
        this.externalLinkProvider = externalLinkProvider;
    }
    ionViewWillEnter() {
        if (this.navParams.data.secret) {
            let pairData = {
                secret: this.navParams.data.secret,
                email: this.navParams.data.email,
                otp: this.navParams.data.otp
            };
            let pairingReason = this.translate.instant('add your BitPay Visa card(s)');
            this.bitPayAccountProvider.pair(pairData, pairingReason, (err, paired, apiContext) => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error pairing BitPay Account'), err);
                    return;
                }
                if (paired) {
                    this.bitPayCardProvider.sync(apiContext, (err, cards) => {
                        if (err) {
                            this.popupProvider.ionicAlert(this.translate.instant('Error updating Debit Cards'), err);
                            return;
                        }
                        // Fixes mobile navigation
                        setTimeout(() => {
                            if (cards[0]) {
                                this.navCtrl
                                    .push(__WEBPACK_IMPORTED_MODULE_8__bitpay_card__["a" /* BitPayCardPage */], { id: cards[0].id }, { animate: false })
                                    .then(() => {
                                    let previousView = this.navCtrl.getPrevious();
                                    this.navCtrl.removeView(previousView);
                                });
                            }
                        }, 200);
                    });
                }
            });
        }
        this.bitPayAccountProvider.getAccounts((err, accounts) => {
            if (err) {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            }
            this.accounts = accounts;
        });
    }
    bitPayCardInfo() {
        let url = 'https://bitpay.com/visa/faq';
        this.externalLinkProvider.open(url);
    }
    orderBitPayCard() {
        let url = 'https://bitpay.com/visa/get-started';
        this.externalLinkProvider.open(url);
    }
    connectBitPayCard() {
        if (this.accounts.length == 0) {
            this.startPairBitPayAccount();
        }
        else {
            this.showAccountSelector();
        }
    }
    startPairBitPayAccount() {
        this.navCtrl.popToRoot({ animate: false }); // Back to Root
        let url = 'https://bitpay.com/visa/dashboard/add-to-bitpay-wallet-confirm';
        this.externalLinkProvider.open(url);
    }
    showAccountSelector() {
        let options = [];
        __WEBPACK_IMPORTED_MODULE_3_lodash__["forEach"](this.accounts, account => {
            options.push({
                text: (account.givenName || account.familyName) +
                    ' (' +
                    account.email +
                    ')',
                handler: () => {
                    this.onAccountSelect(account);
                }
            });
        });
        // Add account
        options.push({
            text: this.translate.instant('Add account'),
            handler: () => {
                this.onAccountSelect();
            }
        });
        // Cancel
        options.push({
            text: this.translate.instant('Cancel'),
            role: 'cancel'
        });
        let actionSheet = this.actionSheetCtrl.create({
            title: this.translate.instant('From BitPay account'),
            buttons: options
        });
        actionSheet.present();
    }
    onAccountSelect(account) {
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isUndefined"](account)) {
            this.startPairBitPayAccount();
        }
        else {
            this.bitPayCardProvider.sync(account.apiContext, err => {
                if (err) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                    return;
                }
                this.navCtrl.pop();
            });
        }
    }
};
BitPayCardIntroPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-bitpay-card-intro',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card-intro/bitpay-card-intro.html"*/'<ion-header no-border>\n  <ion-navbar transparent>\n    <ion-buttons right>\n      <button ion-button icon-only (click)="bitPayCardInfo()">\n        <ion-icon name="information-circle"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="bitpayCard-illustration">\n    <img class="bitpayCard-illustration-img" src="assets/img/bitpay-card/bitpay-card-visa.svg" />\n  </div>\n  <ion-slides pager="true">\n    <ion-slide>\n      <p class="slider-text" translate>\n        Turn bastoji into dollars, swipe anywhere Visa is accepted.\n      </p>\n    </ion-slide>\n    <ion-slide>\n      <p class="slider-text" translate>\n        Get local cash anywhere you go, from any Visa compatible ATM. ATM bank fees may apply.\n      </p>\n    </ion-slide>\n    <ion-slide>\n      <p class="slider-text" translate>\n        Pay 0% fees to turn bastoji into dollars.\n      </p>\n    </ion-slide>\n  </ion-slides>\n  <div padding>\n    <button ion-button class="button-standard" (click)="orderBitPayCard()">\n      {{\'Order the BitPay Card\' | translate}}\n    </button>\n    <button ion-button clear color="blank" class="button-standard" (click)="connectBitPayCard()">\n      {{\'Connect my BitPay Card\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card-intro/bitpay-card-intro.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_account_bitpay_account__["a" /* BitPayAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], BitPayCardIntroPage);

//# sourceMappingURL=bitpay-card-intro.js.map

/***/ }),

/***/ 358:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayAccountProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_device__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__ = __webpack_require__(218);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__bitpay_bitpay__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__replace_parameters_replace_parameters__ = __webpack_require__(57);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// native

// providers








let BitPayAccountProvider = class BitPayAccountProvider {
    /*
     * Pair this app with the bitpay server using the specified pairing data.
     * An app identity will be created if one does not already exist.
     * Pairing data is provided by an input URI provided by the bitpay server.
     *
     * pairData - data needed to complete the pairing process
     * {
     *   secret: shared pairing secret
     *   email: email address associated with bitpay account
     *   otp: two-factor one-time use password
     * }
     *
     * pairingReason - text string to be embedded into popup message.  If `null` then the reason
     * message is not shown to the UI.
     *   "To {{reason}} you must pair this app with your BitPay account ({{email}})."
     *
     * cb - callback after completion
     *   callback(err, paired, apiContext)
     *
     *   err - something unexpected happened which prevented the pairing
     *
     *   paired - boolean indicating whether the pairing was compledted by the user
     *
     *   apiContext - the context needed for making future api calls
     *   {
     *     token: api token for use in future calls
     *     pairData: the input pair data
     *     appIdentity: the identity of this app
     *   }
     */
    constructor(platformProvider, replaceParametersProvider, bitPayProvider, logger, onGoingProcessProvider, popupProvider, persistenceProvider, appIdentityProvider, device, translate) {
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.bitPayProvider = bitPayProvider;
        this.logger = logger;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.persistenceProvider = persistenceProvider;
        this.appIdentityProvider = appIdentityProvider;
        this.device = device;
        this.translate = translate;
        this.logger.info('BitPayAccountProvider initialized');
    }
    pair(pairData, pairingReason, cb) {
        this.checkOtp(pairData, otp => {
            pairData.otp = otp;
            let deviceName = 'Unknown device';
            if (this.platformProvider.isNW) {
                deviceName = __webpack_require__(1175).platform();
            }
            else if (this.platformProvider.isCordova) {
                deviceName = this.device.model;
            }
            let json = {
                method: 'createToken',
                params: {
                    secret: pairData.secret,
                    version: 2,
                    deviceName,
                    code: pairData.otp
                }
            };
            this.onGoingProcessProvider.set('fetchingBitPayAccount');
            this.bitPayProvider.postAuth(json, data => {
                if (data && data.error) {
                    this.onGoingProcessProvider.clear();
                    return cb(data.error);
                }
                let apiContext = {
                    token: data.data,
                    pairData,
                    appIdentity: data.appIdentity
                };
                this.logger.info('BitPay service BitAuth create token: SUCCESS');
                this.fetchBasicInfo(apiContext, (err, basicInfo) => {
                    this.onGoingProcessProvider.clear();
                    if (err)
                        return cb(err);
                    let title = this.translate.instant('Add BitPay Account?');
                    let msg;
                    if (pairingReason) {
                        let reason = pairingReason;
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('To {{reason}} you must first add your BitPay account - {{email}}'), { reason, email });
                    }
                    else {
                        let email = pairData.email;
                        msg = this.replaceParametersProvider.replace(this.translate.instant('Add this BitPay account ({{email}})?'), { email });
                    }
                    let ok = this.translate.instant('Add account');
                    let cancel = this.translate.instant('Go Back');
                    this.popupProvider
                        .ionicConfirm(title, msg, ok, cancel)
                        .then(res => {
                        if (res) {
                            let acctData = {
                                token: apiContext.token,
                                email: pairData.email,
                                givenName: basicInfo.givenName,
                                familyName: basicInfo.familyName
                            };
                            this.setBitpayAccount(acctData);
                            return cb(null, true, apiContext);
                        }
                        else {
                            this.logger.info('User cancelled BitPay pairing process');
                            return cb(null, false);
                        }
                    });
                });
            }, data => {
                return cb(this._setError('BitPay service BitAuth create token: ERROR ', data));
            });
        });
    }
    checkOtp(pairData, cb) {
        if (pairData.otp) {
            let msg = this.translate.instant('Enter Two Factor for your BitPay account');
            this.popupProvider.ionicPrompt(null, msg, null).then(res => {
                cb(res);
            });
        }
        else {
            cb();
        }
    }
    fetchBasicInfo(apiContext, cb) {
        let json = {
            method: 'getBasicInfo'
        };
        // Get basic account information
        this.bitPayProvider.post('/api/v2/' + apiContext.token, json, data => {
            if (data && data.error)
                return cb(data.error);
            this.logger.info('BitPay Account Get Basic Info: SUCCESS');
            return cb(null, data.data);
        }, data => {
            return cb(this._setError('BitPay Account Error: Get Basic Info', data));
        });
    }
    // Returns account objects as stored.
    getAccountsAsStored(cb) {
        this.persistenceProvider
            .getBitpayAccounts(this.bitPayProvider.getEnvironment().network)
            .then(accounts => {
            return cb(null, accounts);
        })
            .catch(err => {
            return cb(err, []);
        });
    }
    // Returns an array where each element represents an account including all information required for fetching data
    // from the server for each account (apiContext).
    getAccounts(cb) {
        this.getAccountsAsStored((err, accounts) => {
            if (err || __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](accounts)) {
                return cb(err, []);
            }
            this.appIdentityProvider.getIdentity(this.bitPayProvider.getEnvironment().network, (err, appIdentity) => {
                if (err) {
                    return cb(err);
                }
                let accountsArray = [];
                __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](Object.keys(accounts), key => {
                    accounts[key].cards = accounts[key].cards;
                    accounts[key].email = key;
                    accounts[key].givenName = accounts[key].givenName || '';
                    accounts[key].familyName = accounts[key].familyName || '';
                    accounts[key].apiContext = {
                        token: accounts[key].token,
                        pairData: {
                            email: key
                        },
                        appIdentity
                    };
                    accountsArray.push(accounts[key]);
                });
                return cb(null, accountsArray);
            });
        });
    }
    setBitpayAccount(account) {
        this.persistenceProvider.setBitpayAccount(this.bitPayProvider.getEnvironment().network, account);
    }
    removeAccount(email, cb) {
        this.persistenceProvider
            .removeBitpayAccount(this.bitPayProvider.getEnvironment().network, email)
            .then(() => {
            return cb();
        });
    }
    _setError(msg, e) {
        this.logger.error(msg);
        let error = e && e.data && e.data.error ? e.data.error : msg;
        return error;
    }
};
BitPayAccountProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_5__bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_6__logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_10__popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_4__app_identity_app_identity__["a" /* AppIdentityProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], BitPayAccountProvider);

//# sourceMappingURL=bitpay-account.js.map

/***/ }),

/***/ 367:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_incoming_data_incoming_data__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_scan_scan__ = __webpack_require__(820);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__paper_wallet_paper_wallet__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__settings_addressbook_add_add__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__environments__ = __webpack_require__(328);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




// pages




let ScanPage = class ScanPage {
    constructor(navCtrl, scanProvider, platform, incomingDataProvider, events, externalLinkProvider, logger, translate, navParams) {
        this.navCtrl = navCtrl;
        this.scanProvider = scanProvider;
        this.platform = platform;
        this.incomingDataProvider = incomingDataProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.translate = translate;
        this.navParams = navParams;
        this.ngVersion = __WEBPACK_IMPORTED_MODULE_0__angular_core__["VERSION"].full;
        this.hasCameras = false;
        this.isCameraSelected = false;
        this.browserScanEnabled = false;
        this.canEnableLight = true;
        this.canChangeCamera = true;
        this.scannerStates = {
            unauthorized: 'unauthorized',
            denied: 'denied',
            unavailable: 'unavailable',
            loading: 'loading',
            visible: 'visible'
        };
        this.scannerIsAvailable = true;
        this.scannerHasPermission = false;
        this.scannerIsDenied = false;
        this.scannerIsRestricted = false;
        this.canOpenSettings = false;
        this.isCordova = this.platform.isCordova;
        if (this.navParams.data.fromAddressbook) {
            this.tabBarElement = document.querySelector('.tabbar.show-tabbar');
            this.tabBarElement.style.display = 'none';
        }
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ScanPage');
    }
    ionViewWillLeave() {
        this.events.unsubscribe('finishIncomingDataMenuEvent');
        this.events.unsubscribe('scannerServiceInitialized');
        if (this.navParams.data.fromAddressbook) {
            this.tabBarElement.style.display = 'flex';
        }
        if (!this.isCordova) {
            this.scanner.resetScan();
        }
        else {
            this.cameraToggleActive = false;
            this.lightActive = false;
            this.scanProvider.frontCameraEnabled = false;
            this.scanProvider.deactivate();
        }
    }
    ionViewWillEnter() {
        if (!__WEBPACK_IMPORTED_MODULE_11__environments__["a" /* default */].activateScanner) {
            // test scanner visibility in E2E mode
            this.selectedDevice = true;
            this.hasPermission = true;
            return;
        }
        this.events.subscribe('finishIncomingDataMenuEvent', data => {
            if (!this.isCordova) {
                this.scanner.resetScan();
            }
            switch (data.redirTo) {
                case 'AmountPage':
                    this.sendPaymentToAddress(data.value, data.coin);
                    break;
                case 'AddressBookPage':
                    this.addToAddressBook(data.value);
                    break;
                case 'OpenExternalLink':
                    this.goToUrl(data.value);
                    break;
                case 'PaperWalletPage':
                    this.scanPaperWallet(data.value);
                    break;
                default:
                    if (this.isCordova) {
                        this.activate();
                    }
                    else if (this.isCameraSelected) {
                        this.scanner.startScan(this.selectedDevice);
                    }
            }
        });
        if (!this.isCordova) {
            if (!this.isCameraSelected) {
                this.loadCamera();
            }
            else {
                this.scanner.startScan(this.selectedDevice);
            }
        }
        else {
            // try initializing and refreshing status any time the view is entered
            if (this.scannerHasPermission) {
                this.activate();
            }
            else {
                if (!this.scanProvider.isInitialized()) {
                    this.scanProvider.gentleInitialize().then(() => {
                        this.authorize();
                    });
                }
                else {
                    this.authorize();
                }
            }
            this.events.subscribe('scannerServiceInitialized', () => {
                this.logger.debug('Scanner initialization finished, reinitializing scan view...');
                this._refreshScanView();
            });
        }
    }
    loadCamera() {
        this.scanner.camerasFound.subscribe((devices) => {
            this.hasCameras = true;
            this.availableDevices = devices;
            this.onDeviceSelectChange();
        });
        this.scanner.camerasNotFound.subscribe(() => {
            this.logger.error('An error has occurred when trying to enumerate your video-stream-enabled devices.');
        });
        this.scanner.askForPermission().subscribe((answer) => {
            this.hasPermission = answer;
        });
    }
    goToUrl(url) {
        this.externalLinkProvider.open(url);
    }
    sendPaymentToAddress(bastojiAddress, coin) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__send_amount_amount__["a" /* AmountPage */], { toAddress: bastojiAddress, coin });
    }
    addToAddressBook(bastojiAddress) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__settings_addressbook_add_add__["a" /* AddressbookAddPage */], { addressbookEntry: bastojiAddress });
    }
    scanPaperWallet(privateKey) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__paper_wallet_paper_wallet__["a" /* PaperWalletPage */], { privateKey });
    }
    updateCapabilities() {
        let capabilities = this.scanProvider.getCapabilities();
        this.scannerIsAvailable = capabilities.isAvailable;
        this.scannerHasPermission = capabilities.hasPermission;
        this.scannerIsDenied = capabilities.isDenied;
        this.scannerIsRestricted = capabilities.isRestricted;
        this.canEnableLight = capabilities.canEnableLight;
        this.canChangeCamera = capabilities.canChangeCamera;
        this.canOpenSettings = capabilities.canOpenSettings;
    }
    handleCapabilities() {
        // always update the view
        if (!this.scanProvider.isInitialized()) {
            this.currentState = this.scannerStates.loading;
        }
        else if (!this.scannerIsAvailable) {
            this.currentState = this.scannerStates.unavailable;
        }
        else if (this.scannerIsDenied) {
            this.currentState = this.scannerStates.denied;
        }
        else if (this.scannerIsRestricted) {
            this.currentState = this.scannerStates.denied;
        }
        else if (!this.scannerHasPermission) {
            this.currentState = this.scannerStates.unauthorized;
        }
        this.logger.debug('Scan view state set to: ' + this.currentState);
    }
    _refreshScanView() {
        this.updateCapabilities();
        this.handleCapabilities();
        if (this.scannerHasPermission) {
            this.activate();
        }
    }
    activate() {
        this.scanProvider.activate().then(() => {
            this.updateCapabilities();
            this.handleCapabilities();
            this.logger.debug('Scanner activated, setting to visible...');
            this.currentState = this.scannerStates.visible;
            // resume preview if paused
            this.scanProvider.resumePreview();
            this.scanProvider.scan().then((contents) => {
                this.scanProvider.pausePreview();
                this.handleSuccessfulScan(contents);
            });
        });
    }
    handleSuccessfulScan(contents) {
        this.logger.debug('Scan returned: "' + contents + '"');
        let fromAddressbook = this.navParams.data.fromAddressbook;
        if (fromAddressbook) {
            this.events.publish('update:address', { value: contents });
            this.navCtrl.pop();
        }
        else {
            this.incomingDataProvider.redir(contents, 'ScanPage');
        }
    }
    authorize() {
        this.scanProvider.initialize().then(() => {
            this._refreshScanView();
        });
    }
    attemptToReactivate() {
        this.scanProvider.reinitialize();
    }
    openSettings() {
        this.scanProvider.openSettings();
    }
    toggleLight() {
        this.scanProvider
            .toggleLight()
            .then(resp => {
            this.lightActive = resp;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + error);
        });
    }
    toggleCamera() {
        this.scanProvider
            .toggleCamera()
            .then(resp => {
            this.cameraToggleActive = resp;
            this.lightActive = false;
        })
            .catch(error => {
            this.logger.warn('scanner error: ' + error);
        });
    }
    handleQrCodeResult(resultString) {
        this.scanner.resetScan();
        setTimeout(() => {
            this.handleSuccessfulScan(resultString);
        }, 0);
    }
    onDeviceSelectChange() {
        if (!this.isCameraSelected) {
            for (const device of this.availableDevices) {
                if (device.kind == 'videoinput') {
                    this.selectedDevice = this.scanner.getDeviceById(device.deviceId);
                    this.isCameraSelected = true;
                    break;
                }
            }
        }
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('scanner'),
    __metadata("design:type", Object)
], ScanPage.prototype, "scanner", void 0);
ScanPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-scan',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/scan/scan.html"*/'<ion-header>\n  <ion-navbar class="navbar-transparent">\n    <ion-title>{{\'Scan\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content *ngIf="!isCordova">\n\n  <div [hidden]="!selectedDevice || !hasPermission">\n\n    <div [hidden]="!hasPermission" class="browser-scanner page-scan-camera-ready">\n\n      <zxing-scanner #scanner class="test-class" start="true" [device]="selectedDevice" (scanSuccess)="handleQrCodeResult($event)"></zxing-scanner>\n      <div class="guides">\n        <img class="svg qr-scan-guides" src="assets/img/bitpay-wallet-qr-scan-guides.svg">\n      </div>\n\n    </div>\n  </div>\n\n  <div *ngIf="!selectedDevice || !hasPermission" class="page-scan-has-problems">\n    <div class="header-container">\n      <div>\n        <div class="header" padding>\n          <div class="image-container">\n            <img src="assets/img/ico-receive.svg" />\n          </div>\n          <div class="title" padding translate>Scan QR Codes</div>\n        </div>\n        <div class="subtitle" translate>You can scan bastoji addresses, payment requests, paper wallets, and more.</div>\n      </div>\n    </div>\n    <div class="body">\n      <div padding>\n        <div *ngIf="hasPermission === false" translate>Enable the camera to get started.</div>\n        <div *ngIf="!hasCameras && hasPermission === true" translate>Please connect a camera to get started.</div>\n      </div>\n      <div>\n        <button ion-button outline class="button-standard" *ngIf="hasPermission === false" (click)="loadCamera()">\n          {{\'Retry camera\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n</ion-content>\n\n<ion-content *ngIf="isCordova" class="back-transparent" no-bounce>\n  <div class="page-scan-has-problems" *ngIf="(currentState == scannerStates.unauthorized || currentState == scannerStates.denied || currentState == scannerStates.unavailable)">\n    <div class="header-container">\n      <div>\n        <div class="header" padding>\n          <div class="image-container">\n            <img src="assets/img/ico-receive.svg" />\n          </div>\n          <div class="title" padding translate>Scan QR Codes</div>\n        </div>\n        <div class="subtitle" translate>You can scan bastoji addresses, payment requests, paper wallets, and more.</div>\n      </div>\n    </div>\n    <div class="body">\n      <div padding>\n        <div *ngIf="currentState == scannerStates.unauthorized" translate>Enable the camera to get started.</div>\n        <div *ngIf="currentState == scannerStates.denied" translate>Enable camera access in your device settings to get started.</div>\n        <div *ngIf="currentState == scannerStates.unavailable" translate>Please connect a camera to get started.</div>\n      </div>\n      <div>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unauthorized" (click)="authorize()">\n          {{\'Allow camera access\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.denied && canOpenSettings" (click)="openSettings()">\n          {{\'Open settings\' | translate}}\n        </button>\n        <button ion-button outline class="button-standard" *ngIf="currentState == scannerStates.unavailable" (click)="attemptToReactivate()">\n          {{\'Retry camera\' | translate}}\n        </button>\n      </div>\n    </div>\n  </div>\n  <div class="page-scan-loading-camera" *ngIf="currentState == scannerStates.loading"></div>\n  <div class="page-scan-camera-ready" *ngIf="currentState == scannerStates.visible">\n    <div class="guides">\n      <img class="svg qr-scan-guides" src="assets/img/bitpay-wallet-qr-scan-guides.svg">\n    </div>\n    <div class="scanner-controls">\n      <span *ngIf="canEnableLight" class="icon-flash" [ngClass]="{\'active\': lightActive}" (click)="toggleLight()"></span>\n      <span *ngIf="canChangeCamera" class="icon-camera-toggle" [ngClass]="{\'active\': cameraToggleActive}" (click)="toggleCamera()"></span>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/scan/scan.html"*/,
        providers: [__WEBPACK_IMPORTED_MODULE_7__providers_scan_scan__["a" /* ScanProvider */]]
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_scan_scan__["a" /* ScanProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */]])
], ScanPage);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 368:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Animate; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let Animate = class Animate {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
    }
    animate(animationName) {
        this.renderer.setElementClass(this.el.nativeElement, animationName, true);
        setTimeout(() => {
            this.renderer.setElementClass(this.el.nativeElement, animationName, false);
        }, 600);
    }
};
Animate = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Directive"])({
        selector: '[animate]'
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_core__["ElementRef"], __WEBPACK_IMPORTED_MODULE_0__angular_core__["Renderer"]])
], Animate);

//# sourceMappingURL=animate.js.map

/***/ }),

/***/ 369:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pages_wallet_details_wallet_details__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__all_addresses_all_addresses__ = __webpack_require__(846);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// providers






// pages



let WalletAddressesPage = class WalletAddressesPage {
    constructor(profileProvider, walletProvider, navCtrl, navParams, logger, bwcErrorProvider, popupProvider, onGoingProcessProvider, modalCtrl, txFormatProvider, translate) {
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.bwcErrorProvider = bwcErrorProvider;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.modalCtrl = modalCtrl;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.UNUSED_ADDRESS_LIMIT = 5;
        this.BALANCE_ADDRESS_LIMIT = 5;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.withBalance = null;
        this.noBalance = null;
    }
    ionViewWillEnter() {
        this.loading = true;
        this.walletProvider
            .getMainAddresses(this.wallet, {})
            .then(allAddresses => {
            this.walletProvider
                .getBalance(this.wallet, {})
                .then(resp => {
                this.withBalance = resp.byAddress;
                var idx = __WEBPACK_IMPORTED_MODULE_12_lodash__["keyBy"](this.withBalance, 'address');
                this.noBalance = __WEBPACK_IMPORTED_MODULE_12_lodash__["reject"](allAddresses, x => {
                    return idx[x.address];
                });
                this.processList(this.noBalance);
                this.processList(this.withBalance);
                this.latestUnused = __WEBPACK_IMPORTED_MODULE_12_lodash__["slice"](this.noBalance, 0, this.UNUSED_ADDRESS_LIMIT);
                this.latestWithBalance = __WEBPACK_IMPORTED_MODULE_12_lodash__["slice"](this.withBalance, 0, this.BALANCE_ADDRESS_LIMIT);
                this.viewAll =
                    this.noBalance.length > this.UNUSED_ADDRESS_LIMIT ||
                        this.withBalance.length > this.BALANCE_ADDRESS_LIMIT;
                this.loading = false;
            })
                .catch(err => {
                this.logger.error(err);
                this.loading = false;
                this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
            });
        })
            .catch(err => {
            this.logger.error(err);
            this.loading = false;
            this.popupProvider.ionicAlert(this.bwcErrorProvider.msg(err, this.translate.instant('Could not update wallet')));
        });
        this.walletProvider
            .getLowUtxos(this.wallet)
            .then(resp => {
            if (resp && resp.allUtxos && resp.allUtxos.length) {
                let allSum = __WEBPACK_IMPORTED_MODULE_12_lodash__["sumBy"](resp.allUtxos || 0, 'satoshis');
                let per = (resp.minFee / allSum) * 100;
                this.lowUtxosNb = resp.lowUtxos.length;
                this.allUtxosNb = resp.allUtxos.length;
                this.lowUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, __WEBPACK_IMPORTED_MODULE_12_lodash__["sumBy"](resp.lowUtxos || 0, 'satoshis'));
                this.allUtxosSum = this.txFormatProvider.formatAmountStr(this.wallet.coin, allSum);
                this.minFee = this.txFormatProvider.formatAmountStr(this.wallet.coin, resp.minFee || 0);
                this.minFeePer = per.toFixed(2) + '%';
            }
        })
            .catch(err => {
            this.logger.warn('GetLowUtxos', err);
        });
    }
    processList(list) {
        __WEBPACK_IMPORTED_MODULE_12_lodash__["each"](list, n => {
            n.path = n.path ? n.path.replace(/^m/g, 'xpub') : null;
            n.address = this.walletProvider.getAddressView(this.wallet, n.address);
        });
    }
    newAddress() {
        if (this.gapReached)
            return;
        this.onGoingProcessProvider.set('generatingNewAddress');
        this.walletProvider
            .getAddress(this.wallet, true)
            .then((addr) => {
            this.walletProvider
                .getMainAddresses(this.wallet, { limit: 1 })
                .then(_addr => {
                this.onGoingProcessProvider.clear();
                if (addr != _addr[0].address) {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('New address could not be generated. Please try again.'));
                    return;
                }
                this.noBalance = [_addr[0]].concat(this.noBalance);
                this.processList(this.noBalance);
                this.latestUnused = __WEBPACK_IMPORTED_MODULE_12_lodash__["slice"](this.noBalance, 0, this.UNUSED_ADDRESS_LIMIT);
                this.viewAll = this.noBalance.length > this.UNUSED_ADDRESS_LIMIT;
            })
                .catch(err => {
                this.logger.error(err);
                this.onGoingProcessProvider.clear();
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
            });
        })
            .catch(err => {
            this.logger.error(err);
            this.onGoingProcessProvider.clear();
            if (err.toString().match('MAIN_ADDRESS_GAP_REACHED')) {
                this.gapReached = true;
            }
            else {
                this.popupProvider.ionicAlert('Error', err);
            }
        });
    }
    viewAllAddresses() {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_11__all_addresses_all_addresses__["a" /* AllAddressesPage */], {
            noBalance: this.noBalance,
            withBalance: this.withBalance,
            coin: this.wallet.coin,
            walletName: this.wallet.name
        });
        modal.present();
    }
    scan() {
        return __awaiter(this, void 0, void 0, function* () {
            this.walletProvider.startScan(this.wallet);
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                walletId: this.wallet.credentials.walletId
            });
        });
    }
};
WalletAddressesPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-addresses',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Addresses\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <ion-item-divider text-center>\n    <span translate>\n      Each bastoji wallet can generate billions of addresses from your 12-word backup. A new address is automatically generated and shown each time you receive a payment.\n    </span>\n    <a (click)="showInfo = !showInfo" *ngIf="!showInfo" translate>Why?</a>\n\n    <div *ngIf="showInfo">\n      <br>\n      <span translate>\n        It\'s a good idea to avoid reusing addresses - this both protects your privacy and keeps your bastojis secure against hypothetical attacks by quantum computers.</span>\n      <a (click)="showInfo = !showInfo" translate>Hide</a>\n    </div>\n  </ion-item-divider>\n\n  <button ion-button class="button-standard" (click)="scan()">\n    <span translate>Scan addresses for funds</span>\n  </button>\n    \n  <ion-item-divider></ion-item-divider>\n\n  <button ion-item *ngIf="viewAll" (click)="viewAllAddresses()">\n    <span ion-text color="dark" translate>View all addresses</span>\n  </button>\n\n  <div class="loading" *ngIf="loading">\n    <ion-spinner icon="crescent"></ion-spinner>\n    <span translate>Loading addresses...</span>\n  </div>\n\n  <ion-list *ngIf="!loading">\n    <ion-item-divider>\n      {{\'Unused addresses\' | translate}}\n      <button ion-button clear item-end class="add-icon" (click)="newAddress()">\n        <ion-icon name="ios-add"></ion-icon>\n      </button>\n    </ion-item-divider>\n\n    <div *ngIf="latestUnused && latestUnused[0]">\n      <div *ngIf="gapReached">\n        <h5 translate>Unused addresses limit</h5>\n        <p>\n          <span translate>The maximum number of consecutive unused addresses (20) has been reached. When one of your unused addresses receives a payment, a new address will be generated and shown in your Receive tab.</span>\n          <a (click)="readMore()" *ngIf="!showMore" translate>Read more</a>\n        </p>\n        <p *ngIf="showMore">\n          <span translate>The restore process will stop when 20 addresses are generated in a row which contain no funds. To safely generate more addresses, make a payment to one of the unused addresses which has already been generated.</span>\n          <a (click)="readMore()" translate>Read less</a>\n        </p>\n      </div>\n\n      <ion-item *ngFor="let u of latestUnused" copy-to-clipboard="{{u.address}}">\n        <h3>{{u.address}}</h3>\n        <p>{{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}</p>\n      </ion-item>\n    </div>\n\n    <div *ngIf="latestWithBalance && latestWithBalance[0]">\n      <ion-item-divider>{{\'Addresses with balance\' | translate}}</ion-item-divider>\n\n      <ion-item *ngFor="let w of latestWithBalance" copy-to-clipboard="{{w.address}}">\n        <h3>{{w.address}}</h3>\n        <p class="info">{{w.amount | satToUnit: wallet.coin}}</p>\n      </ion-item>\n    </div>\n\n    <div *ngIf="allUtxosNb">\n      <ion-item-divider>{{\'Wallet Inputs\' | translate}}</ion-item-divider>\n\n      <ion-item>\n        <span translate>Total wallet inputs</span>\n        <p class="info">{{allUtxosNb}} [{{allUtxosSum}}]</p>\n      </ion-item>\n\n      <ion-item>\n        <span translate> Low amount inputs </span>\n        <p class="info">{{lowUtxosNb}} [{{ lowUtxosSum }}]</p>\n      </ion-item>\n\n      <ion-item>\n        <span translate>Approximate Bastoji network fee to transfer wallet\'s balance (with normal priority)</span>\n        <p class="info">{{minFeePer}} [{{minFee}}]</p>\n      </ion-item>\n    </div>\n  </ion-list>\n  <ion-item-divider></ion-item-divider>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/wallet-addresses.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_8__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], WalletAddressesPage);

//# sourceMappingURL=wallet-addresses.js.map

/***/ }),

/***/ 380:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 380;

/***/ }),

/***/ 39:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__ = __webpack_require__(1090);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let BwcProvider = class BwcProvider {
    constructor(logger) {
        this.logger = logger;
        this.buildTx = __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["buildTx"];
        this.parseSecret = __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["parseSecret"];
        this.Client = __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__;
        this.logger.info('BwcProvider initialized.');
    }
    getBitcore() {
        return __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["Bitcore"];
    }
    getBitcoreCash() {
        return __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["BitcoreCash"];
    }
    getErrors() {
        return __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["errors"];
    }
    getSJCL() {
        return __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["sjcl"];
    }
    getUtils() {
        return __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__["Utils"];
    }
    getClient(walletData, opts) {
        opts = opts || {};
        // note opts use `bwsurl` all lowercase;
        let bwc = new __WEBPACK_IMPORTED_MODULE_2_bitcore_wallet_client__({
            baseUrl: opts.bwsurl || 'https://bws.bitpay.com/bws/api',
            verbose: opts.verbose,
            timeout: 100000,
            transports: ['polling']
        });
        if (walletData)
            bwc.import(walletData, opts);
        return bwc;
    }
};
BwcProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */]])
], BwcProvider);

//# sourceMappingURL=bwc.js.map

/***/ }),

/***/ 426:
/***/ (function(module, exports) {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncatched exception popping up in devtools
	return Promise.resolve().then(function() {
		throw new Error("Cannot find module '" + req + "'.");
	});
}
webpackEmptyAsyncContext.keys = function() { return []; };
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
module.exports = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = 426;

/***/ }),

/***/ 46:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BwcErrorProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let BwcErrorProvider = class BwcErrorProvider {
    constructor(translate) {
        this.translate = translate;
    }
    msg(err, prefix) {
        if (!err)
            return 'Unknown error';
        const name = err.name
            ? err.name === 'Error'
                ? err.message
                : err.name.replace(/^bwc.Error/g, '')
            : err;
        let body = '';
        prefix = prefix || '';
        if (name) {
            switch (name) {
                case 'INVALID_BACKUP':
                    body = this.translate.instant('Wallet Recovery Phrase is invalid');
                    break;
                case 'WALLET_DOES_NOT_EXIST':
                    body = this.translate.instant('Wallet not registered at the wallet service. Recreate it from "Create Wallet" using "Advanced Options" to set your recovery phrase');
                    break;
                case 'MISSING_PRIVATE_KEY':
                    body = this.translate.instant('Missing private keys to sign');
                    break;
                case 'ENCRYPTED_PRIVATE_KEY':
                    body = this.translate.instant('Private key is encrypted, cannot sign');
                    break;
                case 'SERVER_COMPROMISED':
                    body = this.translate.instant('Server response could not be verified');
                    break;
                case 'COULD_NOT_BUILD_TRANSACTION':
                    body = this.translate.instant('Could not build transaction');
                    break;
                case 'INSUFFICIENT_FUNDS':
                    body = this.translate.instant('Insufficient funds');
                    break;
                case 'CONNECTION_ERROR':
                    body = this.translate.instant('Network error');
                    break;
                case 'NOT_FOUND':
                    body = this.translate.instant('Wallet service not found');
                    break;
                case 'ECONNRESET_ERROR':
                    body = this.translate.instant('Connection reset by peer');
                    break;
                case 'BAD_RESPONSE_CODE':
                    body = this.translate.instant('The request could not be understood by the server');
                    break;
                case 'WALLET_ALREADY_EXISTS':
                    body = this.translate.instant('Wallet already exists');
                    break;
                case 'COPAYER_IN_WALLET':
                    body = this.translate.instant('Sqoiner already in this wallet');
                    break;
                case 'WALLET_FULL':
                    body = this.translate.instant('Wallet is full');
                    break;
                case 'WALLET_NOT_FOUND':
                    body = this.translate.instant('Wallet not found');
                    break;
                case 'INSUFFICIENT_FUNDS_FOR_FEE':
                    body = this.translate.instant('Insufficient funds for fee');
                    break;
                case 'LOCKED_FUNDS':
                    body = this.translate.instant('Funds are locked by pending spend proposals');
                    break;
                case 'COPAYER_VOTED':
                    body = this.translate.instant('Sqoiner already voted on this spend proposal');
                    break;
                case 'NOT_AUTHORIZED':
                    body = this.translate.instant('Not authorized');
                    break;
                case 'TX_ALREADY_BROADCASTED':
                    body = this.translate.instant('Transaction already broadcasted');
                    break;
                case 'TX_CANNOT_CREATE':
                    body = this.translate.instant('Locktime in effect. Please wait to create a new spend proposal');
                    break;
                case 'TX_CANNOT_REMOVE':
                    body = this.translate.instant('Locktime in effect. Please wait to remove this spend proposal');
                    break;
                case 'TX_NOT_ACCEPTED':
                    body = this.translate.instant('Spend proposal is not accepted');
                    break;
                case 'TX_NOT_FOUND':
                    body = this.translate.instant('Spend proposal not found');
                    break;
                case 'TX_NOT_PENDING':
                    body = this.translate.instant('The spend proposal is not pending');
                    break;
                case 'UPGRADE_NEEDED':
                    body = this.translate.instant('Please upgrade Sqoin to perform this action');
                    break;
                case 'BAD_SIGNATURES':
                    body = this.translate.instant('Signatures rejected by server');
                    break;
                case 'COPAYER_DATA_MISMATCH':
                    body = this.translate.instant('Sqoiner data mismatch');
                    break;
                case 'DUST_AMOUNT':
                    body = this.translate.instant('Amount below minimum allowed');
                    break;
                case 'INCORRECT_ADDRESS_NETWORK':
                    body = this.translate.instant('Incorrect network address');
                    break;
                case 'COPAYER_REGISTERED':
                    body = this.translate.instant('Key already associated with an existing wallet');
                    break;
                case 'INVALID_ADDRESS':
                    body = this.translate.instant('Invalid address');
                    break;
                case 'MAIN_ADDRESS_GAP_REACHED':
                    body = this.translate.instant('Empty addresses limit reached. New addresses cannot be generated.');
                    break;
                case 'WALLET_LOCKED':
                    body = this.translate.instant('Wallet is locked');
                    break;
                case 'WALLET_NOT_COMPLETE':
                    body = this.translate.instant('Wallet is not complete');
                    break;
                case 'WALLET_NEEDS_BACKUP':
                    body = this.translate.instant('Wallet needs backup');
                    break;
                case 'MISSING_PARAMETER':
                    body = this.translate.instant('Missing parameter');
                    break;
                case 'NO_PASSWORD_GIVEN':
                    body = this.translate.instant('Encrypt password needed');
                    break;
                case 'PASSWORD_INCORRECT':
                    body = this.translate.instant('Wrong encrypt password');
                    break;
                case 'EXCEEDED_DAILY_LIMIT':
                    body = this.translate.instant('Exceeded daily limit of $500 per user');
                    break;
                case 'ERROR':
                    body = err.message || err.error;
                    break;
                default:
                    body = err.message || name;
                    break;
            }
        }
        else if (err.message) {
            body = err.message;
        }
        else {
            body = err;
        }
        var msg = prefix + (body ? (prefix ? ': ' : '') + body : '');
        return msg;
    }
    cb(err, prefix) {
        return new Promise(resolve => {
            resolve(this.msg(err, prefix));
        });
    }
};
BwcErrorProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], BwcErrorProvider);

//# sourceMappingURL=bwc-error.js.map

/***/ }),

/***/ 47:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TxFormatProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__filter_filter__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__rate_rate__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







let TxFormatProvider = class TxFormatProvider {
    constructor(bwcProvider, rate, configProvider, filter, logger) {
        this.bwcProvider = bwcProvider;
        this.rate = rate;
        this.configProvider = configProvider;
        this.filter = filter;
        this.logger = logger;
        this.logger.info('TxFormatProvider initialized.');
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
    }
    toCashAddress(address, withPrefix) {
        let cashAddr = this.bitcoreCash.Address(address).toCashAddress();
        if (withPrefix) {
            return cashAddr;
        }
        return cashAddr.split(':')[1]; // rm prefix
    }
    toLegacyAddress(address) {
        let legacyAddr = this.bitcoreCash.Address(address);
        return legacyAddr;
    }
    formatAmount(satoshis, fullPrecision) {
        let settings = this.configProvider.get().wallet.settings;
        if (settings.unitCode == 'sat')
            return satoshis;
        // TODO : now only works for english, specify opts to change thousand separator and decimal separator
        var opts = {
            fullPrecision: !!fullPrecision
        };
        return this.bwcProvider
            .getUtils()
            .formatAmount(satoshis, settings.unitCode, opts);
    }
    formatAmountStr(coin, satoshis) {
        if (isNaN(satoshis))
            return undefined;
        return this.formatAmount(satoshis) + ' ' + coin.toUpperCase();
    }
    toFiat(coin, satoshis, code) {
        // TODO not a promise
        return new Promise(resolve => {
            if (isNaN(satoshis))
                return resolve();
            var v1;
            v1 = this.rate.toFiat(satoshis, code, coin);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatToUSD(coin, satoshis) {
        // TODO not a promise
        return new Promise(resolve => {
            let v1;
            if (isNaN(satoshis))
                return resolve();
            v1 = this.rate.toFiat(satoshis, 'USD', coin);
            if (!v1)
                return resolve(null);
            return resolve(v1.toFixed(2));
        });
    }
    formatAlternativeStr(coin, satoshis) {
        if (isNaN(satoshis))
            return undefined;
        let settings = this.configProvider.get().wallet.settings;
        let val = (() => {
            var v1 = parseFloat(this.rate.toFiat(satoshis, settings.alternativeIsoCode, coin).toFixed(2));
            v1 = this.filter.formatFiatAmount(v1);
            if (!v1)
                return null;
            return v1 + ' ' + settings.alternativeIsoCode;
        }).bind(this);
        if ((!this.rate.isBtcAvailable() && coin == 'btc') ||
            (!this.rate.isBchAvailable() && coin == 'bch'))
            return null;
        return val();
    }
    processTx(coin, tx, useLegacyAddress) {
        if (!tx || tx.action == 'invalid')
            return tx;
        // New transaction output format
        if (tx.outputs && tx.outputs.length) {
            var outputsNr = tx.outputs.length;
            if (tx.action != 'received') {
                if (outputsNr > 1) {
                    tx.recipientCount = outputsNr;
                    tx.hasMultiplesOutputs = true;
                }
                tx.amount = __WEBPACK_IMPORTED_MODULE_6_lodash__["reduce"](tx.outputs, (total, o) => {
                    o.amountStr = this.formatAmountStr(coin, o.amount);
                    o.alternativeAmountStr = this.formatAlternativeStr(coin, o.amount);
                    return total + o.amount;
                }, 0);
            }
            tx.toAddress = tx.outputs[0].toAddress;
            // toDo: translate all tx.outputs[x].toAddress ?
            if (tx.toAddress && coin == 'bch') {
                tx.toAddress = useLegacyAddress
                    ? this.toLegacyAddress(tx.toAddress)
                    : this.toCashAddress(tx.toAddress);
            }
        }
        tx.amountStr = this.formatAmountStr(coin, tx.amount);
        tx.alternativeAmountStr = this.formatAlternativeStr(coin, tx.amount);
        tx.feeStr = this.formatAmountStr(coin, tx.fee || tx.fees);
        if (tx.amountStr) {
            tx.amountValueStr = tx.amountStr.split(' ')[0];
            tx.amountUnitStr = tx.amountStr.split(' ')[1];
        }
        if (tx.addressTo && coin == 'bch') {
            tx.addressTo = useLegacyAddress
                ? this.toLegacyAddress(tx.addressTo)
                : this.toCashAddress(tx.addressTo);
        }
        return tx;
    }
    formatPendingTxps(txps) {
        this.pendingTxProposalsCountForUs = 0;
        var now = Math.floor(Date.now() / 1000);
        /* To test multiple outputs...
        var txp = {
          message: 'test multi-output',
          fee: 1000,
          createdOn: new Date() / 1000,
          outputs: []
        };
        function addOutput(n) {
          txp.outputs.push({
            amount: 600,
            toAddress: '2N8bhEwbKtMvR2jqMRcTCQqzHP6zXGToXcK',
            message: 'output #' + (Number(n) + 1)
          });
        };
        lodash.times(150, addOutput);
        txps.push(txp);
        */
        __WEBPACK_IMPORTED_MODULE_6_lodash__["each"](txps, function (tx) {
            // no future transactions...
            if (tx.createdOn > now)
                tx.createdOn = now;
            // TODO: implement profileService.getWallet(tx.walletId)
            // TODO tx.wallet = profileService.getWallet(tx.walletId);
            tx.wallet = {
                coin: 'btc',
                copayerId: 'asdasdasdasd'
            };
            // hardcoded tx.wallet ^
            if (!tx.wallet) {
                this.logger.debug('no wallet at txp?');
                return;
            }
            tx = this.processTx(tx.wallet.coin, tx);
            var action = __WEBPACK_IMPORTED_MODULE_6_lodash__["find"](tx.actions, {
                copayerId: tx.wallet.copayerId
            });
            if (!action && tx.status == 'pending') {
                tx.pendingForUs = true;
            }
            if (action && action.type == 'accept') {
                tx.statusForUs = 'accepted';
            }
            else if (action && action.type == 'reject') {
                tx.statusForUs = 'rejected';
            }
            else {
                tx.statusForUs = 'pending';
            }
            if (!tx.deleteLockTime)
                tx.canBeRemoved = true;
        });
        return txps;
    }
    parseAmount(coin, amount, currency) {
        let settings = this.configProvider.get().wallet.settings;
        var satToBtc = 1 / 100000000;
        var unitToSatoshi = settings.unitToSatoshi;
        var amountUnitStr;
        var amountSat;
        var alternativeIsoCode = settings.alternativeIsoCode;
        // If fiat currency
        if (currency != 'BCH' && currency != 'BTJ' && currency != 'sat') {
            amountUnitStr = this.filter.formatFiatAmount(amount) + ' ' + currency;
            amountSat = Number(this.rate.fromFiat(amount, currency, coin).toFixed(0));
        }
        else if (currency == 'sat') {
            amountSat = Number(amount);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert sat to BTJ or BCH
            amount = (amountSat * satToBtc).toFixed(8);
            currency = coin.toUpperCase();
        }
        else {
            amountSat = parseInt((amount * unitToSatoshi).toFixed(0), 10);
            amountUnitStr = this.formatAmountStr(coin, amountSat);
            // convert unit to BTJ or BCH
            amount = (amountSat * satToBtc).toFixed(8);
            currency = coin.toUpperCase();
        }
        return {
            amount,
            currency,
            alternativeIsoCode,
            amountSat,
            amountUnitStr
        };
    }
    satToUnit(amount) {
        let settings = this.configProvider.get().wallet.settings;
        var unitToSatoshi = settings.unitToSatoshi;
        var satToUnit = 1 / unitToSatoshi;
        var unitDecimals = settings.unitDecimals;
        return parseFloat((amount * satToUnit).toFixed(unitDecimals));
    }
};
TxFormatProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_5__rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_3__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */]])
], TxFormatProvider);

//# sourceMappingURL=tx-format.js.map

/***/ }),

/***/ 5:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Logger; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
/* tslint:disable:no-console */


let Logger = class Logger {
    constructor() {
        this.logs = [];
        this.levels = [
            { level: 'error', weight: 1, label: 'Error', def: false },
            { level: 'warn', weight: 2, label: 'Warning', def: false },
            { level: 'info', weight: 3, label: 'Info', def: true },
            { level: 'debug', weight: 4, label: 'Debug', def: false }
        ];
        // Create an array of level weights for performant filtering.
        this.weight = {};
        for (let i = 0; i < this.levels.length; i++) {
            this.weight[this.levels[i].level] = this.levels[i].weight;
        }
    }
    error(message, ...optionalParams) {
        let msg = '[error] ' + (__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](message) ? message : JSON.stringify(message));
        console.log(msg, ...optionalParams);
        let args = this.processingArgs(arguments);
        this.add('error', args);
    }
    debug(message, ...optionalParams) {
        let msg = '[debug] ' + (__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](message) ? message : JSON.stringify(message));
        if (Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["isDevMode"])())
            console.log(msg, ...optionalParams);
        let args = this.processingArgs(arguments);
        this.add('debug', args);
    }
    info(message, ...optionalParams) {
        let msg = '[info] ' + (__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](message) ? message : JSON.stringify(message));
        if (Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["isDevMode"])())
            console.log(msg, ...optionalParams);
        let args = this.processingArgs(arguments);
        this.add('info', args);
    }
    warn(message, ...optionalParams) {
        let msg = '[warn] ' + (__WEBPACK_IMPORTED_MODULE_1_lodash__["isString"](message) ? message : JSON.stringify(message));
        if (Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["isDevMode"])())
            console.log(msg, ...optionalParams);
        let args = this.processingArgs(arguments);
        this.add('warn', args);
    }
    getLevels() {
        return this.levels;
    }
    getWeight(weight) {
        return __WEBPACK_IMPORTED_MODULE_1_lodash__["find"](this.levels, l => {
            return l.weight == weight;
        });
    }
    getDefaultWeight() {
        return __WEBPACK_IMPORTED_MODULE_1_lodash__["find"](this.levels, l => {
            return l.def;
        });
    }
    add(level, msg) {
        msg = msg.replace('/xpriv.*/', '[...]');
        msg = msg.replace('/walletPrivKey.*/', 'walletPrivKey:[...]');
        this.logs.push({
            timestamp: new Date().toISOString(),
            level,
            msg
        });
    }
    /**
     * Returns logs of <= to filteredWeight
     * @param {number} filteredWeight Weight (1-4) to use when filtering logs. optional
     */
    get(filterWeight) {
        let filteredLogs = this.logs;
        if (filterWeight != undefined) {
            filteredLogs = __WEBPACK_IMPORTED_MODULE_1_lodash__["filter"](this.logs, l => {
                return this.weight[l.level] <= filterWeight;
            });
        }
        return filteredLogs;
    }
    processingArgs(argsValues) {
        var args = Array.prototype.slice.call(argsValues);
        args = args.map(v => {
            try {
                if (typeof v == 'undefined')
                    v = 'undefined';
                if (!v)
                    v = 'null';
                if (typeof v == 'object') {
                    v = v.message ? v.message : JSON.stringify(v);
                }
            }
            catch (e) {
                console.log('Error at log decorator:', e);
                v = 'undefined';
            }
            return v;
        });
        return args.join(' ');
    }
};
Logger = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [])
], Logger);

//# sourceMappingURL=logger.js.map

/***/ }),

/***/ 54:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomeIntegrationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




const exchangeList = [{ name: 'coinbase' }, { name: 'glidera' }];
let HomeIntegrationsProvider = class HomeIntegrationsProvider {
    constructor(http, logger) {
        this.http = http;
        this.logger = logger;
        this.logger.info('HomeIntegrationsProviders initialized.');
        this.services = [];
    }
    register(serviceInfo) {
        // Check if already exists
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.services, { name: serviceInfo.name }))
            return;
        this.logger.info('Adding home Integrations entry:' + serviceInfo.name);
        this.services.push(serviceInfo);
    }
    unregister(serviceName) {
        this.services = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.services, x => {
            return x.name != serviceName;
        });
    }
    updateLink(serviceName, token) {
        this.services = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.linked = !!token;
            return x;
        });
    }
    updateConfig(serviceName, show) {
        this.services = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.services, x => {
            if (x.name == serviceName)
                x.show = !!show;
            return x;
        });
    }
    get() {
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["orderBy"](this.services, ['name'], ['asc']);
    }
    getAvailableExchange() {
        let exchangeServices = __WEBPACK_IMPORTED_MODULE_3_lodash__["intersectionBy"](this.services, exchangeList, 'name');
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](exchangeServices, { linked: true, show: true });
    }
};
HomeIntegrationsProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], HomeIntegrationsProvider);

//# sourceMappingURL=home-integrations.js.map

/***/ }),

/***/ 57:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReplaceParametersProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/*
* Example of use:
* let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{amountBelowFeeStr}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { amountBelowFeeStr: amountBelowFeeStr, coin: this.tx.coin.toUpperCase() });
*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let ReplaceParametersProvider = class ReplaceParametersProvider {
    constructor() { }
    replace(stringToReplace, params) {
        let processedParams = [];
        for (let key in params) {
            processedParams.push({ key, value: params[key] });
        }
        processedParams.forEach(param => {
            stringToReplace = __WEBPACK_IMPORTED_MODULE_1_lodash__["replace"](stringToReplace, new RegExp('{{' + param.key + '}}', 'g'), param.value);
            stringToReplace = __WEBPACK_IMPORTED_MODULE_1_lodash__["replace"](stringToReplace, new RegExp('{{ ' + param.key + ' }}', 'g'), param.value);
        });
        return stringToReplace;
    }
};
ReplaceParametersProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [])
], ReplaceParametersProvider);

//# sourceMappingURL=replace-parameters.js.map

/***/ }),

/***/ 642:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ISTORAGE */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);

class KeyAlreadyExistsError extends Error {
    constructor() {
        super('Key already exists');
    }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = KeyAlreadyExistsError;

let ISTORAGE = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["InjectionToken"]('storage');
//# sourceMappingURL=istorage.js.map

/***/ }),

/***/ 67:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TabsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__home_home__ = __webpack_require__(718);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__receive_receive__ = __webpack_require__(819);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__scan_scan__ = __webpack_require__(367);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__send_send__ = __webpack_require__(822);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__settings_settings__ = __webpack_require__(823);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






let TabsPage = class TabsPage {
    constructor() {
        this.homeRoot = __WEBPACK_IMPORTED_MODULE_1__home_home__["a" /* HomePage */];
        this.receiveRoot = __WEBPACK_IMPORTED_MODULE_2__receive_receive__["a" /* ReceivePage */];
        this.scanRoot = __WEBPACK_IMPORTED_MODULE_3__scan_scan__["a" /* ScanPage */];
        this.sendRoot = __WEBPACK_IMPORTED_MODULE_4__send_send__["a" /* SendPage */];
        this.settingsRoot = __WEBPACK_IMPORTED_MODULE_5__settings_settings__["a" /* SettingsPage */];
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('tabs'),
    __metadata("design:type", Object)
], TabsPage.prototype, "tabs", void 0);
TabsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/tabs/tabs.html"*/'<ion-tabs #tabs>\n  <ion-tab [root]="homeRoot" tabTitle="{{\'Home\'|translate}}" tabIcon="tab-home"></ion-tab>\n  <ion-tab [root]="receiveRoot" tabTitle="{{\'Receive\'|translate}}" tabIcon="tab-receive"></ion-tab>\n  <ion-tab [root]="scanRoot" tabTitle="{{\'Scan\'|translate}}" tabIcon="tab-scan"></ion-tab>\n  <ion-tab [root]="sendRoot" tabTitle="{{\'Send\'|translate}}" tabIcon="tab-send"></ion-tab>\n  <ion-tab [root]="settingsRoot" tabTitle="{{\'Settings\'|translate}}" tabIcon="tab-settings"></ion-tab>\n</ion-tabs>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/tabs/tabs.html"*/
    }),
    __metadata("design:paramtypes", [])
], TabsPage);

//# sourceMappingURL=tabs.js.map

/***/ }),

/***/ 675:
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 675;

/***/ }),

/***/ 68:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_filter_filter__ = __webpack_require__(237);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_node_webkit_node_webkit__ = __webpack_require__(239);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__integrations_amazon_buy_amazon_buy_amazon__ = __webpack_require__(721);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__ = __webpack_require__(722);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__integrations_coinbase_buy_coinbase_buy_coinbase__ = __webpack_require__(723);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__integrations_coinbase_sell_coinbase_sell_coinbase__ = __webpack_require__(725);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__integrations_glidera_buy_glidera_buy_glidera__ = __webpack_require__(726);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__integrations_glidera_sell_glidera_sell_glidera__ = __webpack_require__(729);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__integrations_mercado_libre_buy_mercado_libre_buy_mercado_libre__ = __webpack_require__(730);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__ = __webpack_require__(731);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__receive_custom_amount_custom_amount__ = __webpack_require__(734);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__confirm_confirm__ = __webpack_require__(355);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Providers







// Pages










let AmountPage = class AmountPage {
    constructor(actionSheetCtrl, configProvider, filterProvider, logger, navCtrl, navParams, nodeWebkitProvider, platformProvider, rateProvider, txFormatProvider, translate, changeDetectorRef) {
        this.actionSheetCtrl = actionSheetCtrl;
        this.configProvider = configProvider;
        this.filterProvider = filterProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.nodeWebkitProvider = nodeWebkitProvider;
        this.platformProvider = platformProvider;
        this.rateProvider = rateProvider;
        this.txFormatProvider = txFormatProvider;
        this.translate = translate;
        this.changeDetectorRef = changeDetectorRef;
        this.zone = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["NgZone"]({ enableLongStackTrace: false });
        this.config = this.configProvider.get();
        this.recipientType = this.navParams.data.recipientType;
        this.toAddress = this.navParams.data.toAddress;
        this.network = this.navParams.data.network;
        this.name = this.navParams.data.name;
        this.email = this.navParams.data.email;
        this.color = this.navParams.data.color;
        this.fixedUnit = this.navParams.data.fixedUnit;
        this.description = this.navParams.data.description;
        this.onlyIntegers = this.navParams.data.onlyIntegers
            ? this.navParams.data.onlyIntegers
            : false;
        this.showRecipient = true;
        this.showSendMax = false;
        this.useSendMax = false;
        this.allowSend = false;
        this.availableUnits = [];
        this.expression = '';
        this.LENGTH_EXPRESSION_LIMIT = 19;
        this.amount = 0;
        this.altUnitIndex = 0;
        this.unitIndex = 0;
        this.reNr = /^[1234567890\.]$/;
        this.reOp = /^[\*\+\-\/]$/;
        this.nextView = this.getNextView();
        this.itemSelectorLabel = this.translate.instant('Send Max amount');
        this.unitToSatoshi = this.config.wallet.settings.unitToSatoshi;
        this.satToUnit = 1 / this.unitToSatoshi;
        this.unitDecimals = this.config.wallet.settings.unitDecimals;
        // BitPay Card ID or Wallet ID
        this._id = this.navParams.data.id;
        // Use only with ShapeShift
        this.toWalletId = this.navParams.data.toWalletId;
        this.shiftMax = this.navParams.data.shiftMax;
        this.shiftMin = this.navParams.data.shiftMin;
        this.setAvailableUnits();
        this.updateUnitUI();
    }
    ionViewWillEnter() {
        this.expression = '';
        this.useSendMax = false;
        this.processAmount();
    }
    handleKeyboardEvent(event) {
        if (this.navCtrl.getActive().name != 'AmountPage')
            return;
        if (!event.key)
            return;
        if (event.which === 8) {
            event.preventDefault();
            this.removeDigit();
        }
        if (event.key.match(this.reNr)) {
            this.pushDigit(event.key);
        }
        else if (event.key.match(this.reOp)) {
            this.pushOperator(event.key);
        }
        else if (event.keyCode === 86) {
            if (event.ctrlKey || event.metaKey)
                this.processClipboard();
        }
        else if (event.keyCode === 13)
            this.finish();
    }
    setAvailableUnits() {
        this.availableUnits = [];
        this.availableUnits.push({
            name: 'Bastoji',
            id: 'btc',
            shortName: 'BTJ'
        });
        this.availableUnits.push({
            name: 'Bastoji Cash',
            id: 'bch',
            shortName: 'BCH'
        });
        this.unitIndex = 0;
        if (this.navParams.data.coin) {
            let coins = this.navParams.data.coin.split(',');
            let newAvailableUnits = [];
            __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](coins, (c) => {
                let coin = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.availableUnits, {
                    id: c
                });
                if (!coin) {
                    this.logger.warn('Could not find desired coin:' + this.navParams.data.coin);
                }
                else {
                    newAvailableUnits.push(coin);
                }
            });
            if (newAvailableUnits.length > 0) {
                this.availableUnits = newAvailableUnits;
            }
        }
        //  currency have preference
        let fiatName;
        if (this.navParams.data.currency) {
            this.fiatCode = this.navParams.data.currency;
            this.altUnitIndex = this.unitIndex;
            this.unitIndex = this.availableUnits.length;
        }
        else {
            this.fiatCode = this.config.wallet.settings.alternativeIsoCode || 'USD';
            fiatName = this.config.wallet.settings.alternativeName || this.fiatCode;
            this.altUnitIndex = this.availableUnits.length;
        }
        this.availableUnits.push({
            name: fiatName || this.fiatCode,
            // TODO
            id: this.fiatCode,
            shortName: this.fiatCode,
            isFiat: true
        });
        if (this.navParams.data.fixedUnit) {
            this.fixedUnit = true;
        }
    }
    paste(value) {
        this.zone.run(() => {
            this.expression = value;
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    getNextView() {
        let nextPage;
        switch (this.navParams.data.nextPage) {
            case 'BitPayCardTopUpPage':
                this.showRecipient = false;
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_12__integrations_bitpay_card_bitpay_card_topup_bitpay_card_topup__["a" /* BitPayCardTopUpPage */];
                break;
            case 'BuyAmazonPage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_11__integrations_amazon_buy_amazon_buy_amazon__["a" /* BuyAmazonPage */];
                break;
            case 'BuyGlideraPage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_15__integrations_glidera_buy_glidera_buy_glidera__["a" /* BuyGlideraPage */];
                break;
            case 'SellGlideraPage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_16__integrations_glidera_sell_glidera_sell_glidera__["a" /* SellGlideraPage */];
                break;
            case 'BuyCoinbasePage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_13__integrations_coinbase_buy_coinbase_buy_coinbase__["a" /* BuyCoinbasePage */];
                break;
            case 'SellCoinbasePage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_14__integrations_coinbase_sell_coinbase_sell_coinbase__["a" /* SellCoinbasePage */];
                break;
            case 'CustomAmountPage':
                nextPage = __WEBPACK_IMPORTED_MODULE_19__receive_custom_amount_custom_amount__["a" /* CustomAmountPage */];
                break;
            case 'BuyMercadoLibrePage':
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_17__integrations_mercado_libre_buy_mercado_libre_buy_mercado_libre__["a" /* BuyMercadoLibrePage */];
                break;
            case 'ShapeshiftConfirmPage':
                this.showSendMax = true;
                this.showRecipient = false;
                nextPage = __WEBPACK_IMPORTED_MODULE_18__integrations_shapeshift_shapeshift_confirm_shapeshift_confirm__["a" /* ShapeshiftConfirmPage */];
                break;
            default:
                this.showSendMax = true;
                nextPage = __WEBPACK_IMPORTED_MODULE_20__confirm_confirm__["a" /* ConfirmPage */];
        }
        return nextPage;
    }
    processClipboard() {
        if (!this.platformProvider.isNW)
            return;
        let value = this.nodeWebkitProvider.readFromClipboard();
        if (value && this.evaluate(value) > 0)
            this.paste(this.evaluate(value));
    }
    showSendMaxMenu() {
        let buttons = [];
        let sendMaxButton = {
            text: this.itemSelectorLabel,
            icon: 'speedometer',
            handler: () => {
                this.sendMax();
            }
        };
        buttons.push(sendMaxButton);
        const actionSheet = this.actionSheetCtrl.create({
            buttons
        });
        actionSheet.present();
    }
    sendMax() {
        this.useSendMax = true;
        this.finish();
    }
    pushDigit(digit) {
        if (this.expression &&
            this.expression.length >= this.LENGTH_EXPRESSION_LIMIT)
            return;
        this.zone.run(() => {
            this.expression = (this.expression + digit).replace('..', '.');
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    removeDigit() {
        this.zone.run(() => {
            this.expression = this.expression.slice(0, -1);
            this.processAmount();
            this.changeDetectorRef.detectChanges();
        });
    }
    pushOperator(operator) {
        if (!this.expression || this.expression.length == 0)
            return;
        this.zone.run(() => {
            this.expression = this._pushOperator(this.expression, operator);
            this.changeDetectorRef.detectChanges();
        });
    }
    _pushOperator(val, operator) {
        if (!this.isOperator(__WEBPACK_IMPORTED_MODULE_3_lodash__["last"](val))) {
            return val + operator;
        }
        else {
            return val.slice(0, -1) + operator;
        }
    }
    isOperator(val) {
        const regex = /[\/\-\+\x\*]/;
        return regex.test(val);
    }
    isExpression(val) {
        const regex = /^\.?\d+(\.?\d+)?([\/\-\+\*x]\d?\.?\d+)+$/;
        return regex.test(val);
    }
    processAmount() {
        let formatedValue = this.format(this.expression);
        let result = this.evaluate(formatedValue);
        this.allowSend = this.onlyIntegers
            ? __WEBPACK_IMPORTED_MODULE_3_lodash__["isNumber"](result) && +result > 0 && Number.isInteger(+result)
            : __WEBPACK_IMPORTED_MODULE_3_lodash__["isNumber"](result) && +result > 0;
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isNumber"](result)) {
            this.globalResult = this.isExpression(this.expression)
                ? '= ' + this.processResult(result)
                : '';
            if (this.availableUnits[this.unitIndex].isFiat) {
                let a = this.fromFiat(result);
                if (a) {
                    this.alternativeAmount = this.txFormatProvider.formatAmount(a * this.unitToSatoshi, true);
                }
                else {
                    this.alternativeAmount = result ? 'N/A' : null;
                    this.allowSend = false;
                }
            }
            else {
                this.alternativeAmount = this.filterProvider.formatFiatAmount(this.toFiat(result));
            }
        }
    }
    processResult(val) {
        if (this.availableUnits[this.unitIndex].isFiat)
            return this.filterProvider.formatFiatAmount(val);
        else
            return this.txFormatProvider.formatAmount(val.toFixed(this.unitDecimals) * this.unitToSatoshi, true);
    }
    fromFiat(val, coin) {
        coin = coin || this.availableUnits[this.altUnitIndex].id;
        return parseFloat((this.rateProvider.fromFiat(val, this.fiatCode, coin) * this.satToUnit).toFixed(this.unitDecimals));
    }
    toFiat(val) {
        if (!this.rateProvider.getRate(this.fiatCode))
            return undefined;
        return parseFloat(this.rateProvider
            .toFiat(val * this.unitToSatoshi, this.fiatCode, this.availableUnits[this.unitIndex].id)
            .toFixed(2));
    }
    format(val) {
        if (!val)
            return undefined;
        let result = val.toString();
        if (this.isOperator(__WEBPACK_IMPORTED_MODULE_3_lodash__["last"](val)))
            result = result.slice(0, -1);
        return result.replace('x', '*');
    }
    evaluate(val) {
        let result;
        try {
            result = eval(val);
        }
        catch (e) {
            return 0;
        }
        if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isFinite"](result))
            return 0;
        return result;
    }
    finish() {
        let unit = this.availableUnits[this.unitIndex];
        let _amount = this.evaluate(this.format(this.expression));
        let coin = unit.id;
        let data;
        if (unit.isFiat) {
            coin = this.availableUnits[this.altUnitIndex].id;
        }
        if (this.navParams.data.nextPage) {
            data = {
                id: this._id,
                amount: this.useSendMax ? null : _amount,
                currency: unit.id.toUpperCase(),
                coin,
                useSendMax: this.useSendMax,
                toWalletId: this.toWalletId
            };
        }
        else {
            let amount = _amount;
            amount = unit.isFiat
                ? (this.fromFiat(amount) * this.unitToSatoshi).toFixed(0)
                : (amount * this.unitToSatoshi).toFixed(0);
            data = {
                recipientType: this.recipientType,
                amount,
                toAddress: this.toAddress,
                name: this.name,
                email: this.email,
                color: this.color,
                coin,
                useSendMax: this.useSendMax,
                description: this.description
            };
        }
        this.useSendMax = null;
        this.navCtrl.push(this.nextView, data);
    }
    updateUnitUI() {
        this.unit = this.availableUnits[this.unitIndex].shortName;
        this.alternativeUnit = this.availableUnits[this.altUnitIndex].shortName;
        this.processAmount();
        this.logger.debug('Update unit coin @amount unit:' +
            this.unit +
            ' alternativeUnit:' +
            this.alternativeUnit);
    }
    changeUnit() {
        if (this.fixedUnit)
            return;
        this.unitIndex++;
        if (this.unitIndex >= this.availableUnits.length)
            this.unitIndex = 0;
        if (this.availableUnits[this.unitIndex].isFiat) {
            // Always return to BTJ... TODO?
            this.altUnitIndex = 0;
        }
        else {
            this.altUnitIndex = __WEBPACK_IMPORTED_MODULE_3_lodash__["findIndex"](this.availableUnits, {
                isFiat: true
            });
        }
        this.zone.run(() => {
            this.updateUnitUI();
            this.changeDetectorRef.detectChanges();
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["HostListener"])('document:keydown', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], AmountPage.prototype, "handleKeyboardEvent", null);
AmountPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-amount',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/send/amount/amount.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Amount\' | translate}}</ion-title>\n    <ion-buttons end *ngIf="showSendMax">\n      <button (click)="showSendMaxMenu()" ion-button icon-only>\n        <ion-icon name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list *ngIf="showRecipient">\n    <ion-item-divider>\n      <span translate>Recipient</span>\n    </ion-item-divider>\n    <ion-item>\n      <ion-icon *ngIf="recipientType == \'wallet\'" item-start>\n        <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n        <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n      </ion-icon>\n      <ion-icon *ngIf="recipientType == \'contact\'" item-start>\n        <gravatar [name]="name" [height]="30" [width]="30" [email]="email"></gravatar>\n      </ion-icon>\n      <ion-icon *ngIf="!recipientType" item-start>\n        <img src="assets/img/contact-placeholder.svg" class="icon-contact">\n      </ion-icon>\n      <span>{{name || toAddress}}</span>\n    </ion-item>\n  </ion-list>\n  <div>\n    <div class="amount-pane">\n\n      <div *ngIf="shiftMin && shiftMax" class="shapeshift-values">\n        <div>Min: {{shiftMin}}</div>\n        <div>Max: {{shiftMax}}</div>\n      </div>\n\n      <div class="amount-content">\n        <div class="expression-container">\n          <span class="expression">{{expression || (onlyIntegers ? \'0\' : \'0.00\')}}</span>\n          <span class="unit-button" (click)="changeUnit()">{{unit}}</span>\n        </div>\n        <div class="amount" [hidden]="!globalResult">{{globalResult}} {{unit}}</div>\n        <div class="result" *ngIf="alternativeAmount">&asymp; {{alternativeAmount || (onlyIntegers ? \'0\' : \'0.00\')}} {{alternativeUnit}}</div>\n        <div class="result" *ngIf="!alternativeAmount">&nbsp;</div>\n        <div *ngIf="onlyIntegers && !allowSend && alternativeAmount" translate>This service only accepts integers amounts</div>\n      </div>\n    </div>\n  </div>\n</ion-content>\n<ion-footer>\n  <ion-toolbar>\n    <div class="keypad">\n      <div class="operator-row">\n        <div class="col operator-send" [hidden]="!allowSend" (click)="finish()">\n          <ion-icon name="arrow-round-forward"></ion-icon>\n        </div>\n      </div>\n      <div class="row">\n        <div class="col digit" (click)="pushDigit(\'7\')">7</div>\n        <div class="col digit" (click)="pushDigit(\'8\')">8</div>\n        <div class="col digit" (click)="pushDigit(\'9\')">9</div>\n        <div class="col operator" (click)="pushOperator(\'/\')">&#247;</div>\n      </div>\n\n      <div class="row">\n        <div class="col digit" (click)="pushDigit(\'4\')">4</div>\n        <div class="col digit" (click)="pushDigit(\'5\')">5</div>\n        <div class="col digit" (click)="pushDigit(\'6\')">6</div>\n        <div class="col operator" (click)="pushOperator(\'x\')">&#215;</div>\n      </div>\n\n      <div class="row">\n        <div class="col digit" (click)="pushDigit(\'1\')">1</div>\n        <div class="col digit" (click)="pushDigit(\'2\')">2</div>\n        <div class="col digit" (click)="pushDigit(\'3\')">3</div>\n        <div class="col operator" (click)="pushOperator(\'+\')">&#43;</div>\n      </div>\n\n      <div class="row">\n        <div class="col digit" (click)="pushDigit(\'.\')"><span *ngIf="!onlyIntegers">.</span></div>\n        <div class="col digit" (click)="pushDigit(\'0\')">0</div>\n        <div class="col digit" (click)="removeDigit()">\n          <ion-icon name="backspace"></ion-icon>\n        </div>\n        <div class="col operator" (click)="pushOperator(\'-\')">&#45;</div>\n      </div>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/send/amount/amount.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_filter_filter__["a" /* FilterProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_node_webkit_node_webkit__["a" /* NodeWebkitProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_0__angular_core__["ChangeDetectorRef"]])
], AmountPage);

//# sourceMappingURL=amount.js.map

/***/ }),

/***/ 69:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FinishModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let FinishModalPage = class FinishModalPage {
    constructor(viewCtrl, navParams, translate) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.translate = translate;
        this.finishText =
            this.navParams.data.finishText || this.navParams.data.finishText == ''
                ? this.navParams.data.finishText
                : this.translate.instant('Payment Sent');
        this.finishComment = this.navParams.data.finishComment
            ? this.navParams.data.finishComment
            : '';
        this.cssClass = this.navParams.data.cssClass
            ? this.navParams.data.cssClass
            : 'success';
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
FinishModalPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-finish',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/finish/finish.html"*/'<div class="container">\n  <div class="content" [ngClass]="{\'success\': cssClass == \'success\', \'warning\': cssClass == \'warning\', \'danger\': cssClass == \'danger\'}">\n    <div class="body">\n      <img class="body-img" *ngIf="cssClass == \'success\'" src="assets/img/onboarding-success.svg">\n      <img class="body-img" *ngIf="cssClass != \'success\'" src="assets/img/warning.svg">\n      <div class="body-text">\n        {{finishText}}\n      </div>\n      <div class="body-comment">\n        {{finishComment}}\n      </div>\n    </div>\n  </div>\n  <div class="footer" (click)="close()">\n    OK\n  </div>\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/finish/finish.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], FinishModalPage);

//# sourceMappingURL=finish.js.map

/***/ }),

/***/ 701:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 713:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return MiniModalComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mini_modal_content__ = __webpack_require__(1173);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let MiniModalComponent = class MiniModalComponent {
    constructor(viewCtrl, navParams) {
        this.viewCtrl = viewCtrl;
        this.navParams = navParams;
        this.modalTitle = this.navParams.get('modalTitle');
    }
    ngAfterViewInit() {
        this.modalContent.action.subscribe(confirm => {
            this.close(confirm);
        });
    }
    close(confirm) {
        this.viewCtrl.dismiss(confirm, null, { animate: false });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2__mini_modal_content__["a" /* MiniModalContent */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2__mini_modal_content__["a" /* MiniModalContent */])
], MiniModalComponent.prototype, "modalContent", void 0);
MiniModalComponent = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'mini-modal',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/components/mini-modal/mini-modal.html"*/'<div class="mini-modal" [ngSwitch]="modalTitle">\n\n  <mini-modal-content *ngSwitchCase="\'backup-needed\'">\n    <img modal-icon src="assets/img/icon-warning.svg">\n    <div class="modal-heading" translate>Backup Needed</div>\n    <div class="modal-message" translate>\n      Now is a good time to backup your wallet. If this device is lost, it is impossible to access your funds without a backup.\n    </div>\n    <modal-cancel-text translate>Do it later</modal-cancel-text>\n    <div modal-confirm-text translate>I understand</div>\n  </mini-modal-content>\n\n  <mini-modal-content *ngSwitchCase="\'backup-ready\'" type="success">\n    <img modal-icon src="assets/img/onboarding-success.svg">\n    <div class="modal-heading" translate>Your bastoji wallet is backed up!</div>\n    <div class="modal-message" translate>\n      Be sure to store your recovery phrase in a secure place. If this app is deleted, your money cannot be recovered without it.\n    </div>\n    <div modal-confirm-text translate>Got it</div>\n  </mini-modal-content>\n\n  <mini-modal-content *ngSwitchCase="\'backup-warning\'">\n    <img modal-icon src="assets/img/no-screenshot.svg">\n    <div class="modal-heading" translate>Screenshots are not secure</div>\n    <div class="modal-message" translate>\n      If you take a screenshot, your backup may be viewed by other apps. You can make a safe backup with physical paper and a pen.\n    </div>\n    <modal-cancel-text translate>Go Back</modal-cancel-text>\n    <div modal-confirm-text translate>I understand</div>\n  </mini-modal-content>\n\n  <mini-modal-content *ngSwitchCase="\'fee-warning\'" type="danger">\n    <img modal-icon src="assets/img/icon-warning.svg">\n    <div class="modal-heading" translate>Bastoji miner fees unusually high</div>\n    <div class="modal-message" translate>Miner fees are high due to record demand for limited space on the network. BitPay does not receive and does not control miner fees.</div>\n    <div modal-confirm-text translate>I understand</div>\n  </mini-modal-content>\n\n  <mini-modal-content *ngSwitchCase="\'sensitive-info\'">\n    <img modal-icon src="assets/img/icon-warning.svg">\n    <div class="modal-heading" translate>Sensitive Data</div>\n    <div class="modal-message" translate>\n      The information you are about to share/export may contain sensitive data such us wallet IDs, addresses, balances, etc. Please be sure you trust the person or entity with whom you are sharing this information.\n    </div>\n    <modal-cancel-text translate>Go Back</modal-cancel-text>\n    <div modal-confirm-text translate>I understand</div>\n  </mini-modal-content>\n\n</div>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/components/mini-modal/mini-modal.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */]])
], MiniModalComponent);

const MINI_MODAL_COMPONENTS = [
    MiniModalComponent,
    __WEBPACK_IMPORTED_MODULE_2__mini_modal_content__["a" /* MiniModalContent */],
    __WEBPACK_IMPORTED_MODULE_2__mini_modal_content__["b" /* ModalCancelText */]
];
/* harmony export (immutable) */ __webpack_exports__["a"] = MINI_MODAL_COMPONENTS;

//# sourceMappingURL=mini-modal.js.map

/***/ }),

/***/ 717:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupGamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__ = __webpack_require__(181);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// pages

// providers





let BackupGamePage = class BackupGamePage {
    constructor(navCtrl, navParams, logger, profileProvider, walletProvider, bwcProvider, onGoingProcessProvider, popupProvider, translate) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.bwcProvider = bwcProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.walletId = this.navParams.get('walletId');
        this.fromOnboarding = this.navParams.get('fromOnboarding');
        this.wallet = this.profileProvider.getWallet(this.walletId);
        this.credentialsEncrypted = this.wallet.isPrivKeyEncrypted();
    }
    ionViewDidEnter() {
        this.deleted = this.isDeletedSeed();
        if (this.deleted) {
            this.logger.debug('no mnemonics');
            return;
        }
        this.walletProvider
            .getKeys(this.wallet)
            .then(keys => {
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](keys)) {
                this.logger.error('Empty keys');
            }
            this.credentialsEncrypted = false;
            this.keys = keys;
            this.setFlow();
        })
            .catch(err => {
            this.logger.error('Could not get keys: ', err);
            this.navCtrl.pop();
        });
    }
    ngOnInit() {
        this.currentIndex = 0;
        this.navBar.backButtonClick = () => {
            if (this.slides)
                this.slidePrev();
            else
                this.navCtrl.pop();
        };
    }
    ionViewDidLoad() {
        if (this.slides)
            this.slides.lockSwipes(true);
    }
    shuffledWords(words) {
        var sort = __WEBPACK_IMPORTED_MODULE_3_lodash__["sortBy"](words);
        return __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](sort, w => {
            return {
                word: w,
                selected: false
            };
        });
    }
    addButton(index, item) {
        var newWord = {
            word: item.word,
            prevIndex: index
        };
        this.customWords.push(newWord);
        this.shuffledMnemonicWords[index].selected = true;
        this.shouldContinue();
    }
    removeButton(index, item) {
        // if ($scope.loading) return;
        this.customWords.splice(index, 1);
        this.shuffledMnemonicWords[item.prevIndex].selected = false;
        this.shouldContinue();
    }
    shouldContinue() {
        this.selectComplete =
            this.customWords.length === this.shuffledMnemonicWords.length
                ? true
                : false;
    }
    isDeletedSeed() {
        if (!this.wallet.credentials.mnemonic &&
            !this.wallet.credentials.mnemonicEncrypted)
            return true;
        return false;
    }
    slidePrev() {
        this.slides.lockSwipes(false);
        if (this.currentIndex == 0)
            this.navCtrl.pop();
        else {
            this.slides.slidePrev();
            this.currentIndex = this.slides.getActiveIndex();
        }
        this.slides.lockSwipes(true);
    }
    slideNext(reset) {
        if (reset) {
            this.resetGame();
        }
        if (this.currentIndex == 1 && !this.mnemonicHasPassphrase)
            this.finalStep();
        else {
            this.slides.lockSwipes(false);
            this.slides.slideNext();
        }
        this.currentIndex = this.slides.getActiveIndex();
        this.slides.lockSwipes(true);
    }
    resetGame() {
        this.customWords = [];
        this.shuffledMnemonicWords.forEach(word => {
            word.selected = false;
        });
        this.selectComplete = false;
    }
    setFlow() {
        if (!this.keys)
            return;
        let words = this.keys.mnemonic;
        this.mnemonicWords = words.split(/[\u3000\s]+/);
        this.shuffledMnemonicWords = this.shuffledWords(this.mnemonicWords);
        this.mnemonicHasPassphrase = this.wallet.mnemonicHasPassphrase();
        this.useIdeograms = words.indexOf('\u3000') >= 0;
        this.password = '';
        this.customWords = [];
        this.selectComplete = false;
        this.error = false;
        words = __WEBPACK_IMPORTED_MODULE_3_lodash__["repeat"]('x', 300);
        if (this.currentIndex == 2)
            this.slidePrev();
    }
    confirm() {
        return new Promise((resolve, reject) => {
            this.error = false;
            let customWordList = __WEBPACK_IMPORTED_MODULE_3_lodash__["map"](this.customWords, 'word');
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEqual"](this.mnemonicWords, customWordList)) {
                return reject('Mnemonic string mismatch');
            }
            if (this.mnemonicHasPassphrase) {
                let walletClient = this.bwcProvider.getClient();
                let separator = this.useIdeograms ? '\u3000' : ' ';
                let customSentence = customWordList.join(separator);
                let password = this.password || '';
                try {
                    walletClient.seedFromMnemonic(customSentence, {
                        network: this.wallet.credentials.network,
                        password,
                        account: this.wallet.credentials.account
                    });
                }
                catch (err) {
                    walletClient.credentials.xPrivKey = __WEBPACK_IMPORTED_MODULE_3_lodash__["repeat"]('x', 64);
                    return reject(err);
                }
                if (walletClient.credentials.xPrivKey.substr(walletClient.credentials.xPrivKey) != this.keys.xPrivKey) {
                    delete walletClient.credentials;
                    return reject('Private key mismatch');
                }
            }
            this.profileProvider.setBackupFlag(this.wallet.credentials.walletId);
            return resolve();
        });
    }
    finalStep() {
        this.onGoingProcessProvider.set('validatingWords');
        this.confirm()
            .then(() => {
            this.onGoingProcessProvider.clear();
            const modal = this.popupProvider.createMiniModal('backup-ready');
            modal.present({ animate: false });
            modal.onDidDismiss(() => {
                if (this.fromOnboarding) {
                    this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__onboarding_disclaimer_disclaimer__["a" /* DisclaimerPage */]);
                }
                else {
                    this.navCtrl.popToRoot({ animate: false });
                }
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.warn('Failed to verify backup: ', err);
            this.error = true;
            let title = this.translate.instant('Uh oh...');
            let message = this.translate.instant("It's important that you write your backup phrase down correctly. If something happens to your wallet, you'll need this backup to recover your money. Please review your backup and try again.");
            this.popupProvider.ionicAlert(title, message).then(() => {
                this.setFlow();
            });
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* Slides */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* Slides */])
], BackupGamePage.prototype, "slides", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* Navbar */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* Navbar */])
], BackupGamePage.prototype, "navBar", void 0);
BackupGamePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-backup-game',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/backup/backup-game/backup-game.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Backup\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content no-bounce>\n  <div *ngIf="deleted">\n    <h1 class="deleted-title" translate>Wallet recovery phrase not available</h1>\n    <ion-item-divider>\n      {{\'You can still export it from Advanced &gt; Export.\' |translate}}\n      <span *ngIf="wallet.coin == \'bch\'" translate>\n        Note: if this BCH wallet was duplicated from a BTJ wallet, they share the same recovery phrase.\n      </span>\n    </ion-item-divider>\n  </div>\n\n  <ion-slides pager="true" *ngIf="!deleted">\n    <ion-slide>\n      <div class="slide-container" *ngIf="mnemonicWords && mnemonicWords[0] || !credentialsEncrypted">\n        <div>\n          <div class="slide-title" translate>Please carefully write down this phrase.</div>\n          <div class="phrase-container" copy-to-clipboard="{{ wallet.network == \'testnet\' ? keys?.mnemonic : null }}">\n            <div class="phrase">\n              <span *ngFor="let word of mnemonicWords">\n                <span>{{word}}</span>\n                <span *ngIf="useIdeograms">&#x3000;</span>\n              </span>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="bottom-absolute">\n        <div translate class="footer-text">We will confirm on the next screen.</div>\n        <button *ngIf="currentIndex == 0" ion-button class="button-standard" [disabled]="credentialsEncrypted || error" (click)="slideNext(true)">\n          {{\'I have written it down\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n\n    <ion-slide>\n      <div class="slide-container">\n        <div class="slide-body">\n          <div class="slide-title" translate>Let\'s verify your backup phrase.</div>\n          <div class="phrase-container">\n            <div class="phrase">\n              <button ion-button outline *ngFor="let customWord of customWords; let i = index" (click)="removeButton(i, customWord)">{{customWord.word}}</button>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div class="bottom">\n        <div *ngIf="!selectComplete">\n          <ion-item-divider>{{\'Please tap each word in the correct order.\' | translate}}</ion-item-divider>\n          <div class="words">\n            <button ion-button *ngFor="let shuffledWord of shuffledMnemonicWords; let i = index" (click)="addButton(i, shuffledWord)" [disabled]="shuffledWord.selected">{{shuffledWord.word}}\n            </button>\n          </div>\n        </div>\n      </div>\n      <div *ngIf="selectComplete" class="bottom-absolute">\n        <div class="footer-text">{{\'Is this correct?\' | translate}}</div>\n        <button *ngIf="currentIndex == 1 && selectComplete" ion-button class="button-standard" (click)="slideNext(false)">\n          {{\'Confirm\' | translate}}\n        </button>\n        <button ion-button clear class="button-standard" (click)="setFlow()">\n          {{\'Clear\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n\n    <ion-slide *ngIf="wallet.mnemonicHasPassphrase">\n      <div translate>Enter your password</div>\n      <ion-item-divider>{{\'In order to verify your wallet backup, please type your password.\' | translate}}</ion-item-divider>\n      <ion-item>\n        <ion-label stacked translate>Password</ion-label>\n        <ion-input type="password" id="password" [(ngModel)]="password" autocapitalize="off" spellcheck="false"></ion-input>\n      </ion-item>\n      <ion-item-divider class="assertive">\n        {{\'This recovery phrase was created with a password. To recover this wallet both the recovery phrase and password are needed.\' | translate}}\n      </ion-item-divider>\n\n      <div class="bottom-absolute">\n        <button ion-button block [disabled]="!password" (click)="finalStep()">\n          {{\'Confirm\' | translate}}\n        </button>\n        <button *ngIf="currentIndex == 2" [disabled]="!password" ion-button class="button-standard" (click)="finalStep()">\n          {{\'Confirm\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n  </ion-slides>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/backup/backup-game/backup-game.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], BackupGamePage);

//# sourceMappingURL=backup-game.js.map

/***/ }),

/***/ 718:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return HomePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_add__ = __webpack_require__(719);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__integrations_amazon_amazon__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__integrations_bitpay_card_bitpay_card__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__ = __webpack_require__(357);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__integrations_coinbase_coinbase__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__integrations_glidera_glidera__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__integrations_mercado_libre_mercado_libre__ = __webpack_require__(352);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__integrations_shapeshift_shapeshift__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__tx_details_tx_details__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__txp_details_txp_details__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wallet_details_wallet_details__ = __webpack_require__(146);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__activity_activity__ = __webpack_require__(738);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__proposals_proposals__ = __webpack_require__(739);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__providers_feedback_feedback__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_32__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_33__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_34__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_35__providers_release_release__ = __webpack_require__(740);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_36__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_37__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





// Pages














// Providers



















let HomePage = class HomePage {
    constructor(plt, navCtrl, profileProvider, releaseProvider, walletProvider, bwcErrorProvider, logger, events, configProvider, externalLinkProvider, onGoingProcessProvider, popupProvider, modalCtrl, addressBookProvider, appProvider, platformProvider, homeIntegrationsProvider, persistenceProvider, feedbackProvider, bitPayCardProvider, translate, emailProvider, replaceParametersProvider, amazonProvider) {
        this.plt = plt;
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.releaseProvider = releaseProvider;
        this.walletProvider = walletProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.events = events;
        this.configProvider = configProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.modalCtrl = modalCtrl;
        this.addressBookProvider = addressBookProvider;
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.persistenceProvider = persistenceProvider;
        this.feedbackProvider = feedbackProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.translate = translate;
        this.emailProvider = emailProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.amazonProvider = amazonProvider;
        this.showBitPayCard = false;
        this.showAnnouncement = false;
        this.setWallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["debounce"](() => {
            this.wallets = this.profileProvider.getWallets();
            this.walletsBtc = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.wallets, (x) => {
                return x.credentials.coin == 'btc';
            });
            this.walletsBch = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.wallets, (x) => {
                return x.credentials.coin == 'bch';
            });
            this.updateAllWallets();
        }, 5000, {
            leading: true
        });
        this.updateTxps = __WEBPACK_IMPORTED_MODULE_3_lodash__["debounce"](() => {
            this.profileProvider
                .getTxps({ limit: 3 })
                .then(data => {
                this.zone.run(() => {
                    this.txps = data.txps;
                    this.txpsN = data.n;
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        }, 5000, {
            leading: true
        });
        this.getNotifications = __WEBPACK_IMPORTED_MODULE_3_lodash__["debounce"](() => {
            if (!this.recentTransactionsEnabled)
                return;
            this.profileProvider
                .getNotifications({ limit: 3 })
                .then(data => {
                this.zone.run(() => {
                    this.notifications = data.notifications;
                    this.notificationsN = data.total;
                });
            })
                .catch(err => {
                this.logger.error(err);
            });
        }, 5000, {
            leading: true
        });
        this.updatingWalletId = {};
        this.addressbook = {};
        this.cachedBalanceUpdateOn = '';
        this.isNW = this.platformProvider.isNW;
        this.showReorderBtc = false;
        this.showReorderBch = false;
        this.zone = new __WEBPACK_IMPORTED_MODULE_0__angular_core__["NgZone"]({ enableLongStackTrace: false });
    }
    ionViewWillEnter() {
        this.recentTransactionsEnabled = this.configProvider.get().recentTransactions.enabled;
        // Update list of wallets, status and TXPs
        this.setWallets();
        this.addressBookProvider
            .list()
            .then(ab => {
            this.addressbook = ab || {};
        })
            .catch(err => {
            this.logger.error(err);
        });
        // Update Tx Notifications
        this.getNotifications();
    }
    ionViewDidEnter() {
        if (this.isNW)
            this.checkUpdate();
        this.checkHomeTip();
        this.checkFeedbackInfo();
        this.checkAnnouncement();
        this.subscribeBwsEvents();
        // Show integrations
        let integrations = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            show: true
        });
        // Hide BitPay if linked
        setTimeout(() => {
            this.homeIntegrations = __WEBPACK_IMPORTED_MODULE_3_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_3_lodash__["clone"](integrations), x => {
                if (x.name == 'debitcard' && x.linked)
                    return;
                else
                    return x;
            });
        }, 200);
        // Only BitPay Wallet
        this.bitPayCardProvider.get({}, (_, cards) => {
            this.zone.run(() => {
                this.showBitPayCard = this.appProvider.info._enabledExtensions.debitcard
                    ? true
                    : false;
                this.bitpayCardItems = cards;
            });
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad HomePage');
        this.checkEmailLawCompliance();
        this.subscribeStatusEvents();
        this.onResumeSubscription = this.plt.resume.subscribe(() => {
            this.getNotifications();
            this.updateTxps();
            this.setWallets();
            this.subscribeBwsEvents();
            this.subscribeStatusEvents();
        });
        this.onPauseSubscription = this.plt.pause.subscribe(() => {
            this.events.unsubscribe('bwsEvent');
            this.events.unsubscribe('status:updated');
        });
    }
    ngOnDestroy() {
        this.onResumeSubscription.unsubscribe();
        this.onPauseSubscription.unsubscribe();
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    subscribeBwsEvents() {
        // BWS Events: Update Status per Wallet
        // NewBlock, NewCopayer, NewAddress, NewTxProposal, TxProposalAcceptedBy, TxProposalRejectedBy, txProposalFinallyRejected,
        // txProposalFinallyAccepted, TxProposalRemoved, NewIncomingTx, NewOutgoingTx
        this.events.subscribe('bwsEvent', (walletId) => {
            this.getNotifications();
            this.updateWallet(walletId);
        });
    }
    subscribeStatusEvents() {
        // Create, Join, Import and Delete -> Get Wallets -> Update Status for All Wallets
        this.events.subscribe('status:updated', () => {
            this.updateTxps();
            this.setWallets();
        });
    }
    openEmailDisclaimer() {
        let message = this.translate.instant('By providing your email address, you give explicit consent to BitPay to use your email address to send you email notifications about payments.');
        let title = this.translate.instant('Privacy Policy update');
        let okText = this.translate.instant('Accept');
        let cancelText = this.translate.instant('Disable notifications');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (ok) {
                // Accept new Privacy Policy
                this.persistenceProvider.setEmailLawCompliance('accepted');
            }
            else {
                // Disable email notifications
                this.persistenceProvider.setEmailLawCompliance('rejected');
                this.emailProvider.updateEmail({
                    enabled: false,
                    email: 'null@email'
                });
            }
        });
    }
    checkEmailLawCompliance() {
        setTimeout(() => {
            if (this.emailProvider.getEmailIfEnabled()) {
                this.persistenceProvider.getEmailLawCompliance().then(value => {
                    if (!value)
                        this.openEmailDisclaimer();
                });
            }
        }, 2000);
    }
    startUpdatingWalletId(walletId) {
        this.updatingWalletId[walletId] = true;
    }
    stopUpdatingWalletId(walletId) {
        setTimeout(() => {
            this.updatingWalletId[walletId] = false;
        }, 10000);
    }
    checkHomeTip() {
        this.persistenceProvider.getHomeTipAccepted().then((value) => {
            this.homeTip = value == 'accepted' ? false : true;
        });
    }
    hideHomeTip() {
        this.persistenceProvider.setHomeTipAccepted('accepted');
        this.homeTip = false;
    }
    checkAnnouncement() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.amazonProvider.currency)
                yield this.amazonProvider.setCurrencyByLocation();
            if (this.amazonProvider.currency == 'JPY') {
                this.persistenceProvider.getShowAmazonJapanAnnouncement().then(value => {
                    if (!value)
                        this.showAnnouncement = true;
                });
            }
        });
    }
    hideAnnouncement() {
        this.persistenceProvider.setShowAmazonJapanAnnouncement('hide');
        this.showAnnouncement = false;
    }
    openAnnouncement() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__integrations_amazon_amazon__["a" /* AmazonPage */]);
    }
    checkFeedbackInfo() {
        this.persistenceProvider.getFeedbackInfo().then(info => {
            if (!info) {
                this.initFeedBackInfo();
            }
            else {
                let feedbackInfo = info;
                // Check if current version is greater than saved version
                let currentVersion = this.releaseProvider.getCurrentAppVersion();
                let savedVersion = feedbackInfo.version;
                let isVersionUpdated = this.feedbackProvider.isVersionUpdated(currentVersion, savedVersion);
                if (!isVersionUpdated) {
                    this.initFeedBackInfo();
                    return;
                }
                let now = __WEBPACK_IMPORTED_MODULE_4_moment__().unix();
                let timeExceeded = now - feedbackInfo.time >= 24 * 7 * 60 * 60;
                this.showRateCard = timeExceeded && !feedbackInfo.sent;
                this.showCard.setShowRateCard(this.showRateCard);
            }
        });
    }
    initFeedBackInfo() {
        this.persistenceProvider.setFeedbackInfo({
            time: __WEBPACK_IMPORTED_MODULE_4_moment__().unix(),
            version: this.releaseProvider.getCurrentAppVersion(),
            sent: false
        });
        this.showRateCard = false;
    }
    updateWallet(walletId) {
        if (this.updatingWalletId[walletId])
            return;
        this.startUpdatingWalletId(walletId);
        let wallet = this.profileProvider.getWallet(walletId);
        this.walletProvider
            .getStatus(wallet, {})
            .then(status => {
            wallet.status = status;
            wallet.error = null;
            this.profileProvider.setLastKnownBalance(wallet.id, wallet.status.availableBalanceStr);
            this.updateTxps();
            this.stopUpdatingWalletId(walletId);
        })
            .catch(err => {
            this.logger.error(err);
            this.stopUpdatingWalletId(walletId);
        });
    }
    updateAllWallets() {
        let foundMessage = false;
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets))
            return;
        let i = this.wallets.length;
        let j = 0;
        let pr = ((wallet, cb) => {
            this.walletProvider
                .getStatus(wallet, {})
                .then(status => {
                wallet.status = status;
                wallet.error = null;
                if (!foundMessage && !__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](status.serverMessage)) {
                    this.serverMessage = status.serverMessage;
                    foundMessage = true;
                }
                this.profileProvider.setLastKnownBalance(wallet.id, wallet.status.availableBalanceStr);
                return cb();
            })
                .catch(err => {
                wallet.error =
                    err === 'WALLET_NOT_REGISTERED'
                        ? 'Wallet not registered'
                        : this.bwcErrorProvider.msg(err);
                this.logger.warn(this.bwcErrorProvider.msg(err, 'Error updating status for ' + wallet.name));
                return cb();
            });
        }).bind(this);
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](this.wallets, wallet => {
            pr(wallet, () => {
                if (++j == i) {
                    this.updateTxps();
                }
            });
        });
    }
    checkUpdate() {
        this.releaseProvider
            .getLatestAppVersion()
            .toPromise()
            .then(version => {
            this.logger.debug('Current app version:', version);
            var result = this.releaseProvider.checkForUpdates(version);
            this.logger.debug('Update available:', result.updateAvailable);
            if (result.updateAvailable) {
                this.newRelease = true;
                this.updateText = this.replaceParametersProvider.replace(this.translate.instant('There is a new version of {{nameCase}} available'), { nameCase: this.appProvider.info.nameCase });
            }
        })
            .catch(err => {
            this.logger.error('Error getLatestAppVersion', err);
        });
    }
    openServerMessageLink() {
        let url = this.serverMessage.link;
        this.externalLinkProvider.open(url);
    }
    goToAddView() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_add__["a" /* AddPage */]);
    }
    goToWalletDetails(wallet) {
        if (this.showReorderBtc || this.showReorderBch)
            return;
        if (!wallet.isComplete()) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__add_copayers_copayers__["a" /* CopayersPage */], {
                walletId: wallet.credentials.walletId
            });
            return;
        }
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
            walletId: wallet.credentials.walletId
        });
    }
    openNotificationModal(n) {
        let wallet = this.profileProvider.getWallet(n.walletId);
        if (n.txid) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__tx_details_tx_details__["a" /* TxDetailsPage */], { walletId: n.walletId, txid: n.txid });
        }
        else {
            var txp = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.txps, {
                id: n.txpId
            });
            if (txp) {
                this.openTxpModal(txp);
            }
            else {
                this.onGoingProcessProvider.set('loadingTxInfo');
                this.walletProvider
                    .getTxp(wallet, n.txpId)
                    .then(txp => {
                    var _txp = txp;
                    this.onGoingProcessProvider.clear();
                    this.openTxpModal(_txp);
                })
                    .catch(() => {
                    this.onGoingProcessProvider.clear();
                    this.logger.warn('No txp found');
                    let title = this.translate.instant('Error');
                    let subtitle = this.translate.instant('Transaction not found');
                    return this.popupProvider.ionicAlert(title, subtitle);
                });
            }
        }
    }
    reorderBtc() {
        this.showReorderBtc = !this.showReorderBtc;
    }
    reorderBch() {
        this.showReorderBch = !this.showReorderBch;
    }
    reorderWalletsBtc(indexes) {
        let element = this.walletsBtc[indexes.from];
        this.walletsBtc.splice(indexes.from, 1);
        this.walletsBtc.splice(indexes.to, 0, element);
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](this.walletsBtc, (wallet, index) => {
            this.profileProvider.setWalletOrder(wallet.id, index);
        });
    }
    reorderWalletsBch(indexes) {
        let element = this.walletsBch[indexes.from];
        this.walletsBch.splice(indexes.from, 1);
        this.walletsBch.splice(indexes.to, 0, element);
        __WEBPACK_IMPORTED_MODULE_3_lodash__["each"](this.walletsBch, (wallet, index) => {
            this.profileProvider.setWalletOrder(wallet.id, index);
        });
    }
    goToDownload() {
        let url = 'https://github.com/bitpay/copay/releases/latest';
        let optIn = true;
        let title = this.translate.instant('Update Available');
        let message = this.translate.instant('An update to this app is available. For your security, please update to the latest version.');
        let okText = this.translate.instant('View Update');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openTxpModal(tx) {
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_15__txp_details_txp_details__["a" /* TxpDetailsPage */], { tx }, { showBackdrop: false, enableBackdropDismiss: false });
        modal.present();
    }
    openProposalsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__proposals_proposals__["a" /* ProposalsPage */]);
    }
    openActivityPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__activity_activity__["a" /* ActivityPage */]);
    }
    goTo(page) {
        const pageMap = {
            AmazonPage: __WEBPACK_IMPORTED_MODULE_7__integrations_amazon_amazon__["a" /* AmazonPage */],
            BitPayCardIntroPage: __WEBPACK_IMPORTED_MODULE_9__integrations_bitpay_card_bitpay_card_intro_bitpay_card_intro__["a" /* BitPayCardIntroPage */],
            CoinbasePage: __WEBPACK_IMPORTED_MODULE_10__integrations_coinbase_coinbase__["a" /* CoinbasePage */],
            GlideraPage: __WEBPACK_IMPORTED_MODULE_11__integrations_glidera_glidera__["a" /* GlideraPage */],
            MercadoLibrePage: __WEBPACK_IMPORTED_MODULE_12__integrations_mercado_libre_mercado_libre__["a" /* MercadoLibrePage */],
            ShapeshiftPage: __WEBPACK_IMPORTED_MODULE_13__integrations_shapeshift_shapeshift__["a" /* ShapeshiftPage */]
        };
        this.navCtrl.push(pageMap[page]);
    }
    goToCard(cardId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__integrations_bitpay_card_bitpay_card__["a" /* BitPayCardPage */], { id: cardId });
    }
    doRefresh(refresher) {
        refresher.pullMin = 90;
        this.updateAllWallets();
        this.getNotifications();
        setTimeout(() => {
            refresher.complete();
        }, 2000);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('showCard'),
    __metadata("design:type", Object)
], HomePage.prototype, "showCard", void 0);
HomePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-home',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/home/home.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      <img class="home-logo" src="assets/img/app/logo-negative.svg">\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-refresher (ionRefresh)="doRefresh($event)" *ngIf="!showReorderBtc && !showReorderBch">\n    <ion-refresher-content></ion-refresher-content>\n  </ion-refresher>\n  <div class="wrapper">\n    <div class="header-extend">\n      <div *ngIf="!wallets || !wallets[0]" class="no-wallets">\n        <button ion-button clear (click)="goToAddView()">\n          <span translate>Create a new wallet</span>\n        </button>\n      </div>\n    </div>\n\n    <ion-card *ngIf="serverMessage">\n      <ion-item>\n        <div>{{serverMessage.title}}</div>\n        <div>{{serverMessage.body}}</div>\n        <div (click)="openServerMessageLink()">\n          <span translate>Learn more</span>\n        </div>\n      </ion-item>\n    </ion-card>\n\n    <ion-card *ngIf="showAnnouncement">\n      <ion-card-header class="wallet-ready">\n        <ion-row>\n          <button ion-button clear icon-only item-end color="grey" (click)="hideAnnouncement()">\n            <ion-icon name="close"></ion-icon>\n          </button>\n        </ion-row>\n      </ion-card-header>\n      <ion-card-content class="check">\n        <img class="announcement-logo" src="assets/img/amazon/japan/GCs-logo-japan-cllb.jpg" alt="Amazon.co.jp Gift Card">\n        <div class="subtitle">\n          Amazon Amazon.co.jp\n        </div>\n        <div margin-top (click)="openAnnouncement()">\n          <span ion-text color="primary">\n            \n          </span>\n        </div>\n      </ion-card-content>\n    </ion-card>\n\n    <ion-card class="new-release" *ngIf="newRelease">\n      <div class="new-release-icon">\n        <img src="assets/img/icon-update.svg" />\n      </div>\n      <ion-card-header class="new-release-text">\n        {{updateText}}\n      </ion-card-header>\n      <ion-card-content class="new-release-button">\n        <div (click)="goToDownload()">\n          <span translate>Download</span>\n        </div>\n      </ion-card-content>\n    </ion-card>\n\n    <page-feedback-card #showCard></page-feedback-card>\n\n    <ion-card *ngIf="homeTip && wallets && wallets[0]">\n      <ion-card-header class="wallet-ready">\n        <ion-row>\n          <button ion-button clear icon-only item-end color="grey" (click)="hideHomeTip()">\n            <ion-icon name="close"></ion-icon>\n          </button>\n        </ion-row>\n      </ion-card-header>\n      <ion-card-content class="check">\n        <ion-icon class="big-icon-svg check-icon">\n          <img src="assets/img/check-white.svg" class="bg green" />\n        </ion-icon>\n        <div class="title" translate>\n          Your bastoji wallet is ready!\n        </div>\n        <div class="subtitle" translate>\n          On this screen you can see all your wallets, accounts, and assets.\n        </div>\n      </ion-card-content>\n    </ion-card>\n\n    <div class="card" *ngIf="txps && txps[0]">\n      <ion-item-divider (click)="openProposalsPage()">\n        <div class="title" item-start>\n          <span translate>Payment Proposals</span>\n        </div>\n        <div item-end>\n          <button ion-button clear icon-only color="grey">\n            <ion-badge *ngIf="txpsN>3" color="danger">{{txpsN}}</ion-badge>\n            <ion-icon ios="ios-arrow-dropright"></ion-icon>\n          </button>\n        </div>\n      </ion-item-divider>\n      <ion-list>\n        <page-txp *ngFor="let txp of txps" [tx]="txp" [addressbook]="addressbook"></page-txp>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="recentTransactionsEnabled && notifications && notifications[0]">\n      <ion-item-divider (click)="openActivityPage()">\n        <div class="title" item-start>\n          <span translate>Recent Transactions</span>\n        </div>\n        <div item-end>\n          <button ion-button clear icon-only color="grey">\n            <ion-badge *ngIf="notificationsN>3" color="danger">{{notificationsN}}</ion-badge>\n            <ion-icon ios="ios-arrow-dropright"></ion-icon>\n          </button>\n        </div>\n      </ion-item-divider>\n      <ion-list>\n        <page-wallet-activity *ngFor="let notification of notifications" (click)="openNotificationModal(notification)" [notification]="notification"></page-wallet-activity>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="walletsBtc && walletsBtc[0]">\n      <ion-item-divider>\n        <div class="title" item-start>\n          <img src="assets/img/icon-bastoji.svg" alt="Bastoji Wallets" width="18" />\n          <span translate>Bastoji Wallets</span>\n        </div>\n        <div item-end *ngIf="!showReorderBtc">\n          <button ion-button clear icon-only color="grey" (click)="goToAddView()">\n            <ion-icon name="add"></ion-icon>\n          </button>\n          <button ion-button clear icon-only color="grey" (click)="reorderBtc()" *ngIf="walletsBtc.length > 1">\n            <ion-icon name="reorder"></ion-icon>\n          </button>\n        </div>\n        <div item-end *ngIf="showReorderBtc">\n          <button ion-button clear color="secondary" (click)="reorderBtc()">\n            {{\'Done\' | translate}}\n          </button>\n        </div>\n      </ion-item-divider>\n\n      <ion-list reorder="{{showReorderBtc}}" (ionItemReorder)="reorderWalletsBtc($event)">\n        <button ion-item *ngFor="let wallet of walletsBtc" (click)="goToWalletDetails(wallet)">\n          <ion-icon class="item-img" item-start>\n            <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div class="item-title">{{wallet.name}}</div>\n          <div class="item-subtitle">\n            <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n              Incomplete\n            </span>\n            <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n              Needs backup\n            </span>\n            <span *ngIf="wallet.isComplete() && !wallet.needsBackup">\n              <span *ngIf="!wallet.balanceHidden && !wallet.scanning">\n                {{wallet.status && wallet.status.totalBalanceStr ? (wallet.status.totalBalanceStr) : ( wallet.cachedBalance ? wallet.cachedBalance + (wallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( wallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\')}}\n              </span>\n              <span *ngIf="wallet.scanning" translate>Scanning funds</span>\n              <span *ngIf="wallet.balanceHidden && !wallet.scanning">[\n                <span translate>Balance Hidden</span>]</span>\n              <span class="text-gray" *ngIf="wallet.credentials.m > 1">{{wallet.credentials.m}}-of-{{wallet.credentials.n}}</span>\n              <ion-icon *ngIf="!wallet.balanceHidden && wallet.status && (wallet.status.totalBalanceSat != wallet.status.spendableAmount)" ios="ios-timer-outline" md="md-timer"></ion-icon>\n              <span *ngIf="wallet.error" class="wallet-warning">{{wallet.error}}</span>\n            </span>\n          </div>\n        </button>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="walletsBch && walletsBch[0]">\n      <ion-item-divider>\n        <div class="title" item-start>\n          <img src="assets/img/bastoji-cash-logo.svg" alt="Bastoji Cash Wallets" width="22" />\n          <span translate>Bastoji Cash Wallets</span>\n        </div>\n        <div item-end *ngIf="!showReorderBch">\n          <button ion-button clear icon-only color="grey" (click)="goToAddView()">\n            <ion-icon name="add"></ion-icon>\n          </button>\n          <button ion-button clear icon-only color="grey" (click)="reorderBch()" *ngIf="walletsBch.length > 1">\n            <ion-icon name="reorder"></ion-icon>\n          </button>\n        </div>\n        <div item-end *ngIf="showReorderBch">\n          <button ion-button clear color="secondary" (click)="reorderBch()">\n            {{\'Done\' | translate}}\n          </button>\n        </div>\n      </ion-item-divider>\n\n      <ion-list reorder="{{showReorderBch}}" (ionItemReorder)="reorderWalletsBch($event)">\n        <button ion-item *ngFor="let wallet of walletsBch" (click)="goToWalletDetails(wallet)">\n          <ion-icon class="item-img" item-start>\n            <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div class="item-title">{{wallet.name}}</div>\n          <div class="item-subtitle">\n            <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n              Incomplete\n            </span>\n            <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n              Needs backup\n            </span>\n            <span *ngIf="wallet.isComplete() && !wallet.needsBackup">\n              <span *ngIf="!wallet.balanceHidden && !wallet.scanning">\n                {{wallet.status && wallet.status.totalBalanceStr ? (wallet.status.totalBalanceStr) : ( wallet.cachedBalance ? wallet.cachedBalance + (wallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( wallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\')}}\n              </span>\n              <span *ngIf="wallet.scanning" translate>Scanning funds</span>\n              <span *ngIf="wallet.balanceHidden && !wallet.scanning">[\n                <span translate>Balance Hidden</span>]</span>\n              <span *ngIf="wallet.credentials.m > 1">{{wallet.credentials.m}}-of-{{wallet.credentials.n}}</span>\n              <ion-icon *ngIf="!wallet.balanceHidden && wallet.status && (wallet.status.totalBalanceSat != wallet.status.spendableAmount)" name="timer"></ion-icon>\n              <span *ngIf="wallet.error" class="wallet-warning">{{wallet.error}}</span>\n            </span>\n          </div>\n        </button>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="showBitPayCard && bitpayCardItems && bitpayCardItems[0] && wallets &&wallets[0]">\n      <ion-item-divider>\n        <div class="title" item-start>\n          <span>BitPay Visa\n            <sup>&reg;</sup> Card</span>\n        </div>\n        <div item-end>\n          <button ion-button clear icon-only color="grey" (click)="goTo(\'BitPayCardIntroPage\')">\n            <ion-icon name="add"></ion-icon>\n          </button>\n        </div>\n      </ion-item-divider>\n      <ion-list>\n        <button ion-item *ngFor="let card of bitpayCardItems" (click)="goToCard(card.id)">\n          <ion-icon class="item-img" item-start>\n            <img src="assets/img/icon-card.svg" class="icon-card" />\n          </ion-icon>\n          <div class="item-title">BitPay Visa&reg; Card ({{card.lastFourDigits}})</div>\n          <div class="item-subtitle">{{card.balance ? (card.balance | currency:card.currencySymbol:2) : \'Add funds to get started\'|translate}} {{card.updatedOn ? (\' &middot; \' + (card.updatedOn * 1000 | amTimeAgo)) : \'\'}}</div>\n        </button>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="homeIntegrations && homeIntegrations.length>0 && wallets &&wallets[0]">\n      <ion-item-divider (click)="hideHomeIntegrations = !hideHomeIntegrations">\n        <div class="title" item-start translate>Services</div>\n        <div item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="hideHomeIntegrations" name="arrow-dropdown"></ion-icon>\n            <ion-icon *ngIf="!hideHomeIntegrations" name="arrow-dropup"></ion-icon>\n          </button>\n        </div>\n      </ion-item-divider>\n      <ion-list *ngIf="!hideHomeIntegrations">\n        <button ion-item *ngFor="let service of homeIntegrations" (click)="goTo(service.page)">\n          <ion-icon class="item-img" item-start>\n            <img src="{{service.icon}}" class="icon-services" />\n          </ion-icon>\n          <span class="item-title">{{service.title || service.name}}</span>\n        </button>\n      </ion-list>\n\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/home/home.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["n" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_34__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_35__providers_release_release__["a" /* ReleaseProvider */],
        __WEBPACK_IMPORTED_MODULE_37__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_23__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_29__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_24__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_26__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_30__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_33__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_19__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_32__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_28__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_31__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_27__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_22__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_25__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_36__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_amazon_amazon__["a" /* AmazonProvider */]])
], HomePage);

//# sourceMappingURL=home.js.map

/***/ }),

/***/ 719:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__create_wallet_create_wallet__ = __webpack_require__(720);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__import_wallet_import_wallet__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__join_wallet_join_wallet__ = __webpack_require__(350);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// pages



let AddPage = class AddPage {
    constructor(navCtrl, logger) {
        this.navCtrl = navCtrl;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AddPage');
    }
    goToCreateWallet(isShared) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__create_wallet_create_wallet__["a" /* CreateWalletPage */], { isShared });
    }
    goToJoinWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__join_wallet_join_wallet__["a" /* JoinWalletPage */]);
    }
    goToImportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__import_wallet_import_wallet__["a" /* ImportWalletPage */]);
    }
};
AddPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-add',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/add/add.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'New wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <button class="list-button" ion-item (click)="goToCreateWallet(false)">\n    <ion-icon item-start>\n      <img src="assets/img/icon-wallet.svg" class="icon-wallet" />\n    </ion-icon>\n    <span translate>Create personal wallet</span>\n  </button>\n  <button class="list-button" ion-item (click)="goToCreateWallet(true)">\n    <ion-icon item-start>\n      <img src="assets/img/icon-wallet.svg" class="icon-wallet" />\n    </ion-icon>\n    <span translate>Create shared wallet</span>\n  </button>\n  <button class="list-button" ion-item (click)="goToJoinWallet()">\n    <ion-icon class="join-icon" item-start>\n      <img src="assets/img/item-ico-addwallet.svg" class="icon-wallet" />\n    </ion-icon>\n    <span translate>Join shared wallet</span>\n  </button>\n  <button class="list-button" ion-item (click)="goToImportWallet()">\n    <ion-icon class="import-icon" item-start>\n      <img src="assets/img/item-ico-import.svg" class="icon-wallet" />\n    </ion-icon>\n    <span translate>Import wallet</span>\n  </button>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/add/add.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */], __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], AddPage);

//# sourceMappingURL=add.js.map

/***/ }),

/***/ 720:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CreateWalletPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_derivation_path_helper_derivation_path_helper__ = __webpack_require__(240);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Pages

// Providers








let CreateWalletPage = class CreateWalletPage {
    constructor(navCtrl, navParams, fb, profileProvider, configProvider, derivationPathHelperProvider, popupProvider, onGoingProcessProvider, logger, walletProvider, translate, events, pushNotificationsProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.fb = fb;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.derivationPathHelperProvider = derivationPathHelperProvider;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.events = events;
        this.pushNotificationsProvider = pushNotificationsProvider;
        /* For compressed keys, m*73 + n*34 <= 496 */
        this.COPAYER_PAIR_LIMITS = {
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 4,
            6: 4,
            7: 3,
            8: 3,
            9: 2,
            10: 2,
            11: 1,
            12: 1
        };
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        this.isShared = this.navParams.get('isShared');
        this.title = this.isShared
            ? this.translate.instant('Create shared wallet')
            : this.translate.instant('Create personal wallet');
        this.defaults = this.configProvider.getDefaults();
        this.tc = this.isShared ? this.defaults.wallet.totalCopayers : 1;
        this.copayers = __WEBPACK_IMPORTED_MODULE_13_lodash__["range"](2, this.defaults.limits.totalCopayers + 1);
        this.derivationPathByDefault = this.derivationPathHelperProvider.default;
        this.derivationPathForTestnet = this.derivationPathHelperProvider.defaultTestnet;
        this.showAdvOpts = false;
        this.createForm = this.fb.group({
            walletName: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            myName: [null],
            totalCopayers: [1],
            requiredCopayers: [1],
            bwsURL: [this.defaults.bws.url],
            selectedSeed: ['new'],
            recoveryPhrase: [null],
            derivationPath: [this.derivationPathByDefault],
            testnetEnabled: [false],
            singleAddress: [false],
            coin: [null, __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]
        });
        this.setTotalCopayers(this.tc);
        this.updateRCSelect(this.tc);
    }
    ngOnInit() {
        if (this.isShared) {
            this.createForm.get('myName').setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
        }
    }
    setTotalCopayers(n) {
        this.createForm.controls['totalCopayers'].setValue(n);
        this.updateRCSelect(n);
        this.updateSeedSourceSelect();
    }
    updateRCSelect(n) {
        this.createForm.controls['totalCopayers'].setValue(n);
        var maxReq = this.COPAYER_PAIR_LIMITS[n];
        this.signatures = __WEBPACK_IMPORTED_MODULE_13_lodash__["range"](1, maxReq + 1);
        this.createForm.controls['requiredCopayers'].setValue(Math.min(Math.trunc(n / 2 + 1), maxReq));
    }
    updateSeedSourceSelect() {
        this.seedOptions = [
            {
                id: 'new',
                label: this.translate.instant('Random'),
                supportsTestnet: true
            },
            {
                id: 'set',
                label: this.translate.instant('Specify Recovery Phrase'),
                supportsTestnet: false
            }
        ];
        this.createForm.controls['selectedSeed'].setValue(this.seedOptions[0].id); // new or set
    }
    seedOptionsChange(seed) {
        if (seed === 'set') {
            this.createForm
                .get('recoveryPhrase')
                .setValidators([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required]);
        }
        else {
            this.createForm.get('recoveryPhrase').setValidators(null);
        }
        this.createForm.controls['selectedSeed'].setValue(seed); // new or set
        if (this.createForm.controls['testnet'])
            this.createForm.controls['testnet'].setValue(false);
        this.createForm.controls['derivationPath'].setValue(this.derivationPathByDefault);
        this.createForm.controls['recoveryPhrase'].setValue(null);
    }
    setDerivationPath() {
        let path = this.createForm.value.testnet
            ? this.derivationPathForTestnet
            : this.derivationPathByDefault;
        this.createForm.controls['derivationPath'].setValue(path);
    }
    setOptsAndCreate() {
        let opts = {
            name: this.createForm.value.walletName,
            m: this.createForm.value.requiredCopayers,
            n: this.createForm.value.totalCopayers,
            myName: this.createForm.value.totalCopayers > 1
                ? this.createForm.value.myName
                : null,
            networkName: this.createForm.value.testnetEnabled ? 'testnet' : 'livenet',
            bwsurl: this.createForm.value.bwsURL,
            singleAddress: this.createForm.value.singleAddress,
            coin: this.createForm.value.coin
        };
        let setSeed = this.createForm.value.selectedSeed == 'set';
        if (setSeed) {
            let words = this.createForm.value.recoveryPhrase || '';
            if (words.indexOf(' ') == -1 &&
                words.indexOf('prv') == 1 &&
                words.length > 108) {
                opts.extendedPrivateKey = words;
            }
            else {
                opts.mnemonic = words;
            }
            let pathData = this.derivationPathHelperProvider.parse(this.createForm.value.derivationPath);
            if (!pathData) {
                let title = this.translate.instant('Error');
                let subtitle = this.translate.instant('Invalid derivation path');
                this.popupProvider.ionicAlert(title, subtitle);
                return;
            }
            opts.networkName = pathData.networkName;
            opts.derivationStrategy = pathData.derivationStrategy;
        }
        if (setSeed && !opts.mnemonic && !opts.extendedPrivateKey) {
            let title = this.translate.instant('Error');
            let subtitle = this.translate.instant('Please enter the wallet recovery phrase');
            this.popupProvider.ionicAlert(title, subtitle);
            return;
        }
        this.create(opts);
    }
    create(opts) {
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createWallet(opts)
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            this.events.publish('status:updated');
            this.walletProvider.updateRemotePreferences(wallet);
            this.pushNotificationsProvider.updateSubscription(wallet);
            if (this.createForm.value.selectedSeed == 'set') {
                this.profileProvider.setBackupFlag(wallet.credentials.walletId);
            }
            if (!wallet.isComplete()) {
                this.navCtrl.popToRoot();
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__copayers_copayers__["a" /* CopayersPage */], {
                    walletId: wallet.credentials.walletId
                });
            }
            else {
                this.navCtrl.popToRoot();
            }
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error('Create: could not create wallet', err);
            let title = this.translate.instant('Error');
            this.popupProvider.ionicAlert(title, err);
            return;
        });
    }
};
CreateWalletPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-create-wallet',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/add/create-wallet/create-wallet.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <form [formGroup]="createForm" (ngSubmit)="setOptsAndCreate()">\n    <ion-item>\n      <ion-label stacked>{{\'Wallet name\' | translate}}</ion-label>\n      <ion-input type="text" formControlName="walletName" placeholder="{{\'Enter wallet name\'| translate}}"></ion-input>\n    </ion-item>\n\n    <div *ngIf="isShared">\n      <ion-item>\n        <ion-label stacked>{{\'Your name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="myName" placeholder="{{\'Enter your name\'| translate}}"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Total number of sqoiners\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="totalCopayers" (ionChange)="setTotalCopayers(createForm.value.totalCopayers)">\n          <ion-option *ngFor="let copayer of copayers" [value]="copayer">{{copayer}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Required number of signatures\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="requiredCopayers">\n          <ion-option *ngFor="let signature of signatures" [value]="signature">{{signature}}</ion-option>\n        </ion-select>\n      </ion-item>\n    </div>\n\n    <ion-item>\n      <ion-label stacked>{{\'Coin\' | translate}}</ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" placeholder="{{\'Select a coin\' | translate}}" formControlName="coin">\n        <ion-option value="btc">Bastoji (BTJ)</ion-option>\n        <ion-option value="bch">Bastoji Cash (BCH)</ion-option>\n      </ion-select>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item (click)="showAdvOpts = !showAdvOpts">\n      <ion-label *ngIf="!showAdvOpts">{{\'Show advanced options\' | translate}}</ion-label>\n      <ion-label *ngIf="showAdvOpts">{{\'Hide advanced options\' | translate}}</ion-label>\n      <div item-end>\n        <ion-icon color="grey" *ngIf="!showAdvOpts" name="ios-arrow-down-outline"></ion-icon>\n        <ion-icon color="grey" *ngIf="showAdvOpts" name="ios-arrow-up-outline"></ion-icon>\n      </div>\n    </ion-item>\n\n    <div *ngIf="showAdvOpts">\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsURL"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label stacked>{{\'Wallet key\' | translate}}</ion-label>\n        <ion-select okText="{{okText}}" cancelText="{{cancelText}}" formControlName="selectedSeed" (ionChange)="seedOptionsChange(createForm.value.selectedSeed)">\n          <ion-option *ngFor="let opt of seedOptions" [value]="opt.id">{{opt.label}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item *ngIf="createForm.value.selectedSeed == \'set\'">\n        <ion-label stacked>{{\'Wallet recovery phrase\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="recoveryPhrase"></ion-input>\n      </ion-item>\n\n      <ion-item *ngIf="createForm.value.selectedSeed == \'new\'">\n        <ion-label>Testnet</ion-label>\n        <ion-toggle formControlName="testnetEnabled" (ionChange)="setDerivationPath()"></ion-toggle>\n      </ion-item>\n\n      <ion-item *ngIf="createForm.value.testnetEnabled">\n        <div class="warning-container">\n          <ion-icon name="ios-warning-outline"></ion-icon>\n          <span translate>WARNING: The testnet is an alternative Bastoji block chain, to be used for testing. Testnet coins are separate and distinct from actual bastojis, and do not have any value. This allows application developers or bastoji testers to experiment, without having to use real bastojis.</span>\n        </div>\n      </ion-item>\n\n      <ion-item *ngIf="createForm.value.selectedSeed == \'set\'">\n        <ion-label stacked>{{\'Derivation path\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="derivationPath"></ion-input>\n      </ion-item>\n\n      <ion-item>\n        <ion-label>{{\'Single address\' | translate}}</ion-label>\n        <ion-toggle formControlName="singleAddress"></ion-toggle>\n      </ion-item>\n    </div>\n  </form>\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar>\n    <button ion-button full class="button-footer" (click)="setOptsAndCreate()" [disabled]="!createForm.valid">\n      {{\'Create wallet\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/add/create-wallet/create-wallet.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_derivation_path_helper_derivation_path_helper__["a" /* DerivationPathHelperProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_12__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */]])
], CreateWalletPage);

//# sourceMappingURL=create-wallet.js.map

/***/ }),

/***/ 721:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyAmazonPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__amazon__ = __webpack_require__(351);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






// Pages


// Provider














let BuyAmazonPage = class BuyAmazonPage {
    constructor(amazonProvider, bwcErrorProvider, bwcProvider, configProvider, replaceParametersProvider, emailNotificationsProvider, events, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txFormatProvider, walletProvider, translate, payproProvider, platformProvider) {
        this.amazonProvider = amazonProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.payproProvider = payproProvider;
        this.platformProvider = platformProvider;
        this.showError = function (title, msg) {
            return new Promise(resolve => {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                title = title || this.translate.instant('Error');
                this.logger.error(msg);
                msg = msg && msg.errors ? msg.errors[0].message : msg;
                this.popupProvider.ionicAlert(title, msg).then(() => {
                    return resolve();
                });
            });
        };
        this.checkTransaction = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((count, dataSrc) => {
            this.amazonProvider.createGiftCard(dataSrc, (err, giftCard) => {
                this.logger.debug('creating gift card ' + count);
                if (err) {
                    giftCard = giftCard || {};
                    giftCard['status'] = 'FAILURE';
                }
                let now = __WEBPACK_IMPORTED_MODULE_4_moment__().unix() * 1000;
                let newData = giftCard;
                newData.invoiceId = dataSrc.invoiceId;
                newData.accessKey = dataSrc.accessKey;
                newData.invoiceUrl = dataSrc.invoiceUrl;
                newData.amount = dataSrc.amount;
                newData.date = dataSrc.invoiceTime || now;
                newData.uuid = dataSrc.uuid;
                if (newData.status == 'expired') {
                    this.amazonProvider.savePendingGiftCard(newData, {
                        remove: true
                    }, err => {
                        this.logger.error(err);
                        this.onGoingProcessProvider.clear();
                        this.showError(null, this.translate.instant('Gift card expired'));
                    });
                    return;
                }
                if (giftCard.status == 'PENDING' && count < 3) {
                    this.logger.debug('Waiting for payment confirmation');
                    this.amazonProvider.savePendingGiftCard(newData, null, () => {
                        this.logger.debug('Saving gift card with status: ' + newData.status);
                    });
                    this.checkTransaction(count + 1, dataSrc);
                    return;
                }
                this.amazonProvider.savePendingGiftCard(newData, null, () => {
                    this.onGoingProcessProvider.clear();
                    this.logger.debug('Saved new gift card with status: ' + newData.status);
                    this.amazonGiftCard = newData;
                    this.openFinishModal();
                });
            });
        }, 15000, {
            leading: true
        });
        this.FEE_TOO_HIGH_LIMIT_PER = 15;
        this.configWallet = this.configProvider.get().wallet;
        this.amazonGiftCard = null;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.isCordova = this.platformProvider.isCordova;
        this.country = this.amazonProvider.country;
        this.pageTitle = this.amazonProvider.pageTitle;
        this.onlyIntegers = this.amazonProvider.onlyIntegers;
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad BuyAmazonPage');
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        let limitPerDay = this.amazonProvider.limitPerDay;
        this.limitPerDayMessage = this.replaceParametersProvider.replace(this.translate.instant('Purchase Amount is limited to {{limitPerDay}} {{currency}} per day'), { limitPerDay, currency: this.currency });
        if (this.amount > this.amazonProvider.limitPerDay) {
            this.showErrorAndBack(null, this.limitPerDayMessage);
            return;
        }
        this.network = this.amazonProvider.getNetwork();
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            hasFunds: true
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets available'));
            return;
        }
        this.showWallets(); // Show wallet selector
    }
    checkFeeHigh(amount, fee) {
        let per = (fee / (amount + fee)) * 100;
        if (per > this.FEE_TOO_HIGH_LIMIT_PER) {
            const feeWarningModal = this.popupProvider.createMiniModal('fee-warning');
            feeWarningModal.present();
        }
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    _resetValues() {
        this.totalAmountStr = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.createdTx = this.message = this.invoiceId = null;
    }
    showErrorAndBack(title, msg) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    satToFiat(coin, sat) {
        return new Promise(resolve => {
            this.txFormatProvider
                .toFiat(coin, sat, this.currencyIsoCode)
                .then((value) => {
                return resolve(value);
            });
        });
    }
    setTotalAmount(wallet, amountSat, invoiceFeeSat, networkFeeSat) {
        this.satToFiat(wallet.coin, amountSat).then((a) => {
            this.amount = Number(a);
            this.satToFiat(wallet.coin, invoiceFeeSat).then((i) => {
                this.invoiceFee = Number(i);
                this.satToFiat(wallet.coin, networkFeeSat).then((n) => {
                    this.networkFee = Number(n);
                    this.totalAmount = this.amount + this.invoiceFee + this.networkFee;
                });
            });
        });
    }
    isCryptoCurrencySupported(wallet, invoice) {
        let COIN = wallet.coin.toUpperCase();
        if (!invoice['supportedTransactionCurrencies'][COIN])
            return false;
        return invoice['supportedTransactionCurrencies'][COIN].enabled;
    }
    createInvoice(data) {
        return new Promise((resolve, reject) => {
            this.amazonProvider.createBitPayInvoice(data, (err, dataInvoice) => {
                if (err) {
                    let err_title = this.translate.instant('Error creating the invoice');
                    let err_msg;
                    if (err && err.message && err.message.match(/suspended/i)) {
                        err_title = this.translate.instant('Service not available');
                        err_msg = this.translate.instant('Amazon.com is not available at this moment. Please try back later.');
                    }
                    else if (err && err.message) {
                        err_msg = err.message;
                    }
                    else {
                        err_msg = this.translate.instant('Could not access to Amazon.com');
                    }
                    return reject({
                        title: err_title,
                        message: err_msg
                    });
                }
                let accessKey = dataInvoice ? dataInvoice.accessKey : null;
                if (!accessKey) {
                    return reject({
                        message: this.translate.instant('No access key defined')
                    });
                }
                this.amazonProvider.getBitPayInvoice(dataInvoice.invoiceId, (err, invoice) => {
                    if (err) {
                        return reject({
                            message: this.translate.instant('Could not get the invoice')
                        });
                    }
                    return resolve({ invoice, accessKey });
                });
            });
        });
    }
    createTx(wallet, invoice, message) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            let payProUrl = invoice && invoice.paymentCodes
                ? invoice.paymentCodes[COIN].BIP73
                : null;
            if (!payProUrl) {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                });
            }
            this.payproProvider
                .getPayProDetails(payProUrl, wallet.coin)
                .then(details => {
                let txp = {
                    amount: details.amount,
                    toAddress: details.toAddress,
                    outputs: [
                        {
                            toAddress: details.toAddress,
                            amount: details.amount,
                            message
                        }
                    ],
                    message,
                    customData: {
                        service: 'amazon'
                    },
                    payProUrl,
                    excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                        ? false
                        : true
                };
                if (details.requiredFeeRate) {
                    txp.feePerKb = Math.ceil(details.requiredFeeRate * 1024);
                    this.logger.debug('Using merchant fee rate (for amazon gc):' + txp.feePerKb);
                }
                else {
                    txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
                }
                txp['origToAddress'] = txp.toAddress;
                if (wallet.coin && wallet.coin == 'bch') {
                    // Use legacy address
                    txp.toAddress = this.bitcoreCash.Address(txp.toAddress).toString();
                    txp.outputs[0].toAddress = txp.toAddress;
                }
                this.walletProvider
                    .createTx(wallet, txp)
                    .then(ctxp => {
                    return resolve(ctxp);
                })
                    .catch(err => {
                    return reject({
                        title: this.translate.instant('Could not create transaction'),
                        message: this.bwcErrorProvider.msg(err)
                    });
                });
            })
                .catch(err => {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: err
                });
            });
        });
    }
    initialize(wallet) {
        let COIN = wallet.coin.toUpperCase();
        let email = this.emailNotificationsProvider.getEmailIfEnabled();
        let parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, this.amount, this.currency);
        this.currencyIsoCode = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        let dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency,
            uuid: wallet.id,
            email,
            buyerSelectedTransactionCurrency: COIN
        };
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.createInvoice(dataSrc)
            .then(data => {
            let invoice = data.invoice;
            let accessKey = data.accessKey;
            if (!this.isCryptoCurrencySupported(wallet, invoice)) {
                this.onGoingProcessProvider.clear();
                let msg = this.translate.instant('Purchases with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            this.message = this.replaceParametersProvider.replace(this.translate.instant('{{amountUnitStr}} Gift Card'), { amountUnitStr: this.amountUnitStr });
            this.createTx(wallet, invoice, this.message)
                .then(ctxp => {
                this.onGoingProcessProvider.clear();
                // Save in memory
                this.createdTx = ctxp;
                this.invoiceId = invoice.id;
                this.createdTx.giftData = {
                    currency: dataSrc.currency,
                    amount: dataSrc.amount,
                    uuid: dataSrc.uuid,
                    accessKey,
                    invoiceId: invoice.id,
                    invoiceUrl: invoice.url,
                    invoiceTime: invoice.invoiceTime
                };
                this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount);
                // Warn: fee too high
                this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
                this.setTotalAmount(wallet, parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message);
                return;
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
            return;
        });
    }
    buyConfirm() {
        if (!this.createdTx) {
            this.showError(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        let title = this.translate.instant('Confirm');
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, this.message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.publishAndSign(this.wallet, this.createdTx)
                .then(() => {
                this.onGoingProcessProvider.set('buyingGiftCard');
                this.checkTransaction(1, this.createdTx.giftData);
            })
                .catch(err => {
                this._resetValues();
                this.showError(this.translate.instant('Could not send transaction'), this.bwcErrorProvider.msg(err));
                return;
            });
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        this.initialize(wallet);
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Buy from');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishComment;
        let cssClass;
        if (this.amazonGiftCard.status == 'FAILURE') {
            finishComment = this.translate.instant('Your purchase could not be completed');
            cssClass = 'danger';
        }
        if (this.amazonGiftCard.status == 'PENDING') {
            finishComment = this.translate.instant('Your purchase was added to the list of pending');
            cssClass = 'warning';
        }
        if (this.amazonGiftCard.status == 'SUCCESS') {
            finishComment = this.replaceParametersProvider.replace(this.translate.instant('Bought {{ amount }}'), { amount: this.amountUnitStr });
        }
        if (this.amazonGiftCard.status == 'SUCCESS') {
            finishComment = this.translate.instant('Gift card generated and ready to use.');
        }
        let finishText = '';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, cssClass }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__amazon__["a" /* AmazonPage */], { invoiceId: this.invoiceId, country: this.country }, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], BuyAmazonPage.prototype, "slideButton", void 0);
BuyAmazonPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-buy-amazon',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/buy-amazon/buy-amazon.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Buy Gift Card</ion-title>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <div class="amazon-title">\n        <img src="assets/img/amazon/icon-amazon.svg">\n        {{pageTitle}}\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative">\n          {{limitPerDayMessage}}\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>{{\'From\' | translate}}</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <div *ngIf="totalAmountStr">\n        <ion-item-divider>\n          {{\'Details\' | translate}}\n        </ion-item-divider>\n        <ion-item>\n          <span>{{\'Gift Card\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{amount | number : \'1.0-0\'}}</span> \n            <span *ngIf="!onlyIntegers">{{amount | number : \'1.2-2\'}}</span> \n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span>{{\'Network cost\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{invoiceFee | number : \'1.0-0\'}}</span> \n            <span *ngIf="!onlyIntegers">{{invoiceFee | number : \'1.2-2\'}}</span> \n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span>{{\'Miner fee\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="onlyIntegers">{{networkFee | number : \'1.0-0\'}}</span> \n            <span *ngIf="!onlyIntegers">{{networkFee | number : \'1.2-2\'}}</span> \n            {{currencyIsoCode}}\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span>{{\'Total\' | translate}}</span>\n          <ion-note item-end>\n            <span *ngIf="totalAmount">\n              <span *ngIf="onlyIntegers">{{totalAmount | number : \'1.0-0\'}}</span> \n              <span *ngIf="!onlyIntegers">{{totalAmount | number : \'1.2-2\'}}</span> \n              {{currencyIsoCode}}\n            </span>\n            <span *ngIf="totalAmountStr">({{totalAmountStr}})</span>\n          </ion-note>\n        </ion-item>\n      </div>\n      <ion-item-divider></ion-item-divider>\n      <!-- USA -->\n      <ion-item class="amazon-info" *ngIf="country == \'usa\'">\n        *\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> is not a sponsor of this promotion. Except as required by law,\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> Gift Cards ("GCs") cannot be transferred for value or redeemed for cash. GCs may be used only for purchases of eligible goods at\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> or certain of its affiliated websites. For complete terms and conditions, see\n        <a (click)="openExternalLink(\'https://www.amazon.com/gc-legal\')">www.amazon.com/gc-legal</a>. GCs are issued by ACI Gift Cards, Inc., a Washington corporation. All Amazon &reg;, &trade; &amp; &copy; are IP of\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a>, Inc. or its affiliates. No expiration date or service fees.\n      </ion-item>\n\n      <!-- Japan -->\n      <ion-item class="amazon-info" *ngIf="country == \'japan\'">\n        * Amazon Gift Cards Japan  () Amazon ()\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> (PC) 10(0120-999-3731-8-1) (\n        <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/tc\')">www.amazon.co.jp/giftcard/tc</a>)\n        <br>\n        <br>* To use\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> gift cards (Gift Card or Gift Cards) issued by Amazon Gift Cards Japan K.K. (Amazon GC), you need to create an account on\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">http://www.amazon.co.jp</a> (including PC and mobile sites. Amazon Sites). Gift Cards can only be redeemed through Amazon Sites, but cannot be used to purchase other Gift Cards or to pay certain membership fee available at Amazon Sites. Gift Card balance will expire at 11:59 p.m. (Japan Time) of the date specified as expiration date on each Gift Card. Gift Cards are non-refundable and non-exchangeable. Gift Card cannot be resold or transferred for value. Amazon GC or its affiliates are not responsible if Gift Card is lost, stolen, destroyed or used without your permission. If you want to know your Gift Card balance, expiration date or have any other questions regarding Gift Cards, please call Customer Service (TEL: 0120-999-373, Address: 1-8-1 Shimomeguro, Meguro-ku, Tokyo 153-0064, Japan). For more information, please read the full Terms and Conditions of Gift Cards (\n        <a (click)="openExternalLink(\'http://www.amazon.co.jp/giftcard/tc\')">http://www.amazon.co.jp/giftcard/tc</a>).\n      </ion-item>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!(wallet && totalAmountStr)" buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="buyConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!(wallet && totalAmountStr)">{{\'Confirm purchase\' | translate}}</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/buy-amazon/buy-amazon.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_amazon_amazon__["a" /* AmazonProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_13__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */]])
], BuyAmazonPage);

//# sourceMappingURL=buy-amazon.js.map

/***/ }),

/***/ 722:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPayCardTopUpPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bitpay_card__ = __webpack_require__(242);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_bitpay__ = __webpack_require__(170);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





// Pages


// Provider














const FEE_TOO_HIGH_LIMIT_PER = 15;
let BitPayCardTopUpPage = class BitPayCardTopUpPage {
    constructor(bitPayCardProvider, bitPayProvider, bwcErrorProvider, bwcProvider, configProvider, events, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txFormatProvider, walletProvider, translate, platformProvider, feeProvider, payproProvider) {
        this.bitPayCardProvider = bitPayCardProvider;
        this.bitPayProvider = bitPayProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.platformProvider = platformProvider;
        this.feeProvider = feeProvider;
        this.payproProvider = payproProvider;
        this.configWallet = this.configProvider.get().wallet;
        this.isCordova = this.platformProvider.isCordova;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad BitPayCardTopUpPage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.cardId = this.navParams.data.id;
        this.useSendMax = this.navParams.data.useSendMax;
        this.currency = this.navParams.data.currency;
        this.amount = this.navParams.data.amount;
        let coin;
        if (this.currency == 'BTJ')
            coin = 'btc';
        else if (this.currency == 'BCH')
            coin = 'bch';
        else
            coin = null;
        this.bitPayCardProvider.get({
            cardId: this.cardId,
            noRefresh: true
        }, (err, card) => {
            if (err) {
                this.showErrorAndBack(null, err);
                return;
            }
            this.bitPayCardProvider.setCurrencySymbol(card[0]);
            this.lastFourDigits = card[0].lastFourDigits;
            this.currencySymbol = card[0].currencySymbol;
            this.currencyIsoCode = card[0].currency;
            this.wallets = this.profileProvider.getWallets({
                onlyComplete: true,
                network: this.bitPayProvider.getEnvironment().network,
                hasFunds: true,
                coin
            });
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets)) {
                this.showErrorAndBack(null, this.translate.instant('No wallets available'));
                return;
            }
            this.showWallets(); // Show wallet selector
        });
    }
    updateRates(coin) {
        this.bitPayCardProvider.getRatesFromCoin(coin.toUpperCase(), this.currencyIsoCode, (err, r) => {
            if (err)
                this.logger.error(err);
            this.rate = r.rate;
        });
    }
    _resetValues() {
        this.totalAmountStr = this.amount = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.createdTx = null;
    }
    showErrorAndBack(title, msg) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(title, msg) {
        return new Promise(resolve => {
            if (this.isCordova)
                this.slideButton.isConfirmed(false);
            title = title || this.translate.instant('Error');
            this.logger.error(msg);
            msg = msg && msg.errors ? msg.errors[0].message : msg;
            this.popupProvider.ionicAlert(title, msg).then(() => {
                return resolve();
            });
        });
    }
    satToFiat(coin, sat) {
        return new Promise(resolve => {
            this.txFormatProvider
                .toFiat(coin, sat, this.currencyIsoCode)
                .then((value) => {
                return resolve(value);
            });
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    setTotalAmount(wallet, amountSat, invoiceFeeSat, networkFeeSat) {
        this.satToFiat(wallet.coin, amountSat).then((a) => {
            this.amount = Number(a);
            this.satToFiat(wallet.coin, invoiceFeeSat).then((i) => {
                this.invoiceFee = Number(i);
                this.satToFiat(wallet.coin, networkFeeSat).then((n) => {
                    this.networkFee = Number(n);
                    this.totalAmount = this.amount + this.invoiceFee + this.networkFee;
                });
            });
        });
    }
    isCryptoCurrencySupported(wallet, invoice) {
        let COIN = wallet.coin.toUpperCase();
        if (!invoice['supportedTransactionCurrencies'][COIN])
            return false;
        return invoice['supportedTransactionCurrencies'][COIN].enabled;
    }
    createInvoice(data) {
        return new Promise((resolve, reject) => {
            this.bitPayCardProvider.topUp(this.cardId, data, (err, invoiceId) => {
                if (err) {
                    return reject({
                        title: 'Could not create the invoice',
                        message: err
                    });
                }
                this.bitPayCardProvider.getInvoice(invoiceId, (err, inv) => {
                    if (err) {
                        return reject({
                            title: 'Could not get the invoice',
                            message: err
                        });
                    }
                    return resolve(inv);
                });
            });
        });
    }
    createTx(wallet, invoice, message) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            let payProUrl = invoice && invoice.paymentCodes
                ? invoice.paymentCodes[COIN].BIP73
                : null;
            if (!payProUrl) {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                });
            }
            this.payproProvider
                .getPayProDetails(payProUrl, wallet.coin)
                .then(details => {
                let txp = {
                    amount: details.amount,
                    toAddress: details.toAddress,
                    outputs: [
                        {
                            toAddress: details.toAddress,
                            amount: details.amount,
                            message
                        }
                    ],
                    message,
                    customData: {
                        service: 'debitcard'
                    },
                    payProUrl,
                    excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                        ? false
                        : true
                };
                if (details.requiredFeeRate) {
                    txp.feePerKb = Math.ceil(details.requiredFeeRate * 1024);
                    this.logger.debug('Using merchant fee rate (for debit card):' + txp.feePerKb);
                }
                else {
                    txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
                }
                txp['origToAddress'] = txp.toAddress;
                if (wallet.coin && wallet.coin == 'bch') {
                    // Use legacy address
                    txp.toAddress = this.bitcoreCash.Address(txp.toAddress).toString();
                    txp.outputs[0].toAddress = txp.toAddress;
                }
                this.walletProvider
                    .createTx(wallet, txp)
                    .then(ctxp => {
                    return resolve(ctxp);
                })
                    .catch(err => {
                    return reject({
                        title: this.translate.instant('Could not create transaction'),
                        message: this.bwcErrorProvider.msg(err)
                    });
                });
            });
        });
    }
    getSendMaxInfo(wallet) {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getCurrentFeeRate(wallet.coin, wallet.credentials.network)
                .then(feePerKb => {
                this.walletProvider
                    .getSendMaxInfo(wallet, {
                    feePerKb,
                    excludeUnconfirmedUtxos: !this.configWallet.spendUnconfirmed,
                    returnInputs: true
                })
                    .then(resp => {
                    return resolve({
                        sendMax: true,
                        amount: resp.amount,
                        inputs: resp.inputs,
                        fee: resp.fee,
                        feePerKb
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    toFixedTrunc(value, n) {
        const v = value.toString().split('.');
        if (n <= 0)
            return v[0];
        let f = v[1] || '';
        if (f.length > n)
            return `${v[0]}.${f.substr(0, n)}`;
        while (f.length < n)
            f += '0';
        return `${v[0]}.${f}`;
    }
    calculateAmount(wallet) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            // Global variables defined beforeEnter
            let a = this.amount;
            let c = this.currency;
            if (this.useSendMax) {
                this.getSendMaxInfo(wallet)
                    .then(maxValues => {
                    if (maxValues.amount == 0) {
                        return reject({
                            message: this.translate.instant('Insufficient funds for fee')
                        });
                    }
                    let maxAmount = Number((maxValues.amount / 100000000).toFixed(8));
                    // Round to 6 digits
                    maxAmount = this.toFixedTrunc(maxAmount, 6);
                    this.createInvoice({
                        amount: maxAmount,
                        currency: wallet.coin.toUpperCase(),
                        buyerSelectedTransactionCurrency: wallet.coin.toUpperCase()
                    })
                        .then(inv => {
                        // Check if BTJ or BCH is enabled in this account
                        if (!this.isCryptoCurrencySupported(wallet, inv)) {
                            return reject({
                                message: this.translate.instant('Top-up with this cryptocurrency is not enabled')
                            });
                        }
                        inv['minerFees'][COIN]['totalFee'] =
                            inv.minerFees[COIN].totalFee || 0;
                        let invoiceFeeSat = inv.minerFees[COIN].totalFee;
                        let maxAmountSat = Number((maxAmount * 100000000).toFixed(0));
                        let newAmountSat = maxAmountSat - invoiceFeeSat;
                        if (newAmountSat <= 0) {
                            return reject({
                                message: this.translate.instant('Insufficient funds for fee')
                            });
                        }
                        return resolve({ amount: newAmountSat, currency: 'sat' });
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(err => {
                    return reject({
                        title: null,
                        message: err
                    });
                });
            }
            else {
                return resolve({ amount: a, currency: c });
            }
        });
    }
    checkFeeHigh(amount, fee) {
        let per = (fee / (amount + fee)) * 100;
        if (per > FEE_TOO_HIGH_LIMIT_PER) {
            const feeWarningModal = this.popupProvider.createMiniModal('fee-warning');
            feeWarningModal.present();
        }
    }
    initializeTopUp(wallet, parsedAmount) {
        let COIN = wallet.coin.toUpperCase();
        this.amountUnitStr = parsedAmount.amountUnitStr;
        var dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency,
            buyerSelectedTransactionCurrency: wallet.coin.toUpperCase()
        };
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.createInvoice(dataSrc)
            .then(invoice => {
            // Check if BTJ or BCH is enabled in this account
            if (!this.isCryptoCurrencySupported(wallet, invoice)) {
                let msg = this.translate.instant('Top-up with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            let message = this.amountUnitStr + ' to ' + this.lastFourDigits;
            this.createTx(wallet, invoice, message)
                .then(ctxp => {
                this.onGoingProcessProvider.clear();
                // Save TX in memory
                this.createdTx = ctxp;
                this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount);
                // Warn: fee too high
                this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
                this.setTotalAmount(wallet, parsedAmount.amountSat, Number(invoiceFeeSat), ctxp.fee);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
        });
    }
    topUpConfirm() {
        if (!this.createdTx) {
            this.showError(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        let title = this.translate.instant('Confirm');
        let message = 'Load ' + this.amountUnitStr;
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('topup');
            this.publishAndSign(this.wallet, this.createdTx)
                .then(() => {
                this.onGoingProcessProvider.clear();
                this.openFinishModal();
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(this.translate.instant('Could not send transaction'), this.bwcErrorProvider.msg(err));
            });
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        // Update Rates
        this.updateRates(wallet.coin);
        this.onGoingProcessProvider.set('retrievingInputs');
        this.calculateAmount(wallet)
            .then(val => {
            let parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, val.amount, val.currency);
            this.initializeTopUp(wallet, parsedAmount);
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this._resetValues();
            this.showError(err.title, err.message).then(() => {
                this.showWallets();
            });
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'From');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        const finishComment = this.wallet.credentials.m === 1
            ? this.translate.instant('Funds were added to debit card')
            : this.translate.instant('Transaction initiated');
        let finishText = '';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_5__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__bitpay_card__["a" /* BitPayCardPage */], { id: this.cardId }, { animate: false });
        }));
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], BitPayCardTopUpPage.prototype, "slideButton", void 0);
BitPayCardTopUpPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-bitpay-card-topup',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card-topup/bitpay-card-topup.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Add funds\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <div class="bitpay-title">\n        <img src="assets/img/bitpay-card/bitpay-card-visa.svg">\n        <span>BitPay Visa&reg; Card ({{lastFourDigits}})</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative" *ngIf="wallet">\n          <span *ngIf="rate">\n            @ {{rate | currency:currencySymbol:2}} {{currencyIsoCode}} per {{wallet.coin.toUpperCase()}}\n          </span>\n          <span *ngIf="!rate">...</span>\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div translate>From</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <div *ngIf="totalAmountStr">\n        <ion-item-divider>\n          Details\n        </ion-item-divider>\n        <ion-item>\n          <span translate>Funds to be added</span>\n          <ion-note item-end>\n            <span *ngIf="amount">{{amount | currency:currencySymbol:2}} {{currencyIsoCode}}</span>\n            <span *ngIf="!amount">...</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Network cost</span>\n          <ion-note item-end>\n            <span>{{invoiceFee | currency:currencySymbol:2}} {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Miner fee</span>\n          <ion-note item-end>\n            <span>{{networkFee | currency:currencySymbol:2}} {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Total</span>\n          <ion-note item-end>\n            <span *ngIf="totalAmount">{{totalAmount | currency:currencySymbol:2}} {{currencyIsoCode}}</span>\n            <span *ngIf="totalAmountStr">({{totalAmountStr}})</span>\n          </ion-note>\n        </ion-item>\n      </div>\n      <ion-item-divider></ion-item-divider>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!(wallet && totalAmountStr)" buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="topUpConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="topUpConfirm()" [disabled]="!(wallet && totalAmountStr)">\n      {{\'Add funds\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-card-topup/bitpay-card-topup.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bitpay_bitpay__["a" /* BitPayProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__["a" /* PayproProvider */]])
], BitPayCardTopUpPage);

//# sourceMappingURL=bitpay-card-topup.js.map

/***/ }),

/***/ 723:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyCoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__coinbase__ = __webpack_require__(182);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// providers








// pages


let BuyCoinbasePage = class BuyCoinbasePage {
    constructor(coinbaseProvider, logger, popupProvider, navCtrl, events, externalLinkProvider, onGoingProcessProvider, navParams, walletProvider, txFormatProvider, profileProvider, modalCtrl, platformProvider) {
        this.coinbaseProvider = coinbaseProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.navParams = navParams;
        this.walletProvider = walletProvider;
        this.txFormatProvider = txFormatProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.platformProvider = platformProvider;
        this.coin = 'btc';
        this.isFiat = this.navParams.data.currency != 'BTJ' ? true : false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.network = this.coinbaseProvider.getNetwork();
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad BuyCoinbasePage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallets available');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            let accessToken = res.accessToken;
            this.coinbaseProvider.buyPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (err, b) => {
                if (err)
                    this.logger.error(err);
                this.buyPrice = b.data || null;
            });
            this.paymentMethods = [];
            this.selectedPaymentMethodId = null;
            this.coinbaseProvider.getPaymentMethods(accessToken, (err, p) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showErrorAndBack(err);
                    return;
                }
                let hasPrimary;
                let pm;
                for (let i = 0; i < p.data.length; i++) {
                    pm = p.data[i];
                    if (pm.allow_buy) {
                        this.paymentMethods.push(pm);
                    }
                    if (pm.allow_buy && pm.primary_buy) {
                        hasPrimary = true;
                        this.selectedPaymentMethodId = pm.id;
                    }
                }
                if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.paymentMethods)) {
                    this.onGoingProcessProvider.clear();
                    let url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
                    let msg = 'No payment method available to buy';
                    let okText = 'More info';
                    let cancelText = 'Go Back';
                    this.popupProvider
                        .ionicConfirm(null, msg, okText, cancelText)
                        .then(res => {
                        if (res)
                            this.externalLinkProvider.open(url);
                        this.navCtrl.remove(3, 1);
                        this.navCtrl.pop();
                    });
                    return;
                }
                if (!hasPrimary)
                    this.selectedPaymentMethodId = this.paymentMethods[0].id;
                this.buyRequest();
            });
        });
    }
    buyRequest() {
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            let accessToken = res.accessToken;
            let accountId = res.accountId;
            let dataSrc = {
                amount: this.amount,
                currency: this.currency,
                payment_method: this.selectedPaymentMethodId,
                quote: true
            };
            this.coinbaseProvider.buyRequest(accessToken, accountId, dataSrc, (err, data) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(err);
                    return;
                }
                this.buyRequestInfo = data.data;
            });
        });
    }
    buyConfirm() {
        let message = 'Buy bastoji for ' + this.amountUnitStr;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then((ok) => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('buyingBastoji');
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let dataSrc = {
                    amount: this.amount,
                    currency: this.currency,
                    payment_method: this.selectedPaymentMethodId,
                    commit: true
                };
                this.coinbaseProvider.buyRequest(accessToken, accountId, dataSrc, (err, b) => {
                    if (err) {
                        this.onGoingProcessProvider.clear();
                        this.showError(this.coinbaseProvider.getErrorsAsString(err));
                        return;
                    }
                    setTimeout(() => {
                        let tx = b.data ? b.data.transaction : null;
                        if (tx && tx.id) {
                            this.processBuyTx(tx, accessToken, accountId);
                        }
                        else {
                            this._processBuyOrder(b, accessToken, accountId);
                        }
                    }, 10000);
                });
            });
        });
    }
    processBuyTx(tx, accessToken, accountId) {
        if (!tx) {
            this.onGoingProcessProvider.clear();
            this.showError('Transaction not found');
            return;
        }
        this.coinbaseProvider.getTransaction(accessToken, accountId, tx.id, (err, updatedTx) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showError(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            this.walletProvider
                .getAddress(this.wallet, false)
                .then((walletAddr) => {
                updatedTx.data['toAddr'] = walletAddr;
                updatedTx.data['status'] = 'pending'; // Forcing "pending" status to process later
                this.logger.debug('Saving transaction to process later...');
                this.coinbaseProvider.savePendingTransaction(updatedTx.data, {}, err => {
                    this.onGoingProcessProvider.clear();
                    if (err)
                        this.logger.debug(err);
                    this.openFinishModal();
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.showError(err);
            });
        });
    }
    _processBuyOrder(b, accessToken, accountId) {
        this.coinbaseProvider.getBuyOrder(accessToken, accountId, b.data.id, (err, buyResp) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showError(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let tx = buyResp.data ? buyResp.data.transaction : null;
            if (tx && tx.id) {
                this.processBuyTx(tx, accessToken, accountId);
            }
            else {
                setTimeout(() => {
                    this._processBuyOrder(b, accessToken, accountId);
                }, 10000);
            }
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Receive in');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        // Buy always in BTJ
        this.amount = (parsedAmount.amountSat / 100000000).toFixed(8);
        this.currency = 'BTJ';
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.onGoingProcessProvider.set('calculatingFee');
        this.coinbaseProvider.checkEnoughFundsForFee(this.amount, err => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.showErrorAndBack(err);
                return;
            }
            this.processPaymentInfo();
        });
    }
    openFinishModal() {
        let finishText = 'Bought';
        let finishComment = 'Bastoji purchase completed. Coinbase has queued the transfer to your selected wallet';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_12__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__coinbase__["a" /* CoinbasePage */], { coin: 'btc' }, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], BuyCoinbasePage.prototype, "slideButton", void 0);
BuyCoinbasePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-buy-coinbase',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/buy-coinbase/buy-coinbase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="buyRequestInfo">\n    <ion-item>\n      <div class="sending-label">\n        <img class="sending-img" src="assets/img/icon-tx-sent-outline.svg">\n        <span>Buying</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative" *ngIf="buyPrice">\n          <span ng-show="isFiat">{{buyRequestInfo.amount.amount}} {{buyRequestInfo.amount.currency}}</span> @ ${{buyPrice.amount}} per BTJ\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <ion-item>\n        <ion-label stacked>Payment Method</ion-label>\n        <ion-select [(ngModel)]="selectedPaymentMethodId" (ionChange)="buyRequest()">\n          <ion-option *ngFor="let item of paymentMethods" [value]="item.id">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>Receive in</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        <span>Amount</span>\n        <ion-note item-end>\n          {{buyRequestInfo.subtotal.amount}} {{buyRequestInfo.subtotal.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngFor="let fee of buyRequestInfo.fees">\n        <span class="capitalized">{{fee.type}} fee</span>\n        <ion-note item-end>\n          {{fee.amount.amount}} {{fee.amount.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Total to pay</span>\n        <ion-note item-end>\n          {{buyRequestInfo.total.amount}} {{buyRequestInfo.total.currency}}\n        </ion-note>\n      </ion-item>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!wallet || !buyRequestInfo || !selectedPaymentMethodId" buttonText="Slide to confirm" (slideDone)="buyConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!wallet || !buyRequestInfo || !selectedPaymentMethodId">Confirm purchase</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/buy-coinbase/buy-coinbase.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */]])
], BuyCoinbasePage);

//# sourceMappingURL=buy-coinbase.js.map

/***/ }),

/***/ 724:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseTxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers


let CoinbaseTxDetailsPage = class CoinbaseTxDetailsPage {
    constructor(viewCtrl, coinbaseProvider, popupProvider, navParams) {
        this.viewCtrl = viewCtrl;
        this.coinbaseProvider = coinbaseProvider;
        this.popupProvider = popupProvider;
        this.navParams = navParams;
        this.tx = this.navParams.data.tx;
    }
    remove() {
        this.coinbaseProvider.setCredentials();
        this.updateRequired = false;
        var message = 'Are you sure you want to remove this transaction?';
        this.popupProvider
            .ionicConfirm(null, message, null, null)
            .then((ok) => {
            if (!ok) {
                return;
            }
            this.coinbaseProvider.savePendingTransaction(this.tx, {
                remove: true
            }, () => {
                this.updateRequired = true;
                this.close();
            });
        });
    }
    close() {
        this.viewCtrl.dismiss({ updateRequired: this.updateRequired });
    }
};
CoinbaseTxDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-coinbase-tx-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      Details\n    </ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        Close\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n\n  <ion-card>\n    <ion-card-content text-center>\n      <div>\n        <img src="assets/img/bought.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.type == \'send\' && tx.to)) && tx.status == \'completed\'">\n        <img src="assets/img/bought-pending.svg" alt="bought" *ngIf="(tx.type == \'buy\' || (tx.type == \'send\' && tx.to)) && tx.status != \'completed\'">\n        <img src="assets/img/sold.svg" alt="sold" *ngIf="tx.type == \'sell\' && tx.status == \'completed\'">\n        <img src="assets/img/sold-pending.svg" alt="sold" *ngIf="(tx.type == \'sell\' || (tx.type == \'send\' && tx.from)) && tx.status != \'completed\'">\n      </div>\n      <div class="title" padding>\n        <div *ngIf="tx.status == \'completed\'">\n          <span *ngIf="tx.type == \'buy\' || tx.type == \'send\'">Bought</span>\n          <span *ngIf="tx.type == \'sell\'">Sold</span>\n        </div>\n        <div *ngIf="tx.type == \'send\' && (tx.to || tx.from) && tx.status != \'completed\'">\n          <span *ngIf="tx.to">Receiving purchased bastoji</span>\n          <span *ngIf="tx.from">Sending bastoji to sell</span>\n        </div>\n        <div *ngIf="(tx.type == \'sell\' || tx.type == \'buy\') && tx.status != \'completed\'">\n          <span *ngIf="tx.type == \'buy\'">Buying bastoji</span>\n          <span *ngIf="tx.type == \'sell\'">Selling bastoji</span>\n        </div>\n      </div>\n      <div class="price">\n        <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.amount.amount.replace(\'-\',\'\')}} {{tx.amount.currency}}\n      </div>\n      <div class="alternative-price">\n        <span *ngIf="tx.type == \'sell\' || (tx.type == \'send\' && tx.from)">-</span>{{tx.native_amount.amount.replace(\'-\',\'\')}} {{tx.native_amount.currency}}\n      </div>\n    </ion-card-content>\n  </ion-card>\n  <ion-list>\n\n    <ion-item *ngFor="let err of tx.error.errors">\n      <ion-label>\n        <span>{{err.message}}</span>\n      </ion-label>\n    </ion-item>\n\n    <ion-item *ngIf="tx.details && tx.status != \'pending\'">\n      <ion-label>\n        <span>{{tx.details.title}}</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.details.subtitle}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      <ion-label>\n        <span>Status</span>\n      </ion-label>\n      <ion-note item-end>\n        <span class="balanced" *ngIf="tx.status == \'completed\'">Completed</span>\n        <span class="dark" *ngIf="tx.status == \'pending\'">Pending</span>\n        <span class="assertive" *ngIf="tx.status == \'error\'">Error</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.created_at">\n      <ion-label>\n        <span>Date</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.created_at | amCalendar}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.price_sensitivity">\n      <ion-label>\n        <span>Price Sensitivity</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.price_sensitivity.name}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.sell_price_amount">\n      <ion-label>\n        <span>Sell Price</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.sell_price_amount}} {{tx.sell_price_currency}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.description">\n      <ion-label>\n        <span *ngIf="tx.from && tx.type == \'send\'">Sent bastoji from</span>\n        <span *ngIf="tx.to && tx.type == \'send\'">Receive bastoji in</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.description}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider *ngIf="tx.status == \'error\'"></ion-item-divider>\n\n    <ion-item *ngIf="tx.status == \'error\'">\n      <ion-label>\n        <span (click)="remove()">Remove transaction</span>\n      </ion-label>\n    </ion-item>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase-tx-details/coinbase-tx-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */]])
], CoinbaseTxDetailsPage);

//# sourceMappingURL=coinbase-tx-details.js.map

/***/ }),

/***/ 725:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SellCoinbasePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__coinbase__ = __webpack_require__(182);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// pages


// providers











let SellCoinbasePage = class SellCoinbasePage {
    constructor(appProvider, bwcErrorProvider, coinbaseProvider, configProvider, events, logger, popupProvider, navCtrl, navParams, externalLinkProvider, onGoingProcessProvider, walletProvider, txFormatProvider, profileProvider, modalCtrl, platformProvider) {
        this.appProvider = appProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.coinbaseProvider = coinbaseProvider;
        this.configProvider = configProvider;
        this.events = events;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.txFormatProvider = txFormatProvider;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.platformProvider = platformProvider;
        this.checkTransaction = __WEBPACK_IMPORTED_MODULE_2_lodash__["throttle"]((count, txp) => {
            this.logger.warn('Check if transaction has been received by Coinbase. Try ' +
                count +
                '/5');
            // TX amount in BTJ
            let satToBtc = 1 / 100000000;
            let amountBTJ = (txp.amount * satToBtc).toFixed(8);
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.logger.error(err);
                    this.checkTransaction(count, txp);
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let sellPrice = null;
                this.coinbaseProvider.sellPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (err, sell) => {
                    if (err) {
                        this.logger.debug(this.coinbaseProvider.getErrorsAsString(err));
                        this.checkTransaction(count, txp);
                        return;
                    }
                    sellPrice = sell.data;
                    this.coinbaseProvider.getTransactions(accessToken, accountId, (err, ctxs) => {
                        if (err) {
                            this.logger.debug(this.coinbaseProvider.getErrorsAsString(err));
                            this.checkTransaction(count, txp);
                            return;
                        }
                        let coinbaseTransactions = ctxs.data;
                        let txFound = false;
                        let ctx;
                        for (let i = 0; i < coinbaseTransactions.length; i++) {
                            ctx = coinbaseTransactions[i];
                            if (ctx.type == 'send' &&
                                ctx.from &&
                                ctx.amount.amount == amountBTJ) {
                                this.logger.warn('Transaction found!', ctx);
                                txFound = true;
                                this.logger.debug('Saving transaction to process later...');
                                ctx.payment_method = this.selectedPaymentMethodId;
                                ctx.status = 'pending'; // Forcing "pending" status to process later
                                ctx.price_sensitivity = this.selectedPriceSensitivity;
                                ctx.sell_price_amount = sellPrice ? sellPrice.amount : '';
                                ctx.sell_price_currency = sellPrice
                                    ? sellPrice.currency
                                    : 'USD';
                                ctx.description =
                                    this.appProvider.info.nameCase +
                                        ' Wallet: ' +
                                        this.wallet.name;
                                this.coinbaseProvider.savePendingTransaction(ctx, null, err => {
                                    this.onGoingProcessProvider.clear();
                                    this.openFinishModal();
                                    if (err)
                                        this.logger.debug(this.coinbaseProvider.getErrorsAsString(err));
                                });
                                return;
                            }
                        }
                        if (!txFound) {
                            // Transaction sent, but could not be verified by Coinbase.com
                            this.logger.warn('Transaction not found in Coinbase. Will try 5 times...');
                            if (count < 5) {
                                this.checkTransaction(count + 1, txp);
                            }
                            else {
                                this.onGoingProcessProvider.clear();
                                this.showError('No transaction found');
                                return;
                            }
                        }
                    });
                });
            });
        }, 8000, {
            leading: true
        });
        this.coin = 'btc';
        this.isFiat = this.navParams.data.currency != 'BTJ' ? true : false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.priceSensitivity = this.coinbaseProvider.priceSensitivity;
        this.selectedPriceSensitivity = {
            data: this.coinbaseProvider.selectedPriceSensitivity
        };
        this.network = this.coinbaseProvider.getNetwork();
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad SellCoinbasePage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.wallets = this.profileProvider.getWallets({
            m: 1,
            onlyComplete: true,
            network: this.network,
            hasFunds: true,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallet available to operate with Coinbase');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                let err = 'No signing proposal: No private key';
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingCoinbase');
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let accessToken = res.accessToken;
            this.coinbaseProvider.sellPrice(accessToken, this.coinbaseProvider.getAvailableCurrency(), (_, s) => {
                this.sellPrice = s.data || null;
            });
            this.paymentMethods = [];
            this.selectedPaymentMethodId = null;
            this.coinbaseProvider.getPaymentMethods(accessToken, (err, p) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let hasPrimary;
                let pm;
                for (let i = 0; i < p.data.length; i++) {
                    pm = p.data[i];
                    if (pm.allow_buy) {
                        this.paymentMethods.push(pm);
                    }
                    if (pm.allow_buy && pm.primary_buy) {
                        hasPrimary = true;
                        this.selectedPaymentMethodId = pm.id;
                    }
                }
                if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.paymentMethods)) {
                    this.onGoingProcessProvider.clear();
                    let url = 'https://support.coinbase.com/customer/portal/articles/1148716-payment-methods-for-us-customers';
                    let msg = 'No payment method available to buy';
                    let okText = 'More info';
                    let cancelText = 'Go Back';
                    this.popupProvider
                        .ionicConfirm(null, msg, okText, cancelText)
                        .then(res => {
                        if (res)
                            this.externalLinkProvider.open(url);
                        this.navCtrl.remove(3, 1);
                        this.navCtrl.pop();
                    });
                    return;
                }
                if (!hasPrimary)
                    this.selectedPaymentMethodId = this.paymentMethods[0].id;
                this.sellRequest();
            });
        });
    }
    sellRequest() {
        this.coinbaseProvider.init((err, res) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                return;
            }
            let accessToken = res.accessToken;
            let accountId = res.accountId;
            let dataSrc = {
                amount: this.amount,
                currency: this.currency,
                payment_method: this.selectedPaymentMethodId,
                quote: true
            };
            this.coinbaseProvider.sellRequest(accessToken, accountId, dataSrc, (err, data) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                this.sellRequestInfo = data.data;
            });
        });
    }
    sellConfirm() {
        let config = this.configProvider.get();
        let configWallet = config.wallet;
        let walletSettings = configWallet.settings;
        let message = 'Selling bastoji for ' + this.amount + ' ' + this.currency;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('sellingBastoji');
            this.coinbaseProvider.init((err, res) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(this.coinbaseProvider.getErrorsAsString(err));
                    return;
                }
                let accessToken = res.accessToken;
                let accountId = res.accountId;
                let dataSrc = {
                    name: 'Received from ' + this.appProvider.info.nameCase
                };
                this.coinbaseProvider.createAddress(accessToken, accountId, dataSrc, (err, data) => {
                    if (err) {
                        this.onGoingProcessProvider.clear();
                        this.showError(this.coinbaseProvider.getErrorsAsString(err));
                        return;
                    }
                    let outputs = [];
                    let toAddress = data.data.address;
                    let amountSat = parseInt((this.sellRequestInfo.amount.amount * 100000000).toFixed(0), 10);
                    let comment = 'Sell bastoji (Coinbase)';
                    outputs.push({
                        toAddress,
                        amount: amountSat,
                        message: comment
                    });
                    let txp = {
                        toAddress,
                        amount: amountSat,
                        outputs,
                        message: comment,
                        payProUrl: null,
                        excludeUnconfirmedUtxos: configWallet.spendUnconfirmed
                            ? false
                            : true,
                        feeLevel: walletSettings.feeLevel || 'normal'
                    };
                    this.walletProvider
                        .createTx(this.wallet, txp)
                        .then(ctxp => {
                        this.logger.debug('Transaction created.');
                        this.publishAndSign(this.wallet, ctxp)
                            .then(txSent => {
                            this.logger.debug('Transaction broadcasted. Wait for Coinbase confirmation...');
                            this.checkTransaction(1, txSent);
                        })
                            .catch(err => {
                            this.onGoingProcessProvider.clear();
                            this.showError(this.bwcErrorProvider.msg(err));
                            return;
                        });
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        this.showError(err);
                        return;
                    });
                });
            });
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Sell from');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        this.amount = parsedAmount.amount;
        this.currency = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.processPaymentInfo();
    }
    openFinishModal() {
        let finishText = 'Funds sent to Coinbase Account';
        let finishComment = 'The transaction is not yet confirmed, and will show as "Pending" in your Activity. The bastoji sale will be completed automatically once it is confirmed by Coinbase';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__coinbase__["a" /* CoinbasePage */], { coin: 'btc' }, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], SellCoinbasePage.prototype, "slideButton", void 0);
SellCoinbasePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-sell-coinbase',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/sell-coinbase/sell-coinbase.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="sellRequestInfo">\n    <ion-item>\n      <div class="selling-label">\n        <img class="selling-img" src="assets/img/sell-bastoji.svg">\n        <span>Selling</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative">\n          <span *ngIf="isFiat">{{sellRequestInfo.subtotal}} {{sellRequestInfo.currency}}</span> @ ${{sellPrice.amount}} per BTJ\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>From</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n\n      <ion-item>\n        <ion-label stacked>Deposit into</ion-label>\n        <ion-select [(ngModel)]="selectedPaymentMethodId" (ionChange)="sellRequest()">\n          <ion-option *ngFor="let item of paymentMethods" [value]="item.id">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item-divider>\n        At what percentage lower price would you accept to sell?\n      </ion-item-divider>\n\n      <ion-item>\n        <ion-label stacked>Price Sensitivity</ion-label>\n        <ion-select [(ngModel)]="selectedPriceSensitivity">\n          <ion-option *ngFor="let item of priceSensitivity" [value]="item">{{item.name}}</ion-option>\n        </ion-select>\n      </ion-item>\n\n      <ion-item *ngIf="selectedPriceSensitivity">\n        <div>\n          Coinbase has not yet implemented an immediate method to sell bastoji from a wallet. To make this sale, funds will be sent to your Coinbase account, and sold when Coinbase accepts the transaction (usually one hour).\n        </div>\n        <div *ngIf="sellRequestInfo">\n          Estimated sale value:\n          <strong>\n            {{sellRequestInfo.total.amount | currency : \'\' : 2}} {{sellRequestInfo.total.currency}}\n          </strong>\n        </div>\n        <div *ngIf="sellRequestInfo">\n          Still sell if price fall until:\n          <strong>\n            {{(sellRequestInfo.total.amount - (selectedPriceSensitivity.data.value / 100) * sellRequestInfo.total.amount) | currency : \'\' : 2}} {{sellRequestInfo.total.currency}}\n          </strong>\n        </div>\n      </ion-item>\n\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        Amount\n        <ion-note item-end>\n          {{sellRequestInfo.subtotal.amount}} {{sellRequestInfo.subtotal.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item *ngFor="let fee of sellRequestInfo.fees">\n        <span>\n          {{fee.type}} fee\n        </span>\n        <ion-note item-end>\n          <span *ngIf="fee.amount.amount != \'0.00\'">-</span> {{fee.amount.amount}} {{fee.amount.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        Total to receive\n        <ion-note>\n          {{sellRequestInfo.total.amount}} {{sellRequestInfo.total.currency}}\n        </ion-note>\n      </ion-item>\n\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!selectedPaymentMethodId || !sellRequestInfo || !wallet" buttonText="Slide to confirm" (slideDone)="sellConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="sellConfirm()" [disabled]="!selectedPaymentMethodId || !sellRequestInfo || !wallet">Confirm sale</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/sell-coinbase/sell-coinbase.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_13__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_14__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_12__providers_platform_platform__["a" /* PlatformProvider */]])
], SellCoinbasePage);

//# sourceMappingURL=sell-coinbase.js.map

/***/ }),

/***/ 726:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyGlideraPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__integrations_glidera_glidera__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_12_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__integrations__ = __webpack_require__(728);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



// pages


// providers









let BuyGlideraPage = class BuyGlideraPage {
    constructor(platformProvider, events, logger, popupProvider, navCtrl, navParams, onGoingProcessProvider, glideraProvider, profileProvider, txFormatProvider, walletProvider, modalCtrl) {
        this.platformProvider = platformProvider;
        this.events = events;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.glideraProvider = glideraProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.modalCtrl = modalCtrl;
        this.coin = 'btc';
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.isFiat = this.navParams.data.currency != 'BTJ' ? true : false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.network = this.glideraProvider.getNetwork();
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_12_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallets available');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err || '';
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingGlidera');
        this.glideraProvider.init((err, data) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            this.token = data.token;
            var price = Object(__WEBPACK_IMPORTED_MODULE_13__integrations__["a" /* setPrice */])(this.isFiat, this.amount);
            this.glideraProvider.buyPrice(this.token, price, (err, buy) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(err);
                    return;
                }
                this.buyInfo = buy;
            });
        });
    }
    ask2FaCode(mode, cb) {
        if (mode != 'NONE') {
            // SHOW PROMPT
            var title = 'Please, enter the code below';
            var message;
            if (mode == 'PIN') {
                message = 'You have enabled PIN based two-factor authentication.';
            }
            else if (mode == 'AUTHENTICATOR') {
                message = 'Use an authenticator app (Authy or Google Authenticator).';
            }
            else {
                message =
                    'A SMS containing a confirmation code was sent to your phone.';
            }
            this.popupProvider.ionicPrompt(title, message).then(twoFaCode => {
                if (typeof twoFaCode == 'undefined')
                    return cb();
                return cb(twoFaCode);
            });
        }
        else {
            return cb();
        }
        return undefined;
    }
    buyConfirm() {
        let message = 'Buy bastoji for ' + this.amount + ' ' + this.currency;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('buyingBastoji');
            this.glideraProvider.get2faCode(this.token, (err, tfa) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(err);
                    return;
                }
                this.ask2FaCode(tfa.mode, twoFaCode => {
                    if (tfa.mode != 'NONE' && __WEBPACK_IMPORTED_MODULE_12_lodash__["isEmpty"](twoFaCode)) {
                        this.onGoingProcessProvider.clear();
                        this.showError('No code entered');
                        return;
                    }
                    this.walletProvider
                        .getAddress(this.wallet, false)
                        .then(walletAddr => {
                        let data = {
                            destinationAddress: walletAddr,
                            qty: this.buyInfo.qty,
                            priceUuid: this.buyInfo.priceUuid,
                            useCurrentPrice: false,
                            ip: null
                        };
                        this.glideraProvider.buy(this.token, twoFaCode, data, (err, data) => {
                            this.onGoingProcessProvider.clear();
                            if (err)
                                return this.showError(err);
                            this.logger.info('Glidera Buy Info: ', JSON.stringify(data));
                            this.openFinishModal();
                        });
                    })
                        .catch(() => {
                        this.onGoingProcessProvider.clear();
                        this.showError(err);
                    });
                });
            });
        });
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Receive in');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_12_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        this.amount = parsedAmount.amount;
        this.currency = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.processPaymentInfo();
    }
    openFinishModal() {
        let finishText = 'Bought';
        let finishComment = 'A transfer has been initiated from your bank account. Your bastojis should arrive to your wallet in 2-4 business day';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__integrations_glidera_glidera__["a" /* GlideraPage */], null, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], BuyGlideraPage.prototype, "slideButton", void 0);
BuyGlideraPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-buy-glidera',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/buy-glidera/buy-glidera.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Glidera</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="buyInfo">\n    <ion-item>\n      <div class="buying-label">\n        <img class="buying-img" src="assets/img/icon-tx-sent-outline.svg">\n        <span>Buying</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative">\n          <span *ngIf="!isFiat">{{buyInfo.subtotal}} {{buyInfo.currency}}</span>\n          <span *ngIf="isFiat">{{buyInfo.qty}} BTJ</span> @ ${{buyInfo.price}} per BTJ\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>Receive in</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        <span>Expires</span>\n        <ion-note item-end>\n          {{buyInfo.expires | amCalendar}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Fees</span>\n        <ion-note item-end>\n          {{buyInfo.fees}} {{buyInfo.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Total to pay</span>\n        <ion-note item-end>\n          {{buyInfo.total}} {{buyInfo.currency}}\n        </ion-note>\n      </ion-item>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!wallet" buttonText="Slide to confirm" (slideDone)="buyConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="buyConfirm()" [disabled]="!wallet">Confirm purchase</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/buy-glidera/buy-glidera.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__["a" /* GlideraProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
], BuyGlideraPage);

//# sourceMappingURL=buy-glidera.js.map

/***/ }),

/***/ 727:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlideraTxDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


let GlideraTxDetailsPage = class GlideraTxDetailsPage {
    constructor(navParams, viewCtrl) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.tx = this.navParams.data.tx;
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
GlideraTxDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-glidera-tx-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera-tx-details/glidera-tx-details.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>\n      Details\n    </ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        Close\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n\n  <ion-card>\n    <ion-card-content text-center>\n      <div>\n        <img src="assets/img/bought.svg" alt="bought" width="20" *ngIf="tx.type == \'BUY\' && tx.status == \'COMPLETE\'">\n        <img src="assets/img/bought-pending.svg" alt="bought" width="15" *ngIf="tx.type == \'BUY\' && tx.status == \'PROCESSING\'">\n        <img src="assets/img/sold.svg" alt="bought" width="20" *ngIf="tx.type == \'SELL\' && tx.status == \'COMPLETE\'">\n        <img src="assets/img/sold-pending.svg" alt="bought" width="15" *ngIf="tx.type == \'SELL\' && tx.status == \'PROCESSING\'">\n      </div>\n      <div class="title" padding>\n        <span *ngIf="tx.type == \'BUY\'">Bought</span>\n        <span *ngIf="tx.type == \'SELL\'">Sold</span>\n        <b>{{tx.qty}}</b> BTJ\n      </div>\n      <div class="price">\n        {{tx.subtotal|currency:\'\':2}} {{tx.currency}}\n      </div>\n    </ion-card-content>\n  </ion-card>\n  <ion-list>\n\n    <ion-item>\n      <ion-label>\n        <span>Status</span>\n      </ion-label>\n      <ion-note item-end>\n        <span class="text-success" *ngIf="tx.status == \'COMPLETE\'">Completed</span>\n        <span class="text-info" *ngIf="tx.status == \'PROCESSING\'">Processing</span>\n        <span class="text-warning" *ngIf="tx.status == \'ERROR\'">Error</span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.transactionDate">\n      <ion-label>\n        <span>Date</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.transactionDate | amCalendar}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.price">\n      <ion-label>\n        <span>Exchange rate</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.price|currency:\'\':2}} {{tx.currency}}/BTJ\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.subtotal">\n      <ion-label>\n        <span>Subtotal</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.subtotal|currency:\'\':2}} {{tx.currency}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.fees">\n      <ion-label>\n        <span>Fees</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.fees|currency:\'\':2}} {{tx.currency}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="tx.total">\n      <ion-label>\n        <span>Total</span>\n      </ion-label>\n      <ion-note item-end>\n        {{tx.total|currency:\'\':2}} {{tx.currency}}\n      </ion-note>\n    </ion-item>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera-tx-details/glidera-tx-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */]])
], GlideraTxDetailsPage);

//# sourceMappingURL=glidera-tx-details.js.map

/***/ }),

/***/ 728:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = setPrice;
function setPrice(isFiat, amount) {
    return {
        fiat: isFiat ? amount : undefined,
        qty: isFiat ? undefined : amount
    };
}
//# sourceMappingURL=integrations.js.map

/***/ }),

/***/ 729:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SellGlideraPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__integrations_glidera_glidera__ = __webpack_require__(183);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__integrations__ = __webpack_require__(728);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};




// pages


// providers









let SellGlideraPage = class SellGlideraPage {
    constructor(platformProvider, logger, popupProvider, navCtrl, navParams, onGoingProcessProvider, glideraProvider, profileProvider, txFormatProvider, walletProvider, configProvider, events, modalCtrl) {
        this.platformProvider = platformProvider;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.glideraProvider = glideraProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.configProvider = configProvider;
        this.events = events;
        this.modalCtrl = modalCtrl;
        this.coin = 'btc';
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.isFiat = this.navParams.data.currency != 'BTJ' ? true : false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.network = this.glideraProvider.getNetwork();
        this.wallets = this.profileProvider.getWallets({
            m: 1,
            onlyComplete: true,
            network: this.network,
            hasFunds: true,
            coin: this.coin
        });
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack('No wallets available');
            return;
        }
        this.onWalletSelect(this.wallets[0]); // Default first wallet
    }
    showErrorAndBack(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err).then(() => {
            this.navCtrl.pop();
        });
    }
    showError(err) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        this.logger.error(err);
        err = err.errors ? err.errors[0].message : err;
        this.popupProvider.ionicAlert('Error', err);
    }
    processPaymentInfo() {
        this.onGoingProcessProvider.set('connectingGlidera');
        this.glideraProvider.init((err, data) => {
            if (err) {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(err);
                return;
            }
            this.token = data.token;
            let price = Object(__WEBPACK_IMPORTED_MODULE_14__integrations__["a" /* setPrice */])(this.isFiat, this.amount);
            this.glideraProvider.sellPrice(this.token, price, (err, sell) => {
                this.onGoingProcessProvider.clear();
                if (err) {
                    this.showErrorAndBack(err);
                    return;
                }
                this.sellInfo = sell;
            });
        });
    }
    ask2FaCode(mode, cb) {
        if (mode != 'NONE') {
            // SHOW PROMPT
            let title = 'Please, enter the code below';
            let message;
            if (mode == 'PIN') {
                message = 'You have enabled PIN based two-factor authentication.';
            }
            else if (mode == 'AUTHENTICATOR') {
                message = 'Use an authenticator app (Authy or Google Authenticator).';
            }
            else {
                message =
                    'A SMS containing a confirmation code was sent to your phone.';
            }
            this.popupProvider.ionicPrompt(title, message).then(twoFaCode => {
                if (typeof twoFaCode == 'undefined')
                    return cb();
                return cb(twoFaCode);
            });
        }
        else {
            return cb();
        }
        return undefined;
    }
    sellConfirm() {
        let message = 'Sell bastoji for ' + this.amount + ' ' + this.currency;
        let okText = 'Confirm';
        let cancelText = 'Cancel';
        this.popupProvider
            .ionicConfirm(null, message, okText, cancelText)
            .then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.onGoingProcessProvider.set('sellingBastoji');
            this.glideraProvider.get2faCode(this.token, (err, tfa) => {
                if (err) {
                    this.onGoingProcessProvider.clear();
                    this.showError(err);
                    return;
                }
                this.ask2FaCode(tfa.mode, twoFaCode => {
                    if (tfa.mode != 'NONE' && __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](twoFaCode)) {
                        this.onGoingProcessProvider.clear();
                        this.showError('No code entered');
                        return;
                    }
                    let outputs = [];
                    let config = this.configProvider.get();
                    let configWallet = config.wallet;
                    let walletSettings = configWallet.settings;
                    this.walletProvider
                        .getAddress(this.wallet, false)
                        .then(refundAddress => {
                        if (!refundAddress) {
                            this.onGoingProcessProvider.clear();
                            this.showError('Could not create address');
                            return;
                        }
                        this.glideraProvider.getSellAddress(this.token, (err, sellAddress) => {
                            if (!sellAddress || err) {
                                this.onGoingProcessProvider.clear();
                                this.showError(err);
                                return;
                            }
                            let amount = parseInt((this.sellInfo.qty * 100000000).toFixed(0), 10);
                            let comment = 'Glidera transaction';
                            outputs.push({
                                toAddress: sellAddress,
                                amount,
                                message: comment
                            });
                            let txp = {
                                toAddress: sellAddress,
                                amount,
                                outputs,
                                message: comment,
                                payProUrl: null,
                                excludeUnconfirmedUtxos: configWallet.spendUnconfirmed
                                    ? false
                                    : true,
                                feeLevel: walletSettings.feeLevel || 'normal',
                                customData: {
                                    glideraToken: this.token
                                }
                            };
                            this.walletProvider
                                .createTx(this.wallet, txp)
                                .then(createdTxp => {
                                this.walletProvider
                                    .prepare(this.wallet)
                                    .then(password => {
                                    this.walletProvider
                                        .publishTx(this.wallet, createdTxp)
                                        .then(publishedTxp => {
                                        this.walletProvider
                                            .signTx(this.wallet, publishedTxp, password)
                                            .then(signedTxp => {
                                            let rawTx = signedTxp.raw;
                                            let data = {
                                                refundAddress,
                                                signedTransaction: rawTx,
                                                priceUuid: this.sellInfo.priceUuid,
                                                useCurrentPrice: this.sellInfo.priceUuid
                                                    ? false
                                                    : true,
                                                ip: null
                                            };
                                            this.glideraProvider.sell(this.token, twoFaCode, data, (err, data) => {
                                                this.onGoingProcessProvider.clear();
                                                if (err)
                                                    return this.showError(err);
                                                this.logger.info('Glidera Sell Info: ', JSON.stringify(data));
                                                this.openFinishModal();
                                            });
                                        })
                                            .catch(err => {
                                            this.onGoingProcessProvider.clear();
                                            this.showError(err);
                                            this.walletProvider
                                                .removeTx(this.wallet, publishedTxp)
                                                .catch(err => {
                                                // TODO in the original code use signedTxp on this function
                                                if (err)
                                                    this.logger.debug(err);
                                            });
                                        });
                                    })
                                        .catch(err => {
                                        this.onGoingProcessProvider.clear();
                                        this.showError(err);
                                    });
                                })
                                    .catch(err => {
                                    this.onGoingProcessProvider.clear();
                                    this.showError(err);
                                });
                            })
                                .catch(err => {
                                this.onGoingProcessProvider.clear();
                                this.showError(err);
                            });
                        });
                    });
                });
            });
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        let parsedAmount = this.txFormatProvider.parseAmount(this.coin, this.amount, this.currency);
        this.amount = parsedAmount.amount;
        this.currency = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        this.processPaymentInfo();
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Sell From');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishText = 'Funds sent to Glidera Account';
        let finishComment = 'The transaction is not yet confirmed, and will show as "Pending" in your Activity. The bastoji sale will be completed automatically once it is confirmed by Glidera';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_4__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__integrations_glidera_glidera__["a" /* GlideraPage */], null, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], SellGlideraPage.prototype, "slideButton", void 0);
SellGlideraPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-sell-glidera',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/sell-glidera/sell-glidera.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Glidera</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="sellInfo">\n    <ion-item>\n      <div class="selling-label">\n        <img class="selling-img" src="assets/img/icon-tx-sent-outline.svg">\n        <span>Selling</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n        <div class="alternative">\n          <span *ngIf="!isFiat">{{sellInfo.subtotal}} {{sellInfo.currency}}</span>\n          <span *ngIf="isFiat">{{sellInfo.qty}} BTJ</span> @ ${{sellInfo.price}} per BTJ\n        </div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div>From</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n      <ion-item-divider>\n        Transaction details\n      </ion-item-divider>\n      <ion-item>\n        <span>Expires</span>\n        <ion-note item-end>\n          {{sellInfo.expires | amCalendar}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Fees</span>\n        <ion-note item-end>\n          {{sellInfo.fees}} {{sellInfo.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Total to receive</span>\n        <ion-note item-end>\n          {{sellInfo.total}} {{sellInfo.currency}}\n        </ion-note>\n      </ion-item>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!wallet" buttonText="Slide to confirm" (slideDone)="sellConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="sellConfirm()" [disabled]="!wallet">Confirm sale</button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/sell-glidera/sell-glidera.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_10__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_glidera_glidera__["a" /* GlideraProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
], SellGlideraPage);

//# sourceMappingURL=sell-glidera.js.map

/***/ }),

/***/ 730:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BuyMercadoLibrePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__mercado_libre__ = __webpack_require__(352);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__ = __webpack_require__(179);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






// Pages


// Provider














let BuyMercadoLibrePage = class BuyMercadoLibrePage {
    constructor(mercadoLibreProvider, bwcErrorProvider, bwcProvider, configProvider, replaceParametersProvider, emailNotificationsProvider, events, externalLinkProvider, logger, modalCtrl, navCtrl, navParams, onGoingProcessProvider, popupProvider, profileProvider, txFormatProvider, walletProvider, translate, payproProvider, platformProvider) {
        this.mercadoLibreProvider = mercadoLibreProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.emailNotificationsProvider = emailNotificationsProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.modalCtrl = modalCtrl;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.payproProvider = payproProvider;
        this.platformProvider = platformProvider;
        this.showError = function (title, msg) {
            return new Promise(resolve => {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                title = title || this.translate.instant('Error');
                this.logger.error(msg);
                msg = msg && msg.errors ? msg.errors[0].message : msg;
                this.popupProvider.ionicAlert(title, msg).then(() => {
                    return resolve();
                });
            });
        };
        this.checkTransaction = __WEBPACK_IMPORTED_MODULE_3_lodash__["throttle"]((count, dataSrc) => {
            this.mercadoLibreProvider.createGiftCard(dataSrc, (err, giftCard) => {
                this.logger.debug('creating gift card ' + count);
                if (err) {
                    giftCard = giftCard || {};
                    giftCard['status'] = 'FAILURE';
                }
                if (giftCard &&
                    giftCard.cardStatus &&
                    (giftCard.cardStatus != 'active' &&
                        giftCard.cardStatus != 'inactive' &&
                        giftCard.cardStatus != 'expired')) {
                    giftCard = giftCard || {};
                    giftCard['status'] = 'FAILURE';
                }
                var now = __WEBPACK_IMPORTED_MODULE_4_moment__().unix() * 1000;
                var newData = giftCard;
                newData.invoiceId = dataSrc.invoiceId;
                newData.accessKey = dataSrc.accessKey;
                newData.invoiceUrl = dataSrc.invoiceUrl;
                newData.currency = dataSrc.currency;
                newData.amount = dataSrc.amount;
                newData.date = dataSrc.invoiceTime || now;
                newData.uuid = dataSrc.uuid;
                if (giftCard.status == 'PENDING' && count < 3) {
                    this.logger.debug('Waiting for payment confirmation');
                    this.mercadoLibreProvider.savePendingGiftCard(newData, null, () => {
                        this.logger.debug('Saving new gift card with status: ' + newData.status);
                    });
                    this.checkTransaction(count + 1, dataSrc);
                    return;
                }
                this.mercadoLibreProvider.savePendingGiftCard(newData, null, () => {
                    this.onGoingProcessProvider.clear();
                    this.logger.debug('Saved new gift card with status: ' + newData.status);
                    this.mlGiftCard = newData;
                    this.openFinishModal();
                });
            });
        }, 15000, {
            leading: true
        });
        this.FEE_TOO_HIGH_LIMIT_PER = 15;
        this.configWallet = this.configProvider.get().wallet;
        this.mlGiftCard = null;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad BuyMercadoLibrePage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.navCtrl.swipeBackEnabled = false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        if (this.amount > 2000 || this.amount < 50) {
            this.showErrorAndBack(null, this.translate.instant('Purchase amount must be a value between 50 and 2000'));
            return;
        }
        this.network = this.mercadoLibreProvider.getNetwork();
        this.wallets = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            hasFunds: true,
            m: 1
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.wallets)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets available'));
            return;
        }
        this.showWallets(); // Show wallet selector
    }
    checkFeeHigh(amount, fee) {
        let per = (fee / (amount + fee)) * 100;
        if (per > this.FEE_TOO_HIGH_LIMIT_PER) {
            const feeWarningModal = this.popupProvider.createMiniModal('fee-warning');
            feeWarningModal.present();
        }
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    _resetValues() {
        this.totalAmountStr = this.invoiceFee = this.networkFee = this.totalAmount = this.wallet = null;
        this.createdTx = this.message = this.invoiceId = null;
    }
    showErrorAndBack(title, msg) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    satToFiat(coin, sat) {
        return new Promise(resolve => {
            this.txFormatProvider
                .toFiat(coin, sat, this.currencyIsoCode)
                .then((value) => {
                return resolve(value);
            });
        });
    }
    setTotalAmount(wallet, amountSat, invoiceFeeSat, networkFeeSat) {
        this.satToFiat(wallet.coin, amountSat).then((a) => {
            this.amount = Number(a);
            this.satToFiat(wallet.coin, invoiceFeeSat).then((i) => {
                this.invoiceFee = Number(i);
                this.satToFiat(wallet.coin, networkFeeSat).then((n) => {
                    this.networkFee = Number(n);
                    this.totalAmount = this.amount + this.invoiceFee + this.networkFee;
                });
            });
        });
    }
    isCryptoCurrencySupported(wallet, invoice) {
        let COIN = wallet.coin.toUpperCase();
        if (!invoice['supportedTransactionCurrencies'][COIN])
            return false;
        return invoice['supportedTransactionCurrencies'][COIN].enabled;
    }
    createInvoice(data) {
        return new Promise((resolve, reject) => {
            this.mercadoLibreProvider.createBitPayInvoice(data, (err, dataInvoice) => {
                if (err) {
                    let err_title = this.translate.instant('Error creating the invoice');
                    let err_msg;
                    if (err && err.message && err.message.match(/suspended/i)) {
                        err_title = this.translate.instant('Service not available');
                        err_msg = this.translate.instant('Mercadolibre Gift Card Service is not available at this moment. Please try back later.');
                    }
                    else if (err && err.message) {
                        err_msg = err.message;
                    }
                    else {
                        err_msg = this.translate.instant('Could not access Gift Card Service');
                    }
                    return reject({
                        title: err_title,
                        message: err_msg
                    });
                }
                let accessKey = dataInvoice ? dataInvoice.accessKey : null;
                if (!accessKey) {
                    return reject({
                        message: this.translate.instant('No access key defined')
                    });
                }
                this.mercadoLibreProvider.getBitPayInvoice(dataInvoice.invoiceId, (err, invoice) => {
                    if (err) {
                        return reject({
                            message: this.translate.instant('Could not get the invoice')
                        });
                    }
                    return resolve({ invoice, accessKey });
                });
            });
        });
    }
    createTx(wallet, invoice, message) {
        let COIN = wallet.coin.toUpperCase();
        return new Promise((resolve, reject) => {
            let payProUrl = invoice && invoice.paymentCodes
                ? invoice.paymentCodes[COIN].BIP73
                : null;
            if (!payProUrl) {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                });
            }
            this.payproProvider
                .getPayProDetails(payProUrl, wallet.coin)
                .then(details => {
                let txp = {
                    amount: details.amount,
                    toAddress: details.toAddress,
                    outputs: [
                        {
                            toAddress: details.toAddress,
                            amount: details.amount,
                            message
                        }
                    ],
                    message,
                    customData: {
                        service: 'mercadolibre'
                    },
                    payProUrl,
                    excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                        ? false
                        : true
                };
                if (details.requiredFeeRate) {
                    txp.feePerKb = Math.ceil(details.requiredFeeRate * 1024);
                    this.logger.debug('Using merchant fee rate (for mercadolibre gc):' + txp.feePerKb);
                }
                else {
                    txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
                }
                txp['origToAddress'] = txp.toAddress;
                if (wallet.coin && wallet.coin == 'bch') {
                    // Use legacy address
                    txp.toAddress = this.bitcoreCash.Address(txp.toAddress).toString();
                    txp.outputs[0].toAddress = txp.toAddress;
                }
                this.walletProvider
                    .createTx(wallet, txp)
                    .then(ctxp => {
                    return resolve(ctxp);
                })
                    .catch(err => {
                    return reject({
                        title: this.translate.instant('Could not create transaction'),
                        message: this.bwcErrorProvider.msg(err)
                    });
                });
            })
                .catch(() => {
                return reject({
                    title: this.translate.instant('Error in Payment Protocol'),
                    message: this.translate.instant('Invalid URL')
                });
            });
        });
    }
    initialize(wallet) {
        let COIN = wallet.coin.toUpperCase();
        let email = this.emailNotificationsProvider.getEmailIfEnabled();
        let parsedAmount = this.txFormatProvider.parseAmount(wallet.coin, this.amount, this.currency);
        this.currencyIsoCode = parsedAmount.currency;
        this.amountUnitStr = parsedAmount.amountUnitStr;
        let dataSrc = {
            amount: parsedAmount.amount,
            currency: parsedAmount.currency,
            uuid: wallet.id,
            email,
            buyerSelectedTransactionCurrency: COIN
        };
        this.onGoingProcessProvider.set('loadingTxInfo');
        this.createInvoice(dataSrc)
            .then(data => {
            let invoice = data.invoice;
            let accessKey = data.accessKey;
            if (!this.isCryptoCurrencySupported(wallet, invoice)) {
                this.onGoingProcessProvider.clear();
                let msg = this.translate.instant('Purchases with this cryptocurrency is not enabled');
                this.showErrorAndBack(null, msg);
                return;
            }
            // Sometimes API does not return this element;
            invoice['minerFees'][COIN]['totalFee'] =
                invoice.minerFees[COIN].totalFee || 0;
            let invoiceFeeSat = invoice.minerFees[COIN].totalFee;
            this.message = this.replaceParametersProvider.replace(this.translate.instant('{{amountUnitStr}} Gift Card'), { amountUnitStr: this.amountUnitStr });
            this.createTx(wallet, invoice, this.message)
                .then(ctxp => {
                this.onGoingProcessProvider.clear();
                // Save in memory
                this.createdTx = ctxp;
                this.invoiceId = invoice.id;
                this.createdTx.giftData = {
                    currency: dataSrc.currency,
                    amount: dataSrc.amount,
                    uuid: dataSrc.uuid,
                    accessKey,
                    invoiceId: invoice.id,
                    invoiceUrl: invoice.url,
                    invoiceTime: invoice.invoiceTime
                };
                this.totalAmountStr = this.txFormatProvider.formatAmountStr(wallet.coin, ctxp.amount);
                // Warn: fee too high
                this.checkFeeHigh(Number(parsedAmount.amountSat), Number(invoiceFeeSat) + Number(ctxp.fee));
                this.setTotalAmount(wallet, parsedAmount.amountSat, invoiceFeeSat, ctxp.fee);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this._resetValues();
                this.showError(err.title, err.message);
                return;
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(err.title, err.message);
            return;
        });
    }
    buyConfirm() {
        if (!this.createdTx) {
            this.showError(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        var title = this.translate.instant('Confirm');
        this.popupProvider.ionicConfirm(title, this.message).then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.publishAndSign(this.wallet, this.createdTx)
                .then(() => {
                this.onGoingProcessProvider.set('Comprando Vale-Presente');
                this.checkTransaction(1, this.createdTx.giftData);
            })
                .catch(err => {
                this._resetValues();
                this.showError(this.translate.instant('Could not send transaction'), this.bwcErrorProvider.msg(err));
                return;
            });
        });
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        this.initialize(wallet);
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id, 'Buy from');
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    openFinishModal() {
        let finishComment;
        let cssClass;
        if (this.mlGiftCard.status == 'FAILURE') {
            finishComment = 'Sua compra no pde ser concluda';
            cssClass = 'danger';
        }
        if (this.mlGiftCard.status == 'PENDING') {
            finishComment = 'Sua compra foi adicionada  lista de pendentes';
            cssClass = 'warning';
        }
        if (this.mlGiftCard.status == 'SUCCESS' ||
            this.mlGiftCard.cardStatus == 'active') {
            finishComment = 'Vale-Presente gerado e pronto para usar';
        }
        let finishText = '';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText, finishComment, cssClass }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__mercado_libre__["a" /* MercadoLibrePage */], { invoiceId: this.invoiceId }, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], BuyMercadoLibrePage.prototype, "slideButton", void 0);
BuyMercadoLibrePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-buy-mercado-libre',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/buy-mercado-libre/buy-mercado-libre.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Buy Gift Card\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <div class="mercado-libre-title">\n        <img src="assets/img/mercado-libre/icon-ml.svg">\n        <span>Vale-Presente do Mercado Livre Brasil</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountUnitStr}}</div>\n      </div>\n    </ion-item>\n\n    <ion-item-group class="info">\n      <button ion-item detail-none (click)="showWallets()" class="wallets-list">\n        <div translate>From</div>\n        <div class="wallet">\n          <ion-icon item-start>\n            <img *ngIf="network == \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="network != \'testnet\'" [ngStyle]="{\'background-color\': wallet && wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <div>{{wallet ? wallet.name : \'...\'}}</div>\n          <div class="last-item" item-end>\n            <button ion-button clear color="grey" icon-only>\n              <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n              <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n            </button>\n          </div>\n        </div>\n      </button>\n\n      <div *ngIf="totalAmountStr">\n        <ion-item-divider>\n          <span translate>Details</span>\n        </ion-item-divider>\n        <ion-item>\n          <span translate>Gift Card</span>\n          <ion-note item-end>\n            {{amount | currency:\'$ \':2}}\n            <span *ngIf="amount"> {{currencyIsoCode}}</span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Network cost</span>\n          <ion-note item-end>\n            <span>{{invoiceFee | currency:\'$ \':2}}\n              <span *ngIf="invoiceFee"> {{currencyIsoCode}}</span>\n            </span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Miner fee</span>\n          <ion-note item-end>\n            <span>{{networkFee | currency:\'$ \':2}}\n              <span *ngIf="networkFee"> {{currencyIsoCode}}</span>\n            </span>\n          </ion-note>\n        </ion-item>\n        <ion-item>\n          <span translate>Total</span>\n          <ion-note item-end>\n            <span *ngIf="totalAmount">{{totalAmount | currency:\'$ \':2}} {{currencyIsoCode}}</span>\n            <span *ngIf="totalAmountStr">({{totalAmountStr}})</span>\n          </ion-note>\n        </ion-item>\n      </div>\n    </ion-item-group>\n  </ion-list>\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!(wallet && totalAmountStr)" buttonText="Deslize para comprar" (slideDone)="buyConfirm()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button block class="button-footer" (click)="buyConfirm()" [disabled]="!(wallet && totalAmountStr)">\n      Confirmar a compra\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/buy-mercado-libre/buy-mercado-libre.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_13__providers_mercado_libre_mercado_libre__["a" /* MercadoLibreProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_12__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_21__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_15__providers_paypro_paypro__["a" /* PayproProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_platform_platform__["a" /* PlatformProvider */]])
], BuyMercadoLibrePage);

//# sourceMappingURL=buy-mercado-libre.js.map

/***/ }),

/***/ 731:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftConfirmPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__finish_finish__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__shapeshift__ = __webpack_require__(354);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__providers_shapeshift_shapeshift__ = __webpack_require__(144);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






// Pages


// Providers













let ShapeshiftConfirmPage = class ShapeshiftConfirmPage {
    constructor(bwcProvider, bwcErrorProvider, configProvider, replaceParametersProvider, externalLinkProvider, onGoingProcessProvider, logger, navCtrl, navParams, platformProvider, popupProvider, profileProvider, shapeshiftProvider, txFormatProvider, walletProvider, modalCtrl, translate, feeProvider) {
        this.bwcProvider = bwcProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.configProvider = configProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.txFormatProvider = txFormatProvider;
        this.walletProvider = walletProvider;
        this.modalCtrl = modalCtrl;
        this.translate = translate;
        this.feeProvider = feeProvider;
        this.configWallet = this.configProvider.get().wallet;
        this.currencyIsoCode = 'USD'; // Only USD
        this.isCordova = this.platformProvider.isCordova;
        this.bitcore = this.bwcProvider.getBitcore();
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.useSendMax = this.navParams.data.useSendMax ? true : false;
        this.amount = this.navParams.data.amount;
        this.currency = this.navParams.data.currency;
        this.fromWalletId = this.navParams.data.id;
        this.toWalletId = this.navParams.data.toWalletId;
        this.network = this.shapeshiftProvider.getNetwork();
        this.fromWallet = this.profileProvider.getWallet(this.fromWalletId);
        this.toWallet = this.profileProvider.getWallet(this.toWalletId);
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.fromWallet) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.toWallet)) {
            this.showErrorAndBack(null, this.translate.instant('No wallet found'));
            return;
        }
        this.shapeshiftProvider.getLimit(this.getCoinPair(), (_, lim) => {
            let min = Number(lim.min);
            let max = Number(lim.limit);
            if (this.useSendMax) {
                this.getMaxInfo(max)
                    .then(() => {
                    this.createShift();
                })
                    .catch(err => {
                    this.logger.error(err);
                    this.showErrorAndBack(null, err);
                });
            }
            else {
                let amountNumber = Number(this.amount);
                if (amountNumber < min) {
                    let message = this.replaceParametersProvider.replace(this.translate.instant('Minimum amount required is {{min}}'), { min });
                    this.showErrorAndBack(null, message);
                    return;
                }
                if (amountNumber > max) {
                    let message = this.replaceParametersProvider.replace(this.translate.instant('Maximum amount allowed is {{max}}'), { max });
                    this.showErrorAndBack(null, message);
                    return;
                }
                this.createShift();
            }
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ShapeshiftConfirmPage');
    }
    ionViewWillLeave() {
        this.navCtrl.swipeBackEnabled = true;
    }
    ionViewWillEnter() {
        this.navCtrl.swipeBackEnabled = false;
    }
    getMaxInfo(max) {
        return new Promise((resolve, reject) => {
            this.getSendMaxInfo()
                .then(sendMaxInfo => {
                if (sendMaxInfo) {
                    this.logger.debug('Send max info', sendMaxInfo);
                    if (sendMaxInfo.amount == 0) {
                        let msg = this.translate.instant('Not enough funds for fee');
                        return reject(msg);
                    }
                    this.sendMaxInfo = sendMaxInfo;
                    this.amount = sendMaxInfo.amount;
                    let maxSat = parseInt((max * this.configWallet.settings.unitToSatoshi).toFixed(0), 10);
                    if (this.amount > maxSat) {
                        this.popupProvider
                            .ionicAlert(this.translate.instant('ShapeShift max limit reached'), 'Maximum amount allowed is ' + max)
                            .then(() => {
                            this.amount = max;
                            this.useSendMax = false;
                            return resolve();
                        });
                    }
                    else {
                        this.showSendMaxWarning().then(() => {
                            return resolve();
                        });
                    }
                }
            })
                .catch(err => {
                this.logger.error('ShapeShift: could not get SendMax info', err);
                let msg = this.translate.instant('Error getting SendMax information');
                return reject(msg);
            });
        });
    }
    getSendMaxInfo() {
        return new Promise((resolve, reject) => {
            this.feeProvider
                .getFeeRate(this.fromWallet.coin, this.network, this.configWallet.settings.feeLevel || 'normal')
                .then(feeRate => {
                this.onGoingProcessProvider.set('retrievingInputs');
                this.walletProvider
                    .getSendMaxInfo(this.fromWallet, {
                    feePerKb: feeRate,
                    excludeUnconfirmedUtxos: !this.configWallet.spendUnconfirmed,
                    returnInputs: true
                })
                    .then(res => {
                    this.onGoingProcessProvider.clear();
                    return resolve(res);
                })
                    .catch(err => {
                    this.onGoingProcessProvider.clear();
                    return reject(err);
                });
            });
        });
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    showErrorAndBack(title, msg) {
        if (this.isCordova)
            this.slideButton.isConfirmed(false);
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    publishAndSign(wallet, txp) {
        return new Promise((resolve, reject) => {
            if (!wallet.canSign() && !wallet.isPrivKeyExternal()) {
                let err = this.translate.instant('No signing proposal: No private key');
                return reject(err);
            }
            this.walletProvider
                .publishAndSign(wallet, txp)
                .then(txp => {
                this.onGoingProcessProvider.clear();
                return resolve(txp);
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                return reject(err);
            });
        });
    }
    satToFiat(coin, sat, isoCode) {
        return new Promise(resolve => {
            this.txFormatProvider.toFiat(coin, sat, isoCode).then(value => {
                return resolve(value);
            });
        });
    }
    setFiatTotalAmount(amountSat, feeSat, withdrawalSat) {
        this.satToFiat(this.toWallet.coin, withdrawalSat, this.currencyIsoCode).then(w => {
            this.fiatWithdrawal = Number(w);
            this.satToFiat(this.fromWallet.coin, amountSat, this.currencyIsoCode).then(a => {
                this.fiatAmount = Number(a);
                this.satToFiat(this.fromWallet.coin, feeSat, this.currencyIsoCode).then(i => {
                    this.fiatFee = Number(i);
                    this.fiatTotalAmount = this.fiatAmount + this.fiatFee;
                });
            });
        });
    }
    saveShapeshiftData() {
        let address = this.shapeInfo.deposit;
        let withdrawal = this.shapeInfo.withdrawal;
        let now = __WEBPACK_IMPORTED_MODULE_4_moment__().unix() * 1000;
        this.shapeshiftProvider.getStatus(address, (_, st) => {
            let newData = {
                address,
                withdrawal,
                date: now,
                amount: this.amountStr,
                rate: this.rateUnit +
                    ' ' +
                    this.toWallet.coin.toUpperCase() +
                    ' per ' +
                    this.fromWallet.coin.toUpperCase(),
                title: this.fromWallet.coin.toUpperCase() +
                    ' to ' +
                    this.toWallet.coin.toUpperCase(),
                // From ShapeShift
                status: st.status,
                transaction: st.transaction || null,
                incomingCoin: st.incomingCoin || null,
                incomingType: st.incomingType || null,
                outgoingCoin: st.outgoingCoin || null,
                outgoingType: st.outgoingType || null // Coin type of withdrawal
            };
            this.shapeshiftProvider.saveShapeshift(newData, null, () => {
                this.logger.debug('Saved shift with status: ' + newData.status);
                this.openFinishModal();
            });
        });
    }
    createTx(wallet, toAddress) {
        return new Promise((resolve, reject) => {
            let amount = this.useSendMax
                ? this.amount
                : parseInt((this.amount * this.configWallet.settings.unitToSatoshi).toFixed(0), 10);
            this.message =
                this.fromWallet.coin.toUpperCase() +
                    ' to ' +
                    this.toWallet.coin.toUpperCase();
            let outputs = [];
            outputs.push({
                toAddress,
                amount,
                message: this.message
            });
            let txp = {
                toAddress,
                amount,
                outputs,
                message: this.message,
                excludeUnconfirmedUtxos: this.configWallet.spendUnconfirmed
                    ? false
                    : true,
                customData: {
                    shapeShift: toAddress,
                    service: 'shapeshift'
                }
            };
            if (this.sendMaxInfo) {
                txp.inputs = this.sendMaxInfo.inputs;
                txp.fee = this.sendMaxInfo.fee;
            }
            else {
                txp.feeLevel = this.configWallet.settings.feeLevel || 'normal';
            }
            this.walletProvider
                .createTx(wallet, txp)
                .then(ctxp => {
                return resolve(ctxp);
            })
                .catch(err => {
                return reject({
                    title: this.translate.instant('Could not create transaction'),
                    message: this.bwcErrorProvider.msg(err)
                });
            });
        });
    }
    showSendMaxWarning() {
        return new Promise(resolve => {
            let fee = this.sendMaxInfo.fee / 1e8;
            let msg = this.replaceParametersProvider.replace(this.translate.instant('{{fee}} {{coin}} will be deducted for bastoji networking fees.'), { fee, coin: this.fromWallet.coin.toUpperCase() });
            let warningMsg = this.verifyExcludedUtxos();
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](warningMsg))
                msg += '\n' + warningMsg;
            this.popupProvider.ionicAlert(null, msg).then(() => {
                resolve();
            });
        });
    }
    verifyExcludedUtxos() {
        let warningMsg = [];
        if (this.sendMaxInfo.utxosBelowFee > 0) {
            let amountBelowFeeStr = this.sendMaxInfo.amountBelowFee / 1e8;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{fee}} {{coin}} were excluded. These funds come from UTXOs smaller than the network fee provided.'), { fee: amountBelowFeeStr, coin: this.fromWallet.coin.toUpperCase() });
            warningMsg.push(message);
        }
        if (this.sendMaxInfo.utxosAboveMaxSize > 0) {
            let amountAboveMaxSizeStr = this.sendMaxInfo.amountAboveMaxSize / 1e8;
            let message = this.replaceParametersProvider.replace(this.translate.instant('A total of {{fee}} {{coin}} were excluded. The maximum size allowed for a transaction was exceeded.'), { fee: amountAboveMaxSizeStr, coin: this.fromWallet.coin.toUpperCase() });
            warningMsg.push(message);
        }
        return warningMsg.join('\n');
    }
    getLegacyAddressFormat(addr, coin) {
        if (coin == 'btc')
            return addr;
        let a = this.bitcoreCash.Address(addr).toObject();
        return this.bitcore.Address.fromObject(a).toString();
    }
    getNewAddressFormat(addr, coin) {
        if (coin == 'btc')
            return addr;
        let a = this.bitcore.Address(addr).toObject();
        return this.bitcoreCash.Address.fromObject(a).toString();
    }
    getCoinPair() {
        return this.fromWallet.coin + '_' + this.toWallet.coin;
    }
    createShift() {
        this.onGoingProcessProvider.set('connectingShapeshift');
        this.walletProvider
            .getAddress(this.toWallet, false)
            .then((withdrawalAddress) => {
            withdrawalAddress = this.getLegacyAddressFormat(withdrawalAddress, this.toWallet.coin);
            this.walletProvider
                .getAddress(this.fromWallet, false)
                .then((returnAddress) => {
                returnAddress = this.getLegacyAddressFormat(returnAddress, this.fromWallet.coin);
                let data = {
                    withdrawal: withdrawalAddress,
                    pair: this.getCoinPair(),
                    returnAddress
                };
                this.shapeshiftProvider.shift(data, (err, shapeData) => {
                    if (err || shapeData.error) {
                        this.onGoingProcessProvider.clear();
                        this.showErrorAndBack(null, err || shapeData.error);
                        return;
                    }
                    let toAddress = this.getNewAddressFormat(shapeData.deposit, this.fromWallet.coin);
                    this.createTx(this.fromWallet, toAddress)
                        .then(ctxp => {
                        // Save in memory
                        this.createdTx = ctxp;
                        this.shapeInfo = shapeData;
                        this.shapeshiftProvider.getRate(this.getCoinPair(), (_, r) => {
                            this.onGoingProcessProvider.clear();
                            this.rateUnit = r.rate;
                            let amountUnit = this.txFormatProvider.satToUnit(ctxp.amount);
                            let withdrawalSat = Number((this.rateUnit * amountUnit * 100000000).toFixed());
                            // Fee rate
                            let per = (ctxp.fee / (ctxp.amount + ctxp.fee)) * 100;
                            this.feeRatePerStr = per.toFixed(2) + '%';
                            // Amount + Unit
                            this.amountStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.amount);
                            this.withdrawalStr = this.txFormatProvider.formatAmountStr(this.toWallet.coin, withdrawalSat);
                            this.feeStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.fee);
                            this.totalAmountStr = this.txFormatProvider.formatAmountStr(this.fromWallet.coin, ctxp.amount + ctxp.fee);
                            // Convert to fiat
                            this.setFiatTotalAmount(ctxp.amount, ctxp.fee, withdrawalSat);
                        });
                    })
                        .catch(err => {
                        this.onGoingProcessProvider.clear();
                        this.showErrorAndBack(err.title, err.message);
                        return;
                    });
                });
            })
                .catch(() => {
                this.onGoingProcessProvider.clear();
                this.showErrorAndBack(null, 'Could not get address');
                return;
            });
        })
            .catch(() => {
            this.onGoingProcessProvider.clear();
            this.showErrorAndBack(null, 'Could not get address');
            return;
        });
    }
    confirmTx() {
        if (!this.createdTx) {
            this.showErrorAndBack(null, this.translate.instant('Transaction has not been created'));
            return;
        }
        let fromCoin = this.fromWallet.coin.toUpperCase();
        let toCoin = this.toWallet.coin.toUpperCase();
        let title = this.replaceParametersProvider.replace(this.translate.instant('Confirm to shift {{fromCoin}} to {{toCoin}}'), { fromCoin, toCoin });
        let okText = this.translate.instant('OK');
        let cancelText = this.translate.instant('Cancel');
        this.popupProvider.ionicConfirm(title, '', okText, cancelText).then(ok => {
            if (!ok) {
                if (this.isCordova)
                    this.slideButton.isConfirmed(false);
                return;
            }
            this.publishAndSign(this.fromWallet, this.createdTx)
                .then(txSent => {
                this.txSent = txSent;
                this.saveShapeshiftData();
            })
                .catch(err => {
                this.logger.error(this.bwcErrorProvider.msg(err));
                this.showErrorAndBack(null, this.translate.instant('Could not send transaction'));
                return;
            });
        });
    }
    openFinishModal() {
        let finishText = 'Transaction Sent';
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_6__finish_finish__["a" /* FinishModalPage */], { finishText }, { showBackdrop: true, enableBackdropDismiss: false });
        modal.present();
        modal.onDidDismiss(() => __awaiter(this, void 0, void 0, function* () {
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__shapeshift__["a" /* ShapeshiftPage */], null, { animate: false });
        }));
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])('slideButton'),
    __metadata("design:type", Object)
], ShapeshiftConfirmPage.prototype, "slideButton", void 0);
ShapeshiftConfirmPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-shapeshift-confirm',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-confirm/shapeshift-confirm.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Confirm\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list>\n    <ion-item>\n      <div class="sending-label">\n        <img src="assets/img/shapeshift/icon-shapeshift.svg" alt="shapeshift">\n        <span>Shift</span>\n      </div>\n      <div class="amount-label">\n        <div class="amount">{{amountStr}}</div>\n        <div class="alternative" *ngIf="fiatAmount">{{fiatAmount | currency}} {{currencyIsoCode}}</div>\n      </div>\n    </ion-item>\n\n    <div class="info">\n      <ion-item>\n        <span translate>From</span>\n        <img item-end *ngIf="fromWallet.coin == \'btc\'" src="assets/img/icon-bastoji.svg" width="18">\n        <img item-end *ngIf="fromWallet.coin == \'bch\'" src="assets/img/bastoji-cash-logo.svg" width="22">\n      </ion-item>\n      <ion-item class="wallet-selector">\n        <img src="assets/img/icon-wallet.svg" class="icon-wallet" [ngStyle]="{\'background-color\': fromWallet.color}" />\n        <div class="wallet-balance">\n          <span>\n            {{fromWallet ? fromWallet.name : \'...\'}}\n          </span>\n        </div>\n      </ion-item>\n\n      <ion-item>\n        <span translate>To</span>\n        <img item-end *ngIf="toWallet.coin == \'btc\'" src="assets/img/icon-bastoji.svg" width="18">\n        <img item-end *ngIf="toWallet.coin == \'bch\'" src="assets/img/bastoji-cash-logo.svg" width="22">\n      </ion-item>\n      <ion-item class="wallet-selector">\n        <img src="assets/img/icon-wallet.svg" class="icon-wallet" [ngStyle]="{\'background-color\': toWallet.color}" />\n        <div class="wallet-balance">\n          <span>\n            {{toWallet ? toWallet.name : \'...\'}}\n          </span>\n        </div>\n      </ion-item>\n    </div>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item *ngIf="feeRatePerStr">\n      {{\'Fee\'|translate}}\n      <ion-note item-end>\n        <span>\n          {{feeStr}} (\n          <span *ngIf="fiatFee && fiatFee > 0">{{fiatFee | currency}} {{currencyIsoCode}}, </span>{{feeRatePerStr}} )\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item *ngIf="fiatTotalAmount">\n      {{\'Total\'|translate}}\n      <ion-note item-end>\n        <span>\n          {{totalAmountStr}} ( {{fiatTotalAmount | currency}} {{currencyIsoCode}} )\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider class="item-description" *ngIf="withdrawalStr" no-lines>\n      <span translate>\n        A total of {{amountStr}} ({{fiatAmount | currency}} {{currencyIsoCode}}) will be exchanged for {{withdrawalStr}} ({{fiatWithdrawal | currency}} {{currencyIsoCode}}). Would you like to proceed?\n      </span>\n    </ion-item-divider>\n  </ion-list>\n\n</ion-content>\n\n<ion-footer>\n  <page-slide-to-accept #slideButton *ngIf="isCordova" [disabled]="!fromWallet || !totalAmountStr || !toWallet" buttonText="{{\'Slide to confirm\' | translate}}" (slideDone)="confirmTx()"></page-slide-to-accept>\n  <ion-toolbar *ngIf="!isCordova">\n    <button ion-button full class="button-footer" (click)="confirmTx()" [disabled]="!fromWallet || !totalAmountStr || !toWallet">\n      {{\'Click to confirm\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-confirm/shapeshift-confirm.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_17__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_14__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_16__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_18__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_19__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_20__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_12__providers_fee_fee__["a" /* FeeProvider */]])
], ShapeshiftConfirmPage);

//# sourceMappingURL=shapeshift-confirm.js.map

/***/ }),

/***/ 732:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_shapeshift_shapeshift__ = __webpack_require__(144);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers



let ShapeshiftDetailsPage = class ShapeshiftDetailsPage {
    constructor(configProvider, externalLinkProvider, navParams, shapeshiftProvider, viewCtrl, logger) {
        this.configProvider = configProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.shapeshiftProvider = shapeshiftProvider;
        this.viewCtrl = viewCtrl;
        this.logger = logger;
        this.defaults = this.configProvider.getDefaults();
        this.ssData = this.navParams.data.ssData;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ShapeshiftDetailsPage');
    }
    remove() {
        this.shapeshiftProvider.saveShapeshift(this.ssData, {
            remove: true
        }, () => {
            this.close();
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openTransaction(id) {
        var url;
        if (this.ssData.outgoingType.toUpperCase() == 'BTJ') {
            url = 'https://' + this.defaults.blockExplorerUrl.btc + '/tx/' + id;
        }
        else if (this.ssData.outgoingType.toUpperCase() == 'BCH') {
            url = 'https://' + this.defaults.blockExplorerUrl.bch + '/tx/' + id;
        }
        else {
            return;
        }
        this.externalLinkProvider.open(url);
    }
};
ShapeshiftDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-shapeshift-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-details/shapeshift-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      {{\'Details\' | translate}}\n    </ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="header-modal">\n    <div class="title-modal">\n      <img src="assets/img/shapeshift/icon-shapeshift.svg" alt="ShapeShift" width="50"> {{ssData.title}}\n    </div>\n\n    <div class="subtitle-modal">\n      {{ssData.amount}}\n    </div>\n\n    <div class="status-modal">\n      <span class="assertive" *ngIf="ssData.status == \'failed\'" translate>Failed</span>\n      <span class="balanced" *ngIf="ssData.status == \'complete\'" translate>Completed</span>\n      <span class="dark" *ngIf="ssData.status == \'received\'" translate>Pending</span>\n      <span class="text-gray" *ngIf="ssData.status == \'no_deposits\'" translate>Pending</span>\n    </div>\n  </div>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      {{\'Rate\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!ssData.rate">...</span>\n        <span *ngIf="ssData.rate">\n          {{ ssData.rate }}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Created\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!ssData.date">...</span>\n        <span *ngIf="ssData.date">\n          {{ ssData.date | amDateFormat:\'MMM D, YYYY\'}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider>{{\'Deposit\' | translate}}</ion-item-divider>\n\n    <ion-item>\n      {{\'Address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!ssData.address">...</span>\n          <span *ngIf="ssData.address" copy-to-clipboard="{{ssData.address}}">\n            {{ ssData.address }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="ssData.incomingCoin">\n      {{\'Amount\' | translate}}\n      <ion-note item-end>\n        {{ssData.incomingCoin}} {{ssData.incomingType}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider>{{\'Withdraw\' | translate}}</ion-item-divider>\n\n    <ion-item>\n      {{\'Address\' | translate}}\n      <div padding-top>\n        <ion-note text-wrap>\n          <span *ngIf="!ssData.withdrawal">...</span>\n          <span *ngIf="ssData.withdrawal" copy-to-clipboard="{{ssData.withdrawal}}">\n            {{ ssData.withdrawal }}\n          </span>\n        </ion-note>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="ssData.outgoingCoin">\n      {{\'Amount\' | translate}}\n      <ion-note item-end>\n        {{ssData.outgoingCoin}} {{ssData.outgoingType}}\n      </ion-note>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <button ion-item detail-none *ngIf="ssData.transaction" (click)="openTransaction(ssData.transaction)">\n      {{\'See transaction\' | translate}}\n    </button>\n    <button class="assertive" ion-item detail-none (click)="remove()">\n      {{\'Remove\' | translate}}\n    </button>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-details/shapeshift-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], ShapeshiftDetailsPage);

//# sourceMappingURL=shapeshift-details.js.map

/***/ }),

/***/ 733:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftShiftPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_shapeshift_shapeshift__ = __webpack_require__(144);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Pages

// Providers




let ShapeshiftShiftPage = class ShapeshiftShiftPage {
    constructor(events, externalLinkProvider, logger, navCtrl, popupProvider, profileProvider, shapeshiftProvider, translate) {
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.profileProvider = profileProvider;
        this.shapeshiftProvider = shapeshiftProvider;
        this.translate = translate;
        this.walletsBtc = [];
        this.walletsBch = [];
        this.toWallets = [];
        this.fromWallets = [];
        this.fromWalletSelectorTitle = 'From';
        this.toWalletSelectorTitle = 'To';
        this.termsAccepted = false;
        this.network = this.shapeshiftProvider.getNetwork();
        this.walletsBtc = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: 'btc'
        });
        this.walletsBch = this.profileProvider.getWallets({
            onlyComplete: true,
            network: this.network,
            coin: 'bch'
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.walletsBtc) || __WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.walletsBch)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets available to use ShapeShift'));
            return;
        }
        this.fromWallets = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.walletsBtc.concat(this.walletsBch), w => {
            // Available cached funds
            if (!w.cachedBalance)
                return null;
            let hasCachedFunds = w.cachedBalance.match(/0\.00 /gi) ? false : true;
            return hasCachedFunds;
        });
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.fromWallets)) {
            this.showErrorAndBack(null, this.translate.instant('No wallets with funds'));
            return;
        }
        this.onFromWalletSelect(this.fromWallets[0]);
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad ShapeshiftShiftPage');
    }
    ionViewDidEnter() {
        this.termsAccepted = false;
    }
    openTerms() {
        let url = 'https://info.shapeshift.io/sites/default/files/ShapeShift_Terms_Conditions%20v1.1.pdf';
        this.externalLinkProvider.open(url);
    }
    showErrorAndBack(title, msg) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showToWallets() {
        this.toWallets =
            this.fromWallet.coin == 'btc' ? this.walletsBch : this.walletsBtc;
        this.onToWalletSelect(this.toWallets[0]);
        let pair = this.fromWallet.coin + '_' + this.toWallet.coin;
        this.shapeshiftProvider.getRate(pair, (_, rate) => {
            this.rate = rate;
            this.shapeshiftProvider.getMarketInfo(pair, (_, limit) => {
                this.limit = limit;
                if (this.limit['rate'] == 0 || this.rate['rate'] == 0) {
                    let msg = this.translate.instant('ShapeShift is not available at this moment. Please, try again later.');
                    this.popupProvider.ionicAlert(null, msg).then(() => {
                        this.navCtrl.pop();
                    });
                    return;
                }
            });
        });
    }
    onFromWalletSelect(wallet) {
        this.fromWallet = wallet;
        this.showToWallets();
    }
    onToWalletSelect(wallet) {
        this.toWallet = wallet;
    }
    setAmount() {
        if (!this.termsAccepted) {
            return;
        }
        if (this.toWallet.needsBackup) {
            let title = this.translate.instant('Needs backup');
            let msg = this.translate.instant('The destination wallet is not backed up. Please, complete the backup process before continue.');
            this.popupProvider.ionicAlert(title, msg);
            return;
        }
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__send_amount_amount__["a" /* AmountPage */], {
            nextPage: 'ShapeshiftConfirmPage',
            fixedUnit: true,
            coin: this.fromWallet.coin,
            id: this.fromWallet.id,
            toWalletId: this.toWallet.id,
            shiftMax: this.limit.limit + ' ' + this.fromWallet.coin.toUpperCase(),
            shiftMin: this.limit.minimum + ' ' + this.fromWallet.coin.toUpperCase()
        });
    }
    showWallets(selector) {
        let walletsForActionSheet = [];
        let selectedWalletId;
        let title = selector == 'from'
            ? this.fromWalletSelectorTitle
            : this.toWalletSelectorTitle;
        if (selector == 'from') {
            walletsForActionSheet = this.fromWallets;
            selectedWalletId = this.fromWallet.id;
        }
        else if (selector == 'to') {
            walletsForActionSheet = this.toWallets;
            selectedWalletId = this.toWallet.id;
        }
        this.events.publish('showWalletsSelectorEvent', walletsForActionSheet, selectedWalletId, title);
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet, selector);
            this.events.unsubscribe('selectWalletEvent');
        });
    }
    onWalletSelect(wallet, selector) {
        if (selector == 'from') {
            this.onFromWalletSelect(wallet);
        }
        else if (selector == 'to') {
            this.onToWalletSelect(wallet);
        }
    }
};
ShapeshiftShiftPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-shapeshift-shift',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-shift/shapeshift-shift.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Shift</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="fromWallets.length > 0 && toWallets.length > 0">\n    <div *ngIf="fromWallets.length > 0">\n      <ion-item>\n        <span translate>From</span>\n        <img item-end *ngIf="fromWallet.coin == \'btc\'" src="assets/img/icon-bastoji.svg" width="18">\n        <img item-end *ngIf="fromWallet.coin == \'bch\'" src="assets/img/bastoji-cash-logo.svg" width="22">\n      </ion-item>\n      <button ion-item class="wallet-selector" (click)="showWallets(\'from\')">\n        <img *ngIf="fromWallet.network != \'testnet\'" src="assets/img/icon-wallet.svg" [ngStyle]="{\'background-color\': fromWallet.color}" class="icon-wallet" />\n        <div class="wallet-balance">\n          <span>\n            {{fromWallet.name || fromWallet.id}}\n          </span>\n          <p>\n            <span *ngIf="!fromWallet.isComplete()" class="wallet-warning" translate>\n              Incomplete\n            </span>\n            <span *ngIf="fromWallet.isComplete()">\n              <span *ngIf="!fromWallet.balanceHidden && !fromWallet.scanning"> {{fromWallet.status.totalBalanceStr ? fromWallet.status.totalBalanceStr : ( fromWallet.cachedBalance ? fromWallet.cachedBalance + (fromWallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( fromWallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\' ) }} </span>\n              <span *ngIf="fromWallet.scanning">\n                <span translate>Scanning funds</span>...\n              </span>\n\n              <span *ngIf="fromWallet.balanceHidden && !fromWallet.scanning" translate>[Balance Hidden]</span>\n              <span *ngIf="fromWallet.n > 1">\n                {{fromWallet.m}}-of-{{fromWallet.n}}\n              </span>\n              <ion-icon *ngIf="!fromWallet.balanceHidden && (fromWallet.status.totalBalanceSat != fromWallet.status.spendableAmount)" name="ios-timer-outline"></ion-icon>\n              <span class="wallet-warning" *ngIf="fromWallet.error">{{fromWallet.error}}</span>\n            </span>\n            &nbsp;\n          </p>\n        </div>\n      </button>\n    </div>\n    <div *ngIf="toWallets.length > 0">\n      <ion-item>\n        <span translate>To</span>\n        <img item-end *ngIf="toWallet.coin == \'btc\'" src="assets/img/icon-bastoji.svg" width="18">\n        <img item-end *ngIf="toWallet.coin == \'bch\'" src="assets/img/bastoji-cash-logo.svg" width="22">\n      </ion-item>\n      <button ion-item class="wallet-selector" (click)="showWallets(\'to\')">\n        <img *ngIf="toWallet.network != \'testnet\'" src="assets/img/icon-wallet.svg" class="icon-wallet" [ngStyle]="{\'background-color\': toWallet.color}" />\n        <div class="wallet-balance">\n          <span>\n            {{toWallet.name || toWallet.id}}\n          </span>\n          <p>\n            <span *ngIf="!toWallet.isComplete()" class="wallet-warning" translate>\n              Incomplete\n            </span>\n            <span class="wallet-warning" *ngIf="toWallet.isComplete() && toWallet.needsBackup" translate>\n              Needs backup\n            </span>\n            <span *ngIf="toWallet.isComplete() && !toWallet.needsBackup">\n              <span *ngIf="!toWallet.balanceHidden && !toWallet.scanning"> {{toWallet.status.totalBalanceStr ? toWallet.status.totalBalanceStr : ( toWallet.cachedBalance ? toWallet.cachedBalance + (toWallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( toWallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\' ) }} </span>\n              <span *ngIf="toWallet.scanning">\n                <span translate>Scanning funds</span>...\n              </span>\n\n              <span *ngIf="toWallet.balanceHidden && !toWallet.scanning" translate>[Balance Hidden]</span>\n              <span class="tab-home__wallet__multisig-number" *ngIf="toWallet.n > 1">\n                {{toWallet.m}}-of-{{toWallet.n}}\n              </span>\n              <ion-icon *ngIf="!fromWallet.balanceHidden && (fromWallet.status.totalBalanceSat != fromWallet.status.spendableAmount)" name="ios-timer-outline"></ion-icon>\n              <span class="wallet-warning" *ngIf="toWallet.error">{{toWallet.error}}</span>\n            </span>\n            &nbsp;\n          </p>\n        </div>\n      </button>\n    </div>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      {{\'Rate\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!rate">...</span>\n        <span *ngIf="rate">\n          {{rate.rate}} {{toWallet.coin | uppercase}} per {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Deposit Min\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.minimum}} {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Deposit Max\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.limit}} {{fromWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n\n    <ion-item>\n      {{\'Miner fee\' | translate}}\n      <ion-note item-end>\n        <span *ngIf="!limit">...</span>\n        <span *ngIf="limit">\n          {{limit.minerFee}} {{toWallet.coin | uppercase}}\n        </span>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <div *ngIf="fromWallets.length > 0 && toWallets.length > 0" class="agree-to-terms">\n    <ion-item>\n      <ion-checkbox class="check" [(ngModel)]="termsAccepted"></ion-checkbox>\n    </ion-item>\n    <div class="terms">\n      <p>\n        <span translate>I agree to the Terms and certify that I am the beneficial owner of the input assets and the destination address.</span>\n        <a (click)="openTerms()" translate>Click to open Terms</a>.\n      </p>\n    </div>\n  </div>\n\n</ion-content>\n\n<ion-footer>\n  <ion-toolbar *ngIf="fromWallets.length > 0 && toWallets.length > 0">\n    <button ion-button full class="button-footer" no-low-fee type="button" [disabled]="!fromWallet || !toWallet || !termsAccepted" (click)="setAmount()">\n      {{\'Continue\' | translate}}\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-shift/shapeshift-shift.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_shapeshift_shapeshift__["a" /* ShapeshiftProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], ShapeshiftShiftPage);

//# sourceMappingURL=shapeshift-shift.js.map

/***/ }),

/***/ 734:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CustomAmountPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Native

// providers




let CustomAmountPage = class CustomAmountPage {
    constructor(navParams, profileProvider, platformProvider, walletProvider, logger, socialSharing, txFormatProvider) {
        this.navParams = navParams;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.txFormatProvider = txFormatProvider;
        let walletId = this.navParams.data.id;
        this.showShareButton = this.platformProvider.isCordova;
        this.wallet = this.profileProvider.getWallet(walletId);
        this.walletProvider.getAddress(this.wallet, false).then(addr => {
            this.address = this.walletProvider.getAddressView(this.wallet, addr);
            let parsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, this.navParams.data.amount, this.navParams.data.currency);
            // Amount in USD or BTJ
            let _amount = parsedAmount.amount;
            let _currency = parsedAmount.currency;
            this.amountUnitStr = parsedAmount.amountUnitStr;
            if (_currency != 'BTJ' && _currency != 'BCH') {
                // Convert to BTJ or BCH
                let amountUnit = this.txFormatProvider.satToUnit(parsedAmount.amountSat);
                var btcParsedAmount = this.txFormatProvider.parseAmount(this.wallet.coin, amountUnit, this.wallet.coin.toUpperCase());
                this.amountCoin = btcParsedAmount.amount;
                this.altAmountStr = btcParsedAmount.amountUnitStr;
            }
            else {
                this.amountCoin = _amount; // BTJ or BCH
                this.altAmountStr = this.txFormatProvider.formatAlternativeStr(this.wallet.coin, parsedAmount.amountSat);
            }
            this.updateQrAddress();
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad CustomAmountPage');
    }
    updateQrAddress() {
        this.qrAddress =
            this.walletProvider.getProtoAddress(this.wallet, this.address) +
                '?amount=' +
                this.amountCoin;
    }
    shareAddress() {
        this.socialSharing.share(this.qrAddress);
    }
};
CustomAmountPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-custom-amount',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/receive/custom-amount/custom-amount.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Custom Amount\' | translate}}</ion-title>\n    <ion-buttons right>\n      <button *ngIf="showShareButton" ion-button icon-only (click)="shareAddress()">\n        <ion-icon ios="ios-share-outline" md="md-share"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="qr-container">\n    <ngx-qrcode *ngIf="address" copy-to-clipboard="{{ qrAddress }}" qrc-value="{{qrAddress}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n  </div>\n  <ion-list>\n    <ion-item>\n      <ion-label>{{\'Address\' | translate}}</ion-label>\n      <ion-note class="address-note" item-end>\n        {{address}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Amount</span>\n      <ion-note item-end>\n        {{amountUnitStr}} ({{altAmountStr}})\n      </ion-note>\n    </ion-item>\n    <ion-item ion-item>\n      <span translate>Receive in</span>\n      <ion-note class="wallet-label" item-end>\n        <ion-icon item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n        </ion-icon>\n        <span class="wallet-name">{{wallet.name}}</span>\n      </ion-note>\n    </ion-item>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/receive/custom-amount/custom-amount.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_6__providers_tx_format_tx_format__["a" /* TxFormatProvider */]])
], CustomAmountPage);

//# sourceMappingURL=custom-amount.js.map

/***/ }),

/***/ 735:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PayProPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers

let PayProPage = class PayProPage {
    constructor(navParams, viewCtrl, walletProvider) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.walletProvider = walletProvider;
        this.tx = this.navParams.data.tx;
        let wallet = this.navParams.data.wallet;
        this.address = this.walletProvider.getAddressView(wallet, this.tx.paypro.toAddress);
    }
    close() {
        this.viewCtrl.dismiss();
    }
};
PayProPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-payrpo',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/paypro/paypro.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Payment request\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list>\n    <ion-item class="item head">\n      <div class="amount-label">\n        <div class="amount">{{tx.amount | satToUnit: tx.coin}}</div>\n        <div class="alternative">{{tx.amount | satToFiat: tx.coin}}</div>\n      </div>\n    </ion-item>\n    <ion-item *ngIf="tx.paypro.domain">\n\n      <span translate>Pay To</span>\n      <ion-note item-end>\n        {{tx.paypro.domain}}\n      </ion-note>\n\n    </ion-item>\n\n    <ion-item *ngIf="tx.paypro.toAddress" copy-to-clipboard="{{tx.paypro.toAddress}}">\n      <div translate>Address</div>\n      <div class="comment">\n        {{address}}\n      </div>\n    </ion-item>\n\n    <ion-item>\n      <div translate>Certified by</div>\n      <div class="certified" text-wrap *ngIf="tx.paypro.caTrusted">\n        <ion-icon *ngIf="tx.paypro.verified" color="success" name="lock"></ion-icon>\n        <ion-icon *ngIf="!tx.paypro.verified" color="warning" name="unlock"></ion-icon>\n        {{tx.paypro.caName}} {{\'(Trusted)\' | translate}}\n      </div>\n      <div class="certified" text-wrap *ngIf="!tx.paypro.caTrusted">\n        <span *ngIf="tx.paypro.selfSigned">\n          <ion-icon color="danger" name="unlock"></ion-icon>\n          <span translate>Self-signed Certificate</span>\n        </span>\n        <span *ngIf="!tx.paypro.selfSigned">\n          <ion-icon color="warning" name="lock"></ion-icon>\n          {{tx.paypro.caName}}\n          <br>\n          <span translate>WARNING: UNTRUSTED CERTIFICATE</span>\n        </span>\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="tx.paypro.memo">\n      <div translate>Memo</div>\n      <div class="comment" text-wrap>\n        {{tx.paypro.memo}}\n      </div>\n    </ion-item>\n\n    <ion-item *ngIf="tx.paypro.expires">\n      <span translate>Expires</span>\n      <ion-note item-end>\n        {{tx.paypro.expires * 1000 | amTimeAgo }}\n      </ion-note>\n    </ion-item>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/paypro/paypro.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_2__providers_wallet_wallet__["a" /* WalletProvider */]])
], PayProPage);

//# sourceMappingURL=paypro.js.map

/***/ }),

/***/ 736:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ChooseFeeLevelPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Providers


let ChooseFeeLevelPage = class ChooseFeeLevelPage {
    constructor(viewCtrl, logger, popupProvider, feeProvider, translate) {
        this.viewCtrl = viewCtrl;
        this.logger = logger;
        this.popupProvider = popupProvider;
        this.feeProvider = feeProvider;
        this.translate = translate;
        this.FEE_MULTIPLIER = 10;
        this.FEE_MIN = 0;
        this.okText = this.translate.instant('Ok');
        this.cancelText = this.translate.instant('Cancel');
        // From parent controller
        this.network = this.viewCtrl.data.network;
        this.feeLevel = this.viewCtrl.data.feeLevel;
        // IF usingCustomFee
        this.customFeePerKB = this.viewCtrl.data.customFeePerKB
            ? this.viewCtrl.data.customFeePerKB
            : null;
        this.feePerSatByte = this.viewCtrl.data.feePerSatByte
            ? this.viewCtrl.data.feePerSatByte
            : null;
        if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](this.feeLevel))
            this.showErrorAndClose(null, this.translate.instant('Fee level is not defined'));
        this.selectedFee = this.feeLevel;
        this.feeOpts = Object.keys(this.feeProvider.getFeeOpts());
        this.loadingFee = true;
        this.feeProvider
            .getFeeLevels(this.coin)
            .then(levels => {
            this.loadingFee = false;
            if (__WEBPACK_IMPORTED_MODULE_3_lodash__["isEmpty"](levels)) {
                this.showErrorAndClose(null, this.translate.instant('Could not get fee levels'));
                return;
            }
            this.feeLevels = levels;
            this.updateFeeRate();
        })
            .catch(err => {
            this.loadingFee = false;
            this.showErrorAndClose(null, err);
            return;
        });
    }
    showErrorAndClose(title, msg) {
        title = title ? title : this.translate.instant('Error');
        this.logger.error(msg);
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.viewCtrl.dismiss();
        });
    }
    updateFeeRate() {
        let value = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == this.feeLevel;
        });
        // If no custom fee
        if (value) {
            this.customFeePerKB = null;
            this.feePerSatByte = (value.feePerKb / 1000).toFixed();
            this.avgConfirmationTime = value.nbBlocks * 10;
        }
        else {
            this.avgConfirmationTime = null;
            this.customSatPerByte = Number(this.feePerSatByte);
            this.customFeePerKB = (+this.feePerSatByte * 1000).toFixed();
        }
        // Warnings
        this.setFeesRecommended();
        this.checkFees(this.feePerSatByte);
    }
    setFeesRecommended() {
        this.maxFeeRecommended = this.getMaxRecommended();
        this.minFeeRecommended = this.getMinRecommended();
        this.minFeeAllowed = this.FEE_MIN;
        this.maxFeeAllowed = this.maxFeeRecommended * this.FEE_MULTIPLIER;
        this.maxFee =
            this.maxFeeRecommended > this.maxFeeAllowed
                ? this.maxFeeRecommended
                : this.maxFeeAllowed;
        this.minFee =
            this.minFeeRecommended < this.minFeeAllowed
                ? this.minFeeRecommended
                : this.minFeeAllowed;
    }
    getMinRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == 'superEconomy';
        });
        return parseInt((value.feePerKb / 1000).toFixed(), 10);
    }
    getMaxRecommended() {
        let value = __WEBPACK_IMPORTED_MODULE_3_lodash__["find"](this.feeLevels.levels[this.network], feeLevel => {
            return feeLevel.level == 'urgent';
        });
        return parseInt((value.feePerKb / 1000).toFixed(), 10);
    }
    checkFees(feePerSatByte) {
        let fee = Number(feePerSatByte);
        this.showError = fee <= this.minFeeAllowed ? true : false;
        this.showMinWarning =
            fee > this.minFeeAllowed && fee < this.minFeeRecommended ? true : false;
        this.showMaxWarning =
            fee < this.maxFeeAllowed && fee > this.maxFeeRecommended ? true : false;
    }
    ok() {
        this.customFeePerKB = this.customFeePerKB
            ? (this.customSatPerByte * 1000).toFixed()
            : null;
        this.viewCtrl.dismiss({
            newFeeLevel: this.feeLevel,
            customFeePerKB: this.customFeePerKB
        });
    }
    cancel() {
        this.viewCtrl.dismiss();
    }
    changeSelectedFee(newFeeLevelValue) {
        if (this.feeLevel != newFeeLevelValue) {
            this.logger.debug('New fee level: ' + newFeeLevelValue);
            this.feeLevel = newFeeLevelValue;
            this.updateFeeRate();
        }
    }
};
ChooseFeeLevelPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-choose-fee-level',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/send/choose-fee-level/choose-fee-level.html"*/'<ion-header>\n  <ion-navbar hideBackButton="true">\n    <ion-title>{{\'Fee level\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button (click)="cancel()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="testnet-warning" *ngIf="network!=\'livenet\'">\n    Testnet\n  </div>\n  <ion-list [hidden]="!feeLevel">\n    <ion-item-divider></ion-item-divider>\n    <ion-item class="fee-level">\n      <ion-label>{{\'Fee level\' | translate}}</ion-label>\n      <ion-select okText="{{okText}}" cancelText="{{cancelText}}" [(ngModel)]="selectedFee" (ionChange)="changeSelectedFee(selectedFee)">\n        <ion-option *ngFor="let fee of feeOpts" [value]="fee">{{ feeProvider.getFeeOpts()[fee] | translate }}</ion-option>\n      </ion-select>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n  <div [hidden]="!feeLevel">\n    <ion-list class="fee-info" *ngIf="!customFeePerKB">\n      <ion-item>\n        <div translate>\n          Average confirmation time\n        </div>\n        <ion-note item-end>\n          <span *ngIf="loadingFee">...</span>\n          <span *ngIf="avgConfirmationTime">\n            {{ avgConfirmationTime | amDuration: \'minute\' }}\n          </span>\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <div translate>\n          Current fee rate for this policy\n        </div>\n        <ion-note item-end>\n          <span *ngIf="loadingFee">...</span>\n          <span *ngIf="feePerSatByte && !loadingFee">\n            {{feePerSatByte}} sat/byte\n          </span>\n        </ion-note>\n      </ion-item>\n    </ion-list>\n\n    <ion-list class="fee-custom" *ngIf="customFeePerKB">\n      <ion-item>\n        <ion-label color="primary" floating>{{\'Enter custom fee in sat/byte\' | translate}}</ion-label>\n        <ion-input type="number" min="minFee" max="maxFee" (ionChange)="checkFees(customSatPerByte)" [(ngModel)]="customSatPerByte" required></ion-input>\n      </ion-item>\n      <ion-item class="fee-error" *ngIf="showError">\n        <span translate>Transactions without fee are not supported.</span>\n      </ion-item>\n\n      <ion-item class="fee-error" *ngIf="showMinWarning || showMaxWarning" text-wrap>\n        <span *ngIf="showMinWarning" translate>Your fee is lower than recommended.</span>\n        <span *ngIf="showMaxWarning" translate>You should not set a fee higher than {{maxFeeRecommended}} satoshis/byte.</span>\n      </ion-item>\n    </ion-list>\n\n    <button [disabled]="customSatPerByte >= maxFeeAllowed || showError" (click)="ok()" class="button-standard" ion-button>\n      {{\'Apply changes\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/send/choose-fee-level/choose-fee-level.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], ChooseFeeLevelPage);

//# sourceMappingURL=choose-fee-level.js.map

/***/ }),

/***/ 737:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmazonCardDetailsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Provider





let AmazonCardDetailsPage = class AmazonCardDetailsPage {
    constructor(amazonProvider, bwcErrorProvider, logger, externalLinkProvider, navParams, onGoingProcessProvider, popupProvider, viewCtrl) {
        this.amazonProvider = amazonProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.navParams = navParams;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.viewCtrl = viewCtrl;
        this.EXPIRY_TIME = 15 * 60;
        this.card = this.navParams.data.card;
        this.checkExpiryTime();
        this.country = this.amazonProvider.country;
        this.currency = this.amazonProvider.currency;
        this.redeemAmazonUrl = this.amazonProvider.redeemAmazonUrl;
        this.onlyIntegers = this.amazonProvider.onlyIntegers;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AmazonCardDetailsPage');
    }
    cancelGiftCard() {
        this.onGoingProcessProvider.set('cancelingGiftCard');
        this.amazonProvider.cancelGiftCard(this.card, (err, data) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Error canceling gift card', this.bwcErrorProvider.msg(err));
                return;
            }
            this.card.cardStatus = data.cardStatus;
            this.amazonProvider.savePendingGiftCard(this.card, null, () => {
                this.refreshGiftCard();
            });
        });
    }
    remove() {
        this.amazonProvider.savePendingGiftCard(this.card, {
            remove: true
        }, () => {
            this.close();
        });
    }
    refreshGiftCard() {
        if (!this.updateGiftCard)
            return;
        this.onGoingProcessProvider.set('updatingGiftCard');
        this.amazonProvider.getPendingGiftCards((err, giftCards) => {
            this.onGoingProcessProvider.clear();
            if (err) {
                this.popupProvider.ionicAlert('Error', err);
                return;
            }
            __WEBPACK_IMPORTED_MODULE_2_lodash__["forEach"](giftCards, function (dataFromStorage) {
                if (dataFromStorage.invoiceId == this.card.invoiceId) {
                    this.logger.debug('creating gift card');
                    this.amazonProvider.createGiftCard(dataFromStorage, (err, giftCard) => {
                        if (err) {
                            this.popupProvider.ionicAlert('Error', this.bwcErrorProvider.msg(err));
                            return;
                        }
                        if (!__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](giftCard) && giftCard.status != 'PENDING') {
                            var newData = {};
                            __WEBPACK_IMPORTED_MODULE_2_lodash__["merge"](newData, dataFromStorage, giftCard);
                            if (newData.status == 'expired') {
                                this.amazonProvider.savePendingGiftCard(newData, {
                                    remove: true
                                }, () => {
                                    this.close();
                                });
                                return;
                            }
                            this.amazonProvider.savePendingGiftCard(newData, null, () => {
                                this.logger.debug('Amazon gift card updated');
                                this.card = newData;
                            });
                        }
                        else
                            this.logger.debug('Pending gift card not available yet');
                    });
                }
            });
        });
    }
    close() {
        this.viewCtrl.dismiss();
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
    checkExpiryTime() {
        let cardDate = Math.floor(this.card.date / 1000);
        let now = Math.floor(Date.now() / 1000);
        this.isTimeExpired = now - cardDate > this.EXPIRY_TIME ? true : false;
    }
};
AmazonCardDetailsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-amazon-card-details',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon-card-details/amazon-card-details.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Details\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="header-modal">\n    <img *ngIf="country == \'usa\'" src="assets/img/amazon/a_generic.jpg" alt="Amazon.com Gift Card" (click)="refreshGiftCard()">\n    <img *ngIf="country == \'japan\'" src="assets/img/amazon/japan/GCs-logo-japan-cllb.jpg" alt="Amazon.co.jp " (click)="refreshGiftCard()">\n    <div class="header-modal-amount">\n      {{\'Gift Card Amount:\' | translate}}\n      <span class="text-bold">\n        <span *ngIf="onlyIntegers">{{card.amount | number : \'1.0-0\'}}</span> \n        <span *ngIf="!onlyIntegers">{{card.amount | number : \'1.2-2\'}}</span> \n        {{ currency }}\n      </span>\n    </div>\n    <div>\n      {{\'Created\' | translate}} {{card.date | amTimeAgo}}\n    </div>\n\n    <div *ngIf="card.claimCode">\n      <div *ngIf="card.cardStatus !== \'Canceled\'">\n        {{\'Claim code:\' | translate}}\n        <span class="text-bold" copy-to-clipboard="{{card.claimCode}}">{{card.claimCode}}</span>\n      </div>\n      <div class="redeem" *ngIf="card.cardStatus == \'Fulfilled\'">\n        <button ion-button outline (click)="openExternalLink(redeemAmazonUrl + card.claimCode)">\n          {{\'Redeem Now\' | translate}}\n        </button>\n      </div>\n      <div *ngIf="card.cardStatus == \'Canceled\'">\n        <div>\n          {{\'Status:\' | translate}}\n          <span class="text-bold" translate>\n            CANCELED\n          </span>\n        </div>\n      </div>\n    </div>\n    <div *ngIf="!card.claimCode">\n      <div>\n        {{\'Status:\' | translate}}\n        <span class="text-bold" *ngIf="card.status == \'PENDING\'" translate>\n          PENDING\n        </span>\n        <span class="text-bold" *ngIf="card.status==\'invalid\'" translate>\n          STILL PENDING\n        </span>\n        <span class="text-bold" *ngIf="card.status == \'FAILURE\' || card.status == \'RESEND\'" translate>\n          FAILURE\n        </span>\n        <span class="text-bold" *ngIf="card.status == \'expired\'" translate>\n          EXPIRED\n        </span>\n      </div>\n      <div *ngIf="updateGiftCard">\n        <a class="button button-clear button-positive" ng-click="refreshGiftCard()" translate>Try again</a>\n      </div>\n    </div>\n    <div class="invoice">\n      <a class="button button-clear button-calm" (click)="openExternalLink(card.invoiceUrl)" translate>See invoice &rarr;</a>\n    </div>\n    <div class="box-notification assertive" *ngIf="card.status == \'FAILURE\' || card.status == \'RESEND\'" translate>\n      There was a failure to the create gift card. Please, contact BitPay support.\n    </div>\n  </div>\n\n  <!-- Amazon USA -->\n  <ion-list *ngIf="card.claimCode && card.cardStatus == \'Fulfilled\' && country == \'usa\'" class="steps">\n    <ion-item-divider>To redeem your gift card, follow these steps:</ion-item-divider>\n\n    <ion-item>\n      <ol class="steps-info">\n        <li>Visit\n          <a (click)="openExternalLink(\'https://www.amazon.com/gc\')">www.amazon.com/gc</a>\n        </li>\n        <li>Click Apply to Account and enter the Claim Code when prompted.</li>\n        <li>Gift card funds will be applied automatically to eligible orders during the checkout process.</li>\n        <li>You must pay for any remaining balance on your order with another payment method.</li>\n      </ol>\n\n      <div>\n        <p class="steps-info">\n          Your gift card claim code may also be entered when prompted during checkout. To redeem your gift card using the Amazon.com 1-Click&reg; service, first add the gift card funds to Your Account.\n        </p>\n\n        <p class="steps-info">\n          If you have questions about redeeming your gift card, please visit\n          <a (click)="openExternalLink(\'https://www.amazon.com/gc-redeem\')">www.amazon.com/gc-redeem</a>. If you have questions regarding the BitPay Introductory offer, please contact BitPay.\n        </p>\n      </div>\n    </ion-item>\n  </ion-list>\n  <div *ngIf="country == \'usa\'" padding class="steps-info">\n    *\n    <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> is not a sponsor of this promotion. Except as required by law,\n    <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> Gift Cards ("GCs") cannot be transferred for value or redeemed for cash. GCs may be used only for purchases of eligible goods at\n    <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> or certain of its affiliated websites. For complete terms and conditions, see\n    <a (click)="openExternalLink(\'https://www.amazon.com/gc-legal\')">www.amazon.com/gc-legal</a>. GCs are issued by ACI Gift Cards, Inc., a Washington corporation. All Amazon &reg;, &trade; &amp; &copy; are IP of\n    <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a>, Inc. or its affiliates. No expiration date or service fees.\n  </div>\n\n  <!-- Amazon Japan -->\n  <ion-list *ngIf="card.claimCode && card.cardStatus == \'Fulfilled\' && country == \'japan\'" class="steps">\n    <ion-item-divider>Amazon</ion-item-divider>\n\n    <ion-item>\n      <p class="steps-info">Amazon</p>\n      <ol class="steps-info">\n        <li>\n          <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/use\')">www.amazon.co.jp/giftcard/use</a> \n        </li>\n        <li></li>\n        <li></li>\n        <li></li>\n        <li></li>\n      </ol>\n\n      <div>\n        <p class="steps-info">\n          *Amazon\n        </p>\n      </div>\n    </ion-item>\n\n    <ion-item-divider>To redeem your Gift Card:</ion-item-divider>\n    <ion-item>\n      <ol class="steps-info">\n        <li>Visit\n          <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/use\')">www.amazon.co.jp/giftcard/use</a>\n        </li>\n        <li>Sign-in to your Amazon.co.jp account.</li>\n        <li>Input Gift Card Code, and click Apply to Your Account button.</li>\n        <li>The balance of Gift Card amount is shown at the right column.</li>\n        <li>Please enjoy your shopping at Amazon.co.jp!</li>\n        <li>Once Amazon Gift Card is added to your account, you will be able to keep using the Gift Card until the balance becomes 0 JPY before it is expired.</li>\n      </ol>\n    </ion-item>\n\n  </ion-list>\n  <div *ngIf="country == \'japan\'" padding class="steps-info">\n    * Amazon Gift Cards Japan  () Amazon ()\n    <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> (PC) 10(0120-999-3731-8-1) (\n    <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/tc\')">www.amazon.co.jp/giftcard/tc</a>)\n    <br>\n    <br>* To use\n    <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> gift cards (Gift Card or Gift Cards) issued by Amazon Gift Cards Japan K.K. (Amazon GC), you need to create an account on\n    <a (click)="openExternalLink(\'http://amazon.co.jp\')">http://www.amazon.co.jp</a> (including PC and mobile sites. Amazon Sites). Gift Cards can only be redeemed through Amazon Sites, but cannot be used to purchase other Gift Cards or to pay certain membership fee available at Amazon Sites. Gift Card balance will expire at 11:59 p.m. (Japan Time) of the date specified as expiration date on each Gift Card. Gift Cards are non-refundable and non-exchangeable. Gift Card cannot be resold or transferred for value. Amazon GC or its affiliates are not responsible if Gift Card is lost, stolen, destroyed or used without your permission. If you want to know your Gift Card balance, expiration date or have any other questions regarding Gift Cards, please call Customer Service (TEL: 0120-999-373, Address: 1-8-1 Shimomeguro, Meguro-ku, Tokyo 153-0064, Japan). For more information, please read the full Terms and Conditions of Gift Cards (\n    <a (click)="openExternalLink(\'http://www.amazon.co.jp/giftcard/tc\')">http://www.amazon.co.jp/giftcard/tc</a>).\n  </div>\n\n  <button ion-item block text-center detail-none *ngIf="card.status == \'FAILURE\' || card.cardStatus == \'Canceled\' || card.cardStatus == \'Expired\' || card.status == \'expired\'" class="button-footer assertive" (click)="remove()" translate>Remove</button>\n  <button ion-item block text-center detail-none *ngIf="card.status == \'SUCCESS\' && card.cardStatus == \'Fulfilled\' && !isTimeExpired" class="assertive" (click)="cancelGiftCard()" translate>Cancel</button>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon-card-details/amazon-card-details.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_amazon_amazon__["a" /* AmazonProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */]])
], AmazonCardDetailsPage);

//# sourceMappingURL=amazon-card-details.js.map

/***/ }),

/***/ 738:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ActivityPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tx_details_tx_details__ = __webpack_require__(243);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__txp_details_txp_details__ = __webpack_require__(244);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers




// pages



let ActivityPage = class ActivityPage {
    constructor(navCtrl, logger, profileProvider, modalCtrl, onGoingProcessProvider, walletProvider, popupProvider, translate) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.modalCtrl = modalCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.walletProvider = walletProvider;
        this.popupProvider = popupProvider;
        this.translate = translate;
    }
    ionViewWillEnter() {
        let loading = this.translate.instant('Updating... Please stand by');
        this.onGoingProcessProvider.set(loading);
        this.profileProvider
            .getNotifications(50)
            .then(nData => {
            this.onGoingProcessProvider.clear();
            this.notifications = nData.notifications;
            this.profileProvider
                .getTxps({})
                .then(txpsData => {
                this.txps = txpsData.txps;
            })
                .catch(err => {
                this.logger.error(err);
            });
        })
            .catch(err => {
            this.onGoingProcessProvider.clear();
            this.logger.error(err);
        });
    }
    openNotificationModal(n) {
        let wallet = this.profileProvider.getWallet(n.walletId);
        if (n.txid) {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__tx_details_tx_details__["a" /* TxDetailsPage */], { txid: n.txid, walletId: n.walletId });
        }
        else {
            let txp = __WEBPACK_IMPORTED_MODULE_10_lodash__["find"](this.txps, {
                id: n.txpId
            });
            if (txp) {
                let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_9__txp_details_txp_details__["a" /* TxpDetailsPage */], { tx: txp }, { showBackdrop: false, enableBackdropDismiss: false });
                modal.present();
            }
            else {
                this.onGoingProcessProvider.set('loadingTxInfo');
                this.walletProvider
                    .getTxp(wallet, n.txpId)
                    .then(txp => {
                    let _txp = txp;
                    this.onGoingProcessProvider.clear();
                    let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_9__txp_details_txp_details__["a" /* TxpDetailsPage */], { tx: _txp }, { showBackdrop: false, enableBackdropDismiss: false });
                    modal.present();
                })
                    .catch(() => {
                    this.onGoingProcessProvider.clear();
                    this.logger.warn('No txp found');
                    let title = this.translate.instant('Error');
                    let subtitle = this.translate.instant('Transaction not found');
                    this.popupProvider.ionicAlert(title, subtitle);
                });
            }
        }
    }
};
ActivityPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-activity',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/home/activity/activity.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Recent Transactions\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="notifications && notifications[0]">\n    <span *ngFor="let notification of notifications" (click)="openNotificationModal(notification)">\n      <page-wallet-activity [notification]="notification"></page-wallet-activity>\n    </span>\n  </ion-list>\n\n  <ion-list *ngIf="notifications && !notifications[0]">\n    <ion-item text-center>\n      <span translate>No pending proposals</span>\n    </ion-item>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/home/activity/activity.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], ActivityPage);

//# sourceMappingURL=activity.js.map

/***/ }),

/***/ 739:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ProposalsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(14);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers



let ProposalsPage = class ProposalsPage {
    constructor(onGoingProcessProvider, addressBookProvider, logger, profileProvider, translate) {
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.addressBookProvider = addressBookProvider;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.translate = translate;
    }
    ionViewWillEnter() {
        this.addressBookProvider
            .list()
            .then(ab => {
            this.addressbook = ab || {};
            let loading = this.translate.instant('Updating pending proposals... Please stand by');
            this.onGoingProcessProvider.set(loading);
            this.profileProvider
                .getTxps(50)
                .then(txpsData => {
                this.onGoingProcessProvider.clear();
                this.txps = txpsData.txps;
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                this.logger.error(err);
            });
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
};
ProposalsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-proposals',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/home/proposals/proposals.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Pending Proposals\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list *ngIf="txps && txps[0]">\n    <page-txp *ngFor="let txp of txps" [tx]="txp" [addressbook]="addressbook"></page-txp>\n  </ion-list>\n\n  <ion-list *ngIf="txps && !txps[0]">\n    <ion-item>\n      <span translate>No pending proposals</span>\n    </ion-item>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/home/proposals/proposals.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], ProposalsPage);

//# sourceMappingURL=proposals.js.map

/***/ }),

/***/ 740:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReleaseProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operators__ = __webpack_require__(359);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_rxjs_operators___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_rxjs_operators__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(27);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




let ReleaseProvider = class ReleaseProvider {
    constructor(http, app) {
        this.http = http;
        this.app = app;
        this.LATEST_RELEASE_URL =
            'https://api.github.com/repos/bitpay/copay/releases/latest';
        this.appVersion = this.app.info.version;
    }
    getCurrentAppVersion() {
        return this.appVersion;
    }
    getLatestAppVersion() {
        return this.http.get(this.LATEST_RELEASE_URL).pipe(Object(__WEBPACK_IMPORTED_MODULE_2_rxjs_operators__["map"])(x => x['tag_name']));
    }
    verifyTagFormat(tag) {
        var regex = /^v?\d+\.\d+\.\d+$/i;
        return regex.exec(tag);
    }
    formatTagNumber(tag) {
        var formattedNumber = tag.replace(/^v/i, '').split('.');
        return {
            major: +formattedNumber[0],
            minor: +formattedNumber[1],
            patch: +formattedNumber[2]
        };
    }
    checkForUpdates(latestVersion, currentVersion) {
        if (!currentVersion)
            currentVersion = this.appVersion;
        let result = {
            updateAvailable: null,
            availableVersion: null,
            error: null
        };
        if (!this.verifyTagFormat(currentVersion))
            result.error =
                'Cannot verify the format of version tag: ' + currentVersion;
        if (!this.verifyTagFormat(latestVersion))
            result.error =
                'Cannot verify the format of latest release tag: ' + latestVersion;
        let current = this.formatTagNumber(currentVersion);
        let latest = this.formatTagNumber(latestVersion);
        if (latest.major > current.major ||
            (latest.major == current.major && latest.minor > current.minor) ||
            (latest.minor == current.minor && latest.patch > current.patch)) {
            result.updateAvailable = true;
            result.availableVersion = latestVersion;
        }
        return result;
    }
};
ReleaseProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */], __WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */]])
], ReleaseProvider);

//# sourceMappingURL=release.js.map

/***/ }),

/***/ 819:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ReceivePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__backup_backup_warning_backup_warning__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__add_copayers_copayers__ = __webpack_require__(145);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_address_address__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_14_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Native

// Pages



// Providers








let ReceivePage = class ReceivePage {
    constructor(actionSheetCtrl, navCtrl, logger, profileProvider, walletProvider, platformProvider, events, socialSharing, bwcErrorProvider, translate, externalLinkProvider, addressProvider, popupProvider) {
        this.actionSheetCtrl = actionSheetCtrl;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.platformProvider = platformProvider;
        this.events = events;
        this.socialSharing = socialSharing;
        this.bwcErrorProvider = bwcErrorProvider;
        this.translate = translate;
        this.externalLinkProvider = externalLinkProvider;
        this.addressProvider = addressProvider;
        this.popupProvider = popupProvider;
        this.wallets = [];
        this.showShareButton = this.platformProvider.isCordova;
    }
    ionViewWillEnter() {
        this.isOpenSelector = false;
        this.wallets = this.profileProvider.getWallets();
        this.onWalletSelect(this.checkSelectedWallet(this.wallet, this.wallets));
        this.events.subscribe('bwsEvent', (walletId, type) => {
            // Update current address
            if (this.wallet && walletId == this.wallet.id && type == 'NewIncomingTx')
                this.setAddress(true);
        });
    }
    ionViewWillLeave() {
        this.events.unsubscribe('bwsEvent');
    }
    onWalletSelect(wallet) {
        this.wallet = wallet;
        if (this.wallet) {
            this.setAddress(false, true);
        }
    }
    checkSelectedWallet(wallet, wallets) {
        if (!wallet)
            return wallets[0];
        let w = __WEBPACK_IMPORTED_MODULE_14_lodash__["find"](wallets, w => {
            return w.id == wallet.id;
        });
        if (!w)
            return wallets[0];
        return wallet;
    }
    requestSpecificAmount() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__send_amount_amount__["a" /* AmountPage */], {
            toAddress: this.address,
            id: this.wallet.credentials.walletId,
            recipientType: 'wallet',
            name: this.wallet.name,
            color: this.wallet.color,
            coin: this.wallet.coin,
            nextPage: 'CustomAmountPage',
            network: this.addressProvider.validateAddress(this.address).network
        });
    }
    setAddress(newAddr, changingWallet) {
        this.loading =
            newAddr || __WEBPACK_IMPORTED_MODULE_14_lodash__["isEmpty"](this.address) || changingWallet ? true : false;
        this.walletProvider
            .getAddress(this.wallet, newAddr)
            .then(addr => {
            this.loading = false;
            this.address = this.walletProvider.getAddressView(this.wallet, addr);
            this.updateQrAddress();
        })
            .catch(err => {
            this.loading = false;
            this.logger.warn(this.bwcErrorProvider.msg(err, 'Server Error'));
        });
    }
    updateQrAddress() {
        this.qrAddress = this.walletProvider.getProtoAddress(this.wallet, this.address);
    }
    shareAddress() {
        if (!this.showShareButton)
            return;
        this.socialSharing.share(this.address);
    }
    showWallets() {
        this.isOpenSelector = true;
        let id = this.wallet ? this.wallet.credentials.walletId : null;
        this.events.publish('showWalletsSelectorEvent', this.wallets, id);
        this.events.subscribe('selectWalletEvent', wallet => {
            if (!__WEBPACK_IMPORTED_MODULE_14_lodash__["isEmpty"](wallet))
                this.onWalletSelect(wallet);
            this.events.unsubscribe('selectWalletEvent');
            this.isOpenSelector = false;
        });
    }
    goCopayers() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__add_copayers_copayers__["a" /* CopayersPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    goToBackup() {
        const backupWarningModal = this.popupProvider.createMiniModal('backup-needed');
        backupWarningModal.present({
            animate: false
        });
        backupWarningModal.onDidDismiss(goToBackupPage => {
            if (goToBackupPage)
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__backup_backup_warning_backup_warning__["a" /* BackupWarningPage */], {
                    walletId: this.wallet.credentials.walletId
                });
        });
    }
    openWikiBackupNeeded() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/115002989283-Why-don-t-I-have-an-online-account-for-my-BitPay-wallet-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Read more in our Wiki');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    showMoreOptions() {
        let buttons = [];
        let specificAmountButton = {
            text: this.translate.instant('Request Specific Amount'),
            handler: () => {
                this.requestSpecificAmount();
            }
        };
        let shareButton = {
            text: this.translate.instant('Share Address'),
            handler: () => {
                this.shareAddress();
            }
        };
        buttons.push(specificAmountButton);
        if (this.showShareButton &&
            this.wallet &&
            this.wallet.isComplete() &&
            !this.wallet.needsBackup)
            buttons.push(shareButton);
        const actionSheet = this.actionSheetCtrl.create({
            buttons
        });
        actionSheet.present();
    }
};
ReceivePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-receive',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/receive/receive.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Receive\'|translate}}</ion-title>\n    <ion-buttons right>\n      <button *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup" (click)="showMoreOptions()" ion-button icon-only>\n        <ion-icon name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="wrapper">\n    <div class="header-extend">\n      <div *ngIf="!wallet" class="no-wallets">\n        <button ion-button clear>\n          <span translate>No wallet</span>\n        </button>\n      </div>\n    </div>\n    <div class="card" *ngIf="wallets[0]">\n      <button ion-item detail-none (click)="showWallets()">\n        <ion-icon class="item-img" item-start>\n          <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n          <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n        </ion-icon>\n        <div class="item-title">{{wallet.name}}</div>\n        <div class="item-subtitle">\n          <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n            Incomplete\n          </span>\n          <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n            Needs backup\n          </span>\n          <span *ngIf="wallet.isComplete() && !wallet.needsBackup">\n            <span *ngIf="!wallet.balanceHidden && !wallet.scanning">\n              {{wallet.status && wallet.status.totalBalanceStr ? (wallet.status.totalBalanceStr) : ( wallet.cachedBalance ? wallet.cachedBalance + (wallet.cachedBalanceUpdatedOn ? \' &middot; \' + ( wallet.cachedBalanceUpdatedOn * 1000 | amTimeAgo) : \'\') : \'\')}}\n            </span>\n            <span *ngIf="wallet.scanning" translate>Scanning funds</span>\n            <span *ngIf="wallet.balanceHidden && !wallet.scanning">\n              <span translate>[Balance Hidden]</span>\n            </span>\n            <span class="text-gray" *ngIf="wallet.credentials.m > 1" translate>{{wallet.credentials.m}}-of-{{wallet.credentials.n}}</span>\n            <ion-icon *ngIf="!wallet.balanceHidden && wallet.status && (wallet.status.totalBalanceSat != wallet.status.spendableAmount)" ios="ios-timer-outline" md="md-timer"></ion-icon>\n            <span *ngIf="wallet.error" class="wallet-warning">{{wallet.error}}</span>\n          </span>\n        </div>\n        <div item-end>\n          <button ion-button clear color="grey" icon-only>\n            <ion-icon *ngIf="!isOpenSelector" name="ios-arrow-down-outline"></ion-icon>\n            <ion-icon *ngIf="isOpenSelector" name="ios-arrow-up-outline"></ion-icon>\n          </button>\n        </div>\n      </button>\n\n      <div *ngIf="wallet && wallet.isComplete() && wallet.needsBackup" class="message-container">\n        <div class="title">\n          <span translate>Wallet not backed up</span>\n        </div>\n        <div class="subtitle">\n          <span translate>Funds received to a wallet cannot be retrieved if the wallet is not backed up.</span>\n          <a (click)="openWikiBackupNeeded()" translate>Learn more</a>\n        </div>\n        <button ion-button class="button-standard" (click)="goToBackup()">\n          {{\'Backup wallet\' | translate}}\n        </button>\n      </div>\n\n      <div *ngIf="wallet && !wallet.isComplete()" class="message-container">\n        <div class="title">\n          <span translate>Incomplete wallet</span>\n        </div>\n        <div class="subtitle">\n          <span translate>All signing devices must be added to this multisig wallet before bastoji addresses can be created.</span>\n        </div>\n        <button ion-button class="button-standard" (click)="goCopayers()">\n          {{\'Open wallet\' | translate}}\n        </button>\n      </div>\n\n      <div *ngIf="wallet && wallet.isComplete() && !wallet.needsBackup" class="qr-container">\n        <div *ngIf="loading" class="loading-address spinner">\n          <ion-spinner></ion-spinner>\n        </div>\n        <ngx-qrcode *ngIf="!loading && address" copy-to-clipboard="{{ address }}" qrc-value="{{qrAddress}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n        <div>\n          <div *ngIf="!loading" class="text-address ellipsis" copy-to-clipboard="{{ address }}">\n            <img *ngIf="wallet.coin == \'btc\'" src="assets/img/icon-bastoji.svg" alt="BTJ" width="18" />\n            <img *ngIf="wallet.coin == \'bch\'" src="assets/img/bastoji-cash-logo.svg" alt="BCH" width="22" /> {{ address }}\n          </div>\n          <div *ngIf="loading" class="text-address">...</div>\n        </div>\n        <ion-list>\n          <button ion-item detail-none text-center (click)="setAddress(true)">\n            <span class="new-address" ion-text color="primary" translate>Generate new address</span>\n          </button>\n        </ion-list>\n      </div>\n    </div>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/receive/receive.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_9__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_10__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_15__providers_popup_popup__["a" /* PopupProvider */]])
], ReceivePage);

//# sourceMappingURL=receive.js.map

/***/ }),

/***/ 82:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers



let FeeProvider = class FeeProvider {
    constructor(configProvider, logger, bwcProvider, translate) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.bwcProvider = bwcProvider;
        this.translate = translate;
        this.CACHE_TIME_TS = 60;
        this.cache = {
            updateTs: 0,
            coin: ''
        };
        this.logger.info('FeeProvider initialized.');
    }
    getFeeOpts() {
        const feeOpts = {
            urgent: this.translate.instant('Urgent'),
            priority: this.translate.instant('Priority'),
            normal: this.translate.instant('Normal'),
            economy: this.translate.instant('Economy'),
            superEconomy: this.translate.instant('Super Economy'),
            custom: this.translate.instant('Custom')
        };
        return feeOpts;
    }
    getCurrentFeeLevel() {
        return this.configProvider.get().wallet.settings.feeLevel || 'normal';
    }
    getFeeRate(coin, network, feeLevel) {
        return new Promise((resolve, reject) => {
            if (feeLevel == 'custom')
                return resolve();
            network = network || 'livenet';
            this.getFeeLevels(coin)
                .then(response => {
                let feeLevelRate;
                if (response.fromCache) {
                    feeLevelRate = __WEBPACK_IMPORTED_MODULE_5_lodash__["find"](response.levels[network], o => {
                        return o.level == feeLevel;
                    });
                }
                else {
                    feeLevelRate = __WEBPACK_IMPORTED_MODULE_5_lodash__["find"](response.levels[network], o => {
                        return o.level == feeLevel;
                    });
                }
                if (!feeLevelRate || !feeLevelRate.feePerKb) {
                    let msg = this.translate.instant('Could not get dynamic fee for level:') +
                        ' ' +
                        feeLevel;
                    return reject(msg);
                }
                let feeRate = feeLevelRate.feePerKb;
                if (!response.fromCache)
                    this.logger.debug('Dynamic fee: ' +
                        feeLevel +
                        '/' +
                        network +
                        ' ' +
                        (feeLevelRate.feePerKb / 1000).toFixed() +
                        ' SAT/B');
                return resolve(feeRate);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getCurrentFeeRate(coin, network) {
        return new Promise((resolve, reject) => {
            this.getFeeRate(coin, network, this.getCurrentFeeLevel())
                .then((data) => {
                return resolve(data);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getFeeLevels(coin) {
        return new Promise((resolve, reject) => {
            coin = coin || 'btc';
            if (this.cache.coin == coin &&
                this.cache.updateTs > Date.now() - this.CACHE_TIME_TS * 1000) {
                return resolve({ levels: this.cache.data, fromCache: true });
            }
            let walletClient = this.bwcProvider.getClient(null, {});
            walletClient.getFeeLevels(coin, 'livenet', (errLivenet, levelsLivenet) => {
                if (errLivenet) {
                    return reject(this.translate.instant('Could not get dynamic fee'));
                }
                walletClient.getFeeLevels('btc', 'testnet', (errTestnet, levelsTestnet) => {
                    if (errTestnet) {
                        return reject(this.translate.instant('Could not get dynamic fee'));
                    }
                    this.cache.updateTs = Date.now();
                    this.cache.coin = coin;
                    this.cache.data = {
                        livenet: levelsLivenet,
                        testnet: levelsTestnet
                    };
                    return resolve({ levels: this.cache.data });
                });
            });
        });
    }
};
FeeProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], FeeProvider);

//# sourceMappingURL=fee.js.map

/***/ }),

/***/ 820:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ScanProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ionic_native_qr_scanner__ = __webpack_require__(821);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





let ScanProvider = class ScanProvider {
    constructor(qrScanner, platform, logger, events) {
        this.qrScanner = qrScanner;
        this.platform = platform;
        this.logger = logger;
        this.events = events;
        this.isDesktop = !this.platform.isCordova;
        this.isAvailable = true;
        this.hasPermission = false;
        this.isDenied = false;
        this.isRestricted = false;
        this.canEnableLight = false;
        this.canChangeCamera = false;
        this.canOpenSettings = false;
        this.backCamera = true;
        this.initializeStarted = false;
        this.initializeCompleted = false;
        this.scannerVisible = false;
        this.lightEnabled = false;
        this.frontCameraEnabled = false;
    }
    checkCapabilities(status) {
        this.logger.debug('scannerService is reviewing platform capabilities...');
        // Permission can be assumed on the desktop builds
        this.hasPermission = this.isDesktop || status.authorized ? true : false;
        this.isDenied = status.denied ? true : false;
        this.isRestricted = status.restricted ? true : false;
        this.canEnableLight = status.canEnableLight ? true : false;
        this.canChangeCamera = status.canChangeCamera ? true : false;
        this.canOpenSettings = status.canOpenSettings ? true : false;
        this.logCapabilities();
    }
    orIsNot(bool) {
        return bool ? '' : 'not ';
    }
    logCapabilities() {
        this.logger.debug('A camera is ' + this.orIsNot(this.isAvailable) + 'available to this app.');
        var access = 'not authorized';
        if (this.hasPermission)
            access = 'authorized';
        if (this.isDenied)
            access = 'denied';
        if (this.isRestricted)
            access = 'restricted';
        this.logger.debug('Camera access is ' + access + '.');
        this.logger.debug('Support for opening device settings is ' +
            this.orIsNot(this.canOpenSettings) +
            'available on this platform.');
        this.logger.debug('A light is ' +
            this.orIsNot(this.canEnableLight) +
            'available on this platform.');
        this.logger.debug('A second camera is ' +
            this.orIsNot(this.canChangeCamera) +
            'available on this platform.');
    }
    /**
     * Immediately return known capabilities of the current platform.
     */
    getCapabilities() {
        return {
            isAvailable: this.isAvailable,
            hasPermission: this.hasPermission,
            isDenied: this.isDenied,
            isRestricted: this.isRestricted,
            canEnableLight: this.canEnableLight,
            canChangeCamera: this.canChangeCamera,
            canOpenSettings: this.canOpenSettings
        };
    }
    /**
     * If camera access has been granted, pre-initialize the QRScanner. This method
     * can be safely called before the scanner is visible to improve perceived
     * scanner loading times.
     *
     * The `status` of QRScanner is returned to the callback.
     */
    gentleInitialize() {
        return new Promise(resolve => {
            if (this.initializeStarted && !this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                });
                return resolve();
            }
            this.initializeStarted = true;
            this.logger.debug('Trying to pre-initialize QRScanner.');
            if (!this.isDesktop) {
                this.qrScanner.getStatus().then(status => {
                    this.checkCapabilities(status);
                    if (status.authorized) {
                        this.logger.debug('Camera permission already granted.');
                        this.initialize().then(() => {
                            return resolve();
                        });
                    }
                    else {
                        this.logger.debug('QRScanner not authorized, waiting to initalize.');
                        this.completeInitialization(status);
                        return resolve();
                    }
                });
            }
            else {
                this.logger.debug('To avoid flashing the privacy light, we do not pre-initialize the camera on desktop.');
                return resolve();
            }
        });
    }
    reinitialize() {
        this.initializeCompleted = false;
        this.qrScanner.destroy();
        this.initialize();
    }
    initialize() {
        return new Promise(resolve => {
            this.logger.debug('Initializing scanner...');
            this.qrScanner
                .prepare()
                .then(status => {
                this.completeInitialization(status);
                return resolve();
            })
                .catch(err => {
                this.isAvailable = false;
                this.logger.error(err);
                // does not return `status` if there is an error
                this.qrScanner.getStatus().then(status => {
                    this.completeInitialization(status);
                    return resolve();
                });
            });
        });
    }
    completeInitialization(status) {
        this.checkCapabilities(status);
        this.initializeCompleted = true;
        this.events.publish('scannerServiceInitialized');
    }
    isInitialized() {
        return this.initializeCompleted;
    }
    isInitializeStarted() {
        return this.initializeStarted;
    }
    /**
     * (Re)activate the QRScanner, and cancel the timeouts if present.
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    activate() {
        return new Promise(resolve => {
            this.logger.debug('Activating scanner...');
            this.qrScanner.show().then(status => {
                this.initializeCompleted = true;
                this.checkCapabilities(status);
                return resolve();
            });
        });
    }
    /**
     * Start a new scan.
     */
    scan() {
        return new Promise(resolve => {
            this.logger.debug('Scanning...');
            let scanSub = this.qrScanner.scan().subscribe((text) => {
                this.logger.debug('Scanned something', text);
                scanSub.unsubscribe(); // stop scanning
                return resolve(text);
            });
        });
    }
    pausePreview() {
        this.qrScanner.pausePreview();
    }
    resumePreview() {
        this.qrScanner.resumePreview();
    }
    /**
     * Deactivate the QRScanner. To balance user-perceived performance and power
     * consumption, this kicks off a countdown which will "sleep" the scanner
     * after a certain amount of time.
     *
     * The `status` of QRScanner is passed to the callback when deactivation
     * is complete.
     */
    deactivate() {
        this.logger.debug('Deactivating scanner...');
        if (this.lightEnabled) {
            this.qrScanner.disableLight();
            this.lightEnabled = false;
        }
        this.hide();
        this.destroy();
    }
    // Natively hide the QRScanner's preview
    // On mobile platforms, this can reduce GPU/power usage
    // On desktop, this fully turns off the camera (and any associated privacy lights)
    hide() {
        this.qrScanner.hide();
    }
    // Reduce QRScanner power/processing consumption by the maximum amount
    destroy() {
        this.qrScanner.destroy();
    }
    /**
     * Toggle the device light (if available).
     *
     * The callback receives a boolean which is `true` if the light is enabled.
     */
    toggleLight() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling light...');
            if (this.lightEnabled) {
                this.qrScanner
                    .disableLight()
                    .then(() => {
                    this.lightEnabled = false;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (disableLight)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .enableLight()
                    .then(() => {
                    this.lightEnabled = true;
                    return resolve(this.lightEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (enableLight)', err);
                    return reject(err);
                });
            }
        });
    }
    /**
     * Switch cameras (if a second camera is available).
     *
     * The `status` of QRScanner is passed to the callback when activation
     * is complete.
     */
    toggleCamera() {
        return new Promise((resolve, reject) => {
            this.logger.info('Toggling camera...');
            if (this.frontCameraEnabled) {
                this.qrScanner
                    .useBackCamera()
                    .then(() => {
                    this.frontCameraEnabled = false;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useBackCamera)', err);
                    return reject(err);
                });
            }
            else {
                this.qrScanner
                    .useFrontCamera()
                    .then(() => {
                    this.frontCameraEnabled = true;
                    return resolve(this.frontCameraEnabled);
                })
                    .catch(err => {
                    this.logger.error('Scan Provider Error (useFrontCamera)', err);
                    return reject(err);
                });
            }
        });
    }
    openSettings() {
        this.logger.debug('Attempting to open device settings...');
        this.qrScanner.openSettings();
    }
};
ScanProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1__ionic_native_qr_scanner__["a" /* QRScanner */],
        __WEBPACK_IMPORTED_MODULE_4__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */]])
], ScanProvider);

//# sourceMappingURL=scan.js.map

/***/ }),

/***/ 822:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SendPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_address__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__ = __webpack_require__(238);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__paper_wallet_paper_wallet__ = __webpack_require__(255);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__settings_addressbook_add_add__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__amount_amount__ = __webpack_require__(68);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers








// Pages



let SendPage = class SendPage {
    constructor(navCtrl, profileProvider, walletProvider, addressBookProvider, logger, incomingDataProvider, popupProvider, addressProvider, events, externalLinkProvider) {
        this.navCtrl = navCtrl;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.addressBookProvider = addressBookProvider;
        this.logger = logger;
        this.incomingDataProvider = incomingDataProvider;
        this.popupProvider = popupProvider;
        this.addressProvider = addressProvider;
        this.events = events;
        this.externalLinkProvider = externalLinkProvider;
        this.search = '';
        this.contactsList = [];
        this.filteredContactsList = [];
        this.CONTACTS_SHOW_LIMIT = 10;
        this.currentContactsPage = 0;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad SendPage');
    }
    ionViewWillLeave() {
        this.events.unsubscribe('finishIncomingDataMenuEvent');
    }
    ionViewWillEnter() {
        this.walletsBtc = this.profileProvider.getWallets({ coin: 'btc' });
        this.walletsBch = this.profileProvider.getWallets({ coin: 'bch' });
        this.hasBtcWallets = !__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.walletsBtc);
        this.hasBchWallets = !__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.walletsBch);
        this.events.subscribe('finishIncomingDataMenuEvent', data => {
            switch (data.redirTo) {
                case 'AmountPage':
                    this.sendPaymentToAddress(data.value, data.coin);
                    break;
                case 'AddressBookPage':
                    this.addToAddressBook(data.value);
                    break;
                case 'OpenExternalLink':
                    this.goToUrl(data.value);
                    break;
                case 'PaperWalletPage':
                    this.scanPaperWallet(data.value);
                    break;
            }
        });
        this.updateBchWalletsList();
        this.updateBtcWalletsList();
        this.updateContactsList();
    }
    ionViewDidEnter() {
        this.search = '';
    }
    goToUrl(url) {
        this.externalLinkProvider.open(url);
    }
    sendPaymentToAddress(bastojiAddress, coin) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__amount_amount__["a" /* AmountPage */], { toAddress: bastojiAddress, coin });
    }
    addToAddressBook(bastojiAddress) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__settings_addressbook_add_add__["a" /* AddressbookAddPage */], { addressbookEntry: bastojiAddress });
    }
    scanPaperWallet(privateKey) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__paper_wallet_paper_wallet__["a" /* PaperWalletPage */], { privateKey });
    }
    updateBchWalletsList() {
        this.walletBchList = [];
        if (!this.hasBchWallets)
            return;
        __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](this.walletsBch, v => {
            this.walletBchList.push({
                color: v.color,
                name: v.name,
                recipientType: 'wallet',
                coin: v.coin,
                network: v.network,
                m: v.credentials.m,
                n: v.credentials.n,
                isComplete: v.isComplete(),
                needsBackup: v.needsBackup,
                getAddress: () => {
                    return new Promise((resolve, reject) => {
                        this.walletProvider
                            .getAddress(v, false)
                            .then(addr => {
                            return resolve(addr);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                }
            });
        });
    }
    updateBtcWalletsList() {
        this.walletBtcList = [];
        if (!this.hasBtcWallets)
            return;
        __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](this.walletsBtc, v => {
            this.walletBtcList.push({
                color: v.color,
                name: v.name,
                recipientType: 'wallet',
                coin: v.coin,
                network: v.network,
                m: v.credentials.m,
                n: v.credentials.n,
                isComplete: v.isComplete(),
                needsBackup: v.needsBackup,
                getAddress: () => {
                    return new Promise((resolve, reject) => {
                        this.walletProvider
                            .getAddress(v, false)
                            .then(addr => {
                            return resolve(addr);
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                }
            });
        });
    }
    updateContactsList() {
        this.addressBookProvider.list().then(ab => {
            this.hasContacts = __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](ab) ? false : true;
            if (!this.hasContacts)
                return;
            this.contactsList = [];
            __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](ab, (v, k) => {
                this.contactsList.push({
                    name: __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](v) ? v.name : v,
                    address: k,
                    network: this.addressProvider.validateAddress(k).network,
                    email: __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](v) ? v.email : null,
                    recipientType: 'contact',
                    coin: this.addressProvider.validateAddress(k).coin,
                    getAddress: () => {
                        return new Promise(resolve => {
                            return resolve(k);
                        });
                    }
                });
            });
            let shortContactsList = __WEBPACK_IMPORTED_MODULE_2_lodash__["clone"](this.contactsList.slice(0, (this.currentContactsPage + 1) * this.CONTACTS_SHOW_LIMIT));
            this.filteredContactsList = __WEBPACK_IMPORTED_MODULE_2_lodash__["clone"](shortContactsList);
            this.contactsShowMore =
                this.contactsList.length > shortContactsList.length;
        });
    }
    showMore() {
        this.currentContactsPage++;
        this.updateContactsList();
    }
    openScanner() {
        this.navCtrl.parent.select(2);
    }
    findContact(search) {
        if (this.incomingDataProvider.redir(search))
            return;
        if (search && search.trim() != '') {
            let result = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.contactsList, item => {
                let val = item.name;
                return __WEBPACK_IMPORTED_MODULE_2_lodash__["includes"](val.toLowerCase(), search.toLowerCase());
            });
            this.filteredContactsList = result;
        }
        else {
            this.updateContactsList();
        }
    }
    goToAmount(item) {
        item
            .getAddress()
            .then((addr) => {
            if (!addr) {
                // Error is already formated
                this.popupProvider.ionicAlert('Error - no address');
                return;
            }
            this.logger.debug('Got address:' + addr + ' | ' + item.name);
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_13__amount_amount__["a" /* AmountPage */], {
                recipientType: item.recipientType,
                toAddress: addr,
                name: item.name,
                email: item.email,
                color: item.color,
                coin: item.coin,
                network: item.network
            });
            return;
        })
            .catch(err => {
            this.logger.error('Send: could not getAddress', err);
        });
    }
};
SendPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-send',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/send/send.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Send\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div *ngIf="hasBtcWallets || hasBchWallets">\n    <div class="send-header-wrapper">\n      <span class="send-heading" translate>Recipient</span>\n      <ion-item class="search-wrapper">\n        <ion-icon item-start class="bastoji-icon" name="search-btc"></ion-icon>\n        <ion-input placeholder="{{\'Search or enter bastoji address\' | translate}}" [(ngModel)]="search" (ngModelChange)="findContact(search)"></ion-input>\n        <ion-icon item-end class="scan-icon" (click)="openScanner()">\n          <img src="assets/img/scan-ico.svg">\n        </ion-icon>\n      </ion-item>\n    </div>\n\n    <div class="card" *ngIf="filteredContactsList && filteredContactsList[0]">\n      <ion-item-divider>\n        <span class="title" translate>Transfer to Contact</span>\n      </ion-item-divider>\n      <ion-list>\n        <button ion-item *ngFor="let item of filteredContactsList" (click)="goToAmount(item)">\n          <ion-icon class="item-img" item-start>\n            <gravatar [name]="item.name" [width]="35" [height]="35" [email]="item.email"></gravatar>\n          </ion-icon>\n          <div class="item-title">{{item.name}}</div>\n        </button>\n        <button ion-item class="show-more" *ngIf="contactsShowMore" (click)="showMore()">\n          <span translate>Show all</span>\n        </button>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="walletBtcList && walletBtcList[0]">\n      <ion-item-divider class="title">\n        <img src="assets/img/icon-bastoji.svg" alt="Bastoji Wallets" width="16" />\n        <span translate>Transfer to Bastoji Wallet</span>\n      </ion-item-divider>\n\n      <ion-list>\n        <button ion-item *ngFor="let wallet of walletBtcList" (click)="goToAmount(wallet)">\n          <ion-icon class="item-img" item-start>\n            <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <span class="item-title">{{wallet.name}}</span>\n          <ion-note class="wallet-warning" *ngIf="!wallet.isComplete" item-end>\n            {{\'Incomplete\' | translate}}\n          </ion-note>\n          <ion-note class="wallet-warning" *ngIf="wallet.isComplete && wallet.needsBackup" item-end>\n            {{\'Needs backup\' | translate}}\n          </ion-note>\n          <ion-note *ngIf="wallet.m > 1 && wallet.isComplete && !wallet.needsBackup" item-end>\n            {{wallet.m}}-{{wallet.n}}\n          </ion-note>\n        </button>\n      </ion-list>\n    </div>\n\n    <div class="card" *ngIf="walletBchList && walletBchList[0]">\n      <ion-item-divider class="title">\n        <img src="assets/img/bastoji-cash-logo.svg" alt="Bastoji Cash Wallets" width="22" />\n        <span translate>Transfer to Bastoji Cash Wallet</span>\n      </ion-item-divider>\n\n      <ion-list>\n        <button ion-item *ngFor="let wallet of walletBchList" (click)="goToAmount(wallet)">\n          <ion-icon class="item-img" item-start>\n            <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg" class="icon-wallet" />\n            <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n          </ion-icon>\n          <span class="item-title">{{wallet.name}}</span>\n          <ion-note class="wallet-warning" *ngIf="!wallet.isComplete" item-end>\n            {{\'Incomplete\' | translate}}\n          </ion-note>\n          <ion-note class="wallet-warning" *ngIf="wallet.isComplete && wallet.needsBackup" item-end>\n            {{\'Needs backup\' | translate}}\n          </ion-note>\n          <ion-note *ngIf="wallet.m > 1 && wallet.isComplete && !wallet.needsBackup" item-end>\n            {{wallet.m}}-{{wallet.n}}\n          </ion-note>\n        </button>\n      </ion-list>\n    </div>\n  </div>\n  <div *ngIf="!hasBtcWallets && !hasBchWallets" class="no-wallet-message">\n    <span translate>To get started, you\'ll need to create a bastoji wallet and get some bastoji.</span>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/send/send.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_9__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_incoming_data_incoming_data__["a" /* IncomingDataProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */]])
], SendPage);

//# sourceMappingURL=send.js.map

/***/ }),

/***/ 823:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_language_language__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__feedback_feedback_complete_feedback_complete__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__feedback_send_feedback_send_feedback__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__integrations_amazon_amazon_settings_amazon_settings__ = __webpack_require__(824);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__integrations_bitpay_card_bitpay_settings_bitpay_settings__ = __webpack_require__(825);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__integrations_coinbase_coinbase_settings_coinbase_settings__ = __webpack_require__(826);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__integrations_glidera_glidera_settings_glidera_settings__ = __webpack_require__(827);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__integrations_mercado_libre_mercado_libre_settings_mercado_libre_settings__ = __webpack_require__(828);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__integrations_shapeshift_shapeshift_settings_shapeshift_settings__ = __webpack_require__(829);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__pin_pin_modal_pin_modal__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__about_about__ = __webpack_require__(831);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__addressbook_addressbook__ = __webpack_require__(833);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_25__advanced_advanced__ = __webpack_require__(835);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_26__alt_currency_alt_currency__ = __webpack_require__(836);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_27__fee_policy_fee_policy__ = __webpack_require__(837);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_28__language_language__ = __webpack_require__(838);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_29__lock_lock__ = __webpack_require__(839);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_30__notifications_notifications__ = __webpack_require__(840);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_31__wallet_settings_wallet_settings__ = __webpack_require__(841);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers









// pages


















let SettingsPage = class SettingsPage {
    constructor(navCtrl, app, language, externalLinkProvider, profileProvider, configProvider, logger, homeIntegrationsProvider, bitPayCardProvider, platformProvider, translate, modalCtrl, touchid) {
        this.navCtrl = navCtrl;
        this.app = app;
        this.language = language;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.modalCtrl = modalCtrl;
        this.touchid = touchid;
        this.integrationServices = [];
        this.bitpayCardItems = [];
        this.showBitPayCard = false;
        this.appName = this.app.info.nameCase;
        this.walletsBch = [];
        this.walletsBtc = [];
        this.isCordova = this.platformProvider.isCordova;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad SettingsPage');
    }
    ionViewWillEnter() {
        this.currentLanguageName = this.language.getName(this.language.getCurrent());
        this.walletsBtc = this.profileProvider.getWallets({
            coin: 'btc'
        });
        this.walletsBch = this.profileProvider.getWallets({
            coin: 'bch'
        });
        this.config = this.configProvider.get();
        this.selectedAlternative = {
            name: this.config.wallet.settings.alternativeName,
            isoCode: this.config.wallet.settings.alternativeIsoCode
        };
        this.lockMethod =
            this.config && this.config.lock && this.config.lock.method
                ? this.config.lock.method.toLowerCase()
                : null;
    }
    ionViewDidEnter() {
        // Show integrations
        let integrations = this.homeIntegrationsProvider.get();
        // Hide BitPay if linked
        setTimeout(() => {
            this.integrationServices = __WEBPACK_IMPORTED_MODULE_4_lodash__["remove"](__WEBPACK_IMPORTED_MODULE_4_lodash__["clone"](integrations), x => {
                if (x.name == 'debitcard' && x.linked)
                    return;
                else
                    return x;
            });
        }, 200);
        // Only BitPay Wallet
        this.bitPayCardProvider.get({}, (_, cards) => {
            this.showBitPayCard = this.app.info._enabledExtensions.debitcard
                ? true
                : false;
            this.bitpayCardItems = cards;
        });
    }
    openAltCurrencyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_26__alt_currency_alt_currency__["a" /* AltCurrencyPage */]);
    }
    openLanguagePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_28__language_language__["a" /* LanguagePage */]);
    }
    openAdvancedPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_25__advanced_advanced__["a" /* AdvancedPage */]);
    }
    openAboutPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_23__about_about__["a" /* AboutPage */]);
    }
    openLockPage() {
        let config = this.configProvider.get();
        let lockMethod = config && config.lock && config.lock.method
            ? config.lock.method.toLowerCase()
            : null;
        if (!lockMethod || lockMethod == 'disabled')
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        if (lockMethod == 'pin')
            this.openPinModal('lockSetUp');
        if (lockMethod == 'fingerprint')
            this.checkFingerprint();
    }
    openAddressBookPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_24__addressbook_addressbook__["a" /* AddressbookPage */]);
    }
    openNotificationsPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_30__notifications_notifications__["a" /* NotificationsPage */]);
    }
    openFeePolicyPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_27__fee_policy_fee_policy__["a" /* FeePolicyPage */]);
    }
    openWalletSettingsPage(walletId) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_31__wallet_settings_wallet_settings__["a" /* WalletSettingsPage */], { walletId });
    }
    openSendFeedbackPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_15__feedback_send_feedback_send_feedback__["a" /* SendFeedbackPage */]);
    }
    openFeedbackCompletePage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_14__feedback_feedback_complete_feedback_complete__["a" /* FeedbackCompletePage */], { fromSettings: true });
    }
    openSettingIntegration(name) {
        switch (name) {
            case 'amazon':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_16__integrations_amazon_amazon_settings_amazon_settings__["a" /* AmazonSettingsPage */]);
                break;
            case 'coinbase':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_18__integrations_coinbase_coinbase_settings_coinbase_settings__["a" /* CoinbaseSettingsPage */]);
                break;
            case 'debitcard':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */]);
                break;
            case 'glidera':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_19__integrations_glidera_glidera_settings_glidera_settings__["a" /* GlideraSettingsPage */]);
                break;
            case 'mercadolibre':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_20__integrations_mercado_libre_mercado_libre_settings_mercado_libre_settings__["a" /* MercadoLibreSettingsPage */]);
                break;
            case 'shapeshift':
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_21__integrations_shapeshift_shapeshift_settings_shapeshift_settings__["a" /* ShapeshiftSettingsPage */]);
                break;
        }
    }
    openCardSettings(id) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_17__integrations_bitpay_card_bitpay_settings_bitpay_settings__["a" /* BitPaySettingsPage */], { id });
    }
    openHelpExternalLink() {
        let url = this.appName == 'Sqoin'
            ? 'https://github.com/bbergaoui/bastoji-mobile/issues'
            : 'https://help.bitpay.com/bitpay-app';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website.');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_22__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(cancelClicked => {
            if (!cancelClicked)
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        });
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_29__lock_lock__["a" /* LockPage */]);
        });
    }
};
SettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Settings\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item (click)="openAddressBookPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-address-book.svg" width="22">\n      </ion-icon>\n      <span translate>Address book</span>\n    </button>\n\n    <button ion-item (click)="openHelpExternalLink()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-help-support.svg" width="22">\n      </ion-icon>\n      <span translate>Help &amp; support</span>\n    </button>\n\n    <button ion-item (click)="openSendFeedbackPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-send-feedback.svg" width="22">\n      </ion-icon>\n      <span translate>Send feedback</span>\n    </button>\n\n    <button ion-item *ngIf="isCordova" (click)="openFeedbackCompletePage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-heart.svg" width="22">\n      </ion-icon>\n      <span translate>Share</span> {{ appName }}\n    </button>\n\n    <ion-item-divider>{{\'Preferences\' | translate}}</ion-item-divider>\n\n    <button ion-item (click)="openNotificationsPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-notifications.svg" width="22">\n      </ion-icon>\n      <span translate>Notifications</span>\n    </button>\n\n    <button ion-item (click)="openLanguagePage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-language.svg" width="22">\n      </ion-icon>\n      <ion-label>\n        <span translate>Language</span>\n      </ion-label>\n      <ion-note *ngIf="currentLanguageName" item-end>\n        {{ currentLanguageName }}\n      </ion-note>\n    </button>\n\n    <button ion-item (click)="openAltCurrencyPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-alternative-currency.svg" width="22">\n      </ion-icon>\n      <ion-label>\n        {{\'Alternative currency\' | translate}}\n      </ion-label>\n      <ion-note *ngIf="selectedAlternative" item-end>\n        {{ selectedAlternative.name }}\n      </ion-note>\n    </button>\n\n    <button ion-item (click)="openFeePolicyPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-network.svg" width="22">\n      </ion-icon>\n      <ion-label>\n        {{\'Bastoji network fee policy\' | translate}}\n      </ion-label>\n    </button>\n\n    <button ion-item *ngIf="isCordova" (click)="openLockPage()">\n      <ion-icon class="custom-icon item-img" *ngIf="lockMethod != \'disabled\'" name="ios-lock-outline" item-start></ion-icon>\n      <ion-icon class="custom-icon item-img" *ngIf="lockMethod == \'disabled\'" name="ios-unlock-outline" item-start></ion-icon>\n      <ion-label>\n        {{\'Lock\' | translate}}\n      </ion-label>\n      <ion-note *ngIf="lockMethod === \'disabled\'" item-end>\n        {{\'Disabled\' | translate}}\n      </ion-note>\n      <ion-note *ngIf="lockMethod === \'pin\'" item-end>\n        {{\'PIN\' | translate}}\n      </ion-note>\n      <ion-note *ngIf="lockMethod === \'fingerprint\'" item-end>\n        {{\'Fingerprint\' | translate}}\n      </ion-note>\n    </button>\n\n    <ion-item-divider *ngIf="walletsBtc.length">{{\'Bastoji Wallets\' | translate}}</ion-item-divider>\n\n    <button ion-item *ngFor="let wallet of walletsBtc" (click)="openWalletSettingsPage(wallet.credentials.walletId)">\n      <ion-icon class="item-img" item-start>\n        <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg"\n          class="icon-wallet" />\n        <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg"\n          class="icon-wallet" />\n      </ion-icon>\n      <div class="item-title">{{wallet.name}}</div>\n      <div class="item-subtitle">\n        <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n          Incomplete\n        </span>\n        <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n          Needs backup\n        </span>\n      </div>\n      <ion-note *ngIf="wallet.credentials.m > 1 && wallet.isComplete() && !wallet.needsBackup" item-end>\n        {{wallet.credentials.m}}-{{wallet.credentials.n}}\n      </ion-note>\n    </button>\n    \n    <ion-item-divider *ngIf="walletsBch.length">{{\'Bastoji Cash Wallets\' | translate}}</ion-item-divider>\n    \n    <button ion-item *ngFor="let wallet of walletsBch" (click)="openWalletSettingsPage(wallet.credentials.walletId)">\n      <ion-icon class="item-img" item-start>\n        <img *ngIf="wallet.network == \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet-testnet.svg"\n          class="icon-wallet" />\n        <img *ngIf="wallet.network != \'testnet\'" [ngStyle]="{\'background-color\': wallet.color}" src="assets/img/icon-wallet.svg"\n          class="icon-wallet" />\n      </ion-icon>\n      <div class="item-title">{{wallet.name}}</div>\n      <div class="item-subtitle">\n        <span class="wallet-warning" *ngIf="!wallet.isComplete()" translate>\n          Incomplete\n        </span>\n        <span class="wallet-warning" *ngIf="wallet.isComplete() && wallet.needsBackup" translate>\n          Needs backup\n        </span>\n      </div>\n      <ion-note *ngIf="wallet.credentials.m > 1 && wallet.isComplete() && !wallet.needsBackup" item-end>\n        {{wallet.credentials.m}}-{{wallet.credentials.n}}\n      </ion-note>\n    </button>\n\n    <div *ngIf="showBitPayCard && bitpayCardItems && bitpayCardItems[0]">\n      <ion-item-divider>\n        BitPay Visa\n        <sup>&reg;</sup> Card\n      </ion-item-divider>\n      <ion-list>\n        <button ion-item *ngFor="let card of bitpayCardItems" (click)="openCardSettings(card.id)">\n          <ion-icon class="item-img" item-start>\n            <img src="assets/img/icon-card.svg" class="icon-card" />\n          </ion-icon>\n          <div class="item-title">BitPay Visa&reg; Card ({{card.lastFourDigits}})</div>\n          <div class="item-subtitle">{{card.balance ? (card.balance | currency:card.currencySymbol:2) : \'Add funds to get started\'|translate}} {{card.updatedOn\n            ? (\' &middot; \' + (card.updatedOn * 1000 | amTimeAgo)) : \'\'}}</div>\n        </button>\n      </ion-list>\n    </div>\n\n    <ion-item-divider>\n      {{\'Services\' | translate}}\n    </ion-item-divider>\n\n    <button ion-item *ngFor="let integration of integrationServices" (click)="openSettingIntegration(integration.name)">\n      <ion-icon class="item-img" item-start>\n        <img src="{{integration.icon}}" class="icon-services" />\n      </ion-icon>\n      <span>{{integration.title}}</span>\n      <ion-note item-end>\n        <span *ngIf="integration.linked" translate>Linked</span>\n        <span *ngIf="!integration.linked">\n          {{integration.show ? (\'On\'|translate) : (\'Off\'|translate)}}\n        </span>\n      </ion-note>\n    </button>\n\n    <ion-item-divider>{{\'More\' | translate}}</ion-item-divider>\n\n    <button ion-item (click)="openAdvancedPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-advanced.svg" width="22">\n      </ion-icon>\n      <span translate>Advanced</span>\n    </button>\n\n    <button ion-item (click)="openAboutPage()">\n      <ion-icon class="item-img" item-start>\n        <img src="assets/img/settings-icons/icon-about.svg" width="22">\n      </ion-icon>\n      <span translate>About</span> {{appName}}\n    </button>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_13__providers_touchid_touchid__["b" /* TouchIdProvider */]])
], SettingsPage);

//# sourceMappingURL=settings.js.map

/***/ }),

/***/ 824:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AmazonSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_amazon_amazon__ = __webpack_require__(122);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__ = __webpack_require__(17);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


// Providers






let AmazonSettingsPage = class AmazonSettingsPage {
    constructor(configProvider, logger, externalLinkProvider, homeIntegrationsProvider, onGoingProcessProvider, amazonProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.amazonProvider = amazonProvider;
        this.serviceName = 'amazon';
        this.serviceName = 'amazon';
        this.service = __WEBPACK_IMPORTED_MODULE_1_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AmazonSettingsPage');
        this.initialize();
    }
    initialize() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.amazonProvider.currency) {
                this.onGoingProcessProvider.set('');
                yield this.amazonProvider.setCurrencyByLocation();
                this.onGoingProcessProvider.clear();
            }
            this.country = this.amazonProvider.country;
            this.pageTitle = this.amazonProvider.pageTitle;
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    openExternalLink(url) {
        this.externalLinkProvider.open(url);
    }
};
AmazonSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-amazon-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon-settings/amazon-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{ pageTitle }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n    </ion-item>\n\n    <!-- USA -->\n    <ion-item-divider text-wrap *ngIf="country == \'usa\'">\n      <span class="terms-of-use">\n        *\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> is not a sponsor of this promotion. Except as required by law,\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> Gift Cards ("GCs") cannot be transferred for value or redeemed for cash. GCs may be used only for purchases of eligible goods at\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a> or certain of its affiliated websites. For complete terms and conditions, see\n        <a (click)="openExternalLink(\'https://www.amazon.com/gc-legal\')">www.amazon.com/gc-legal</a>. GCs are issued by ACI Gift Cards, Inc., a Washington corporation. All Amazon &reg;, &trade; &amp; &copy; are IP of\n        <a (click)="openExternalLink(\'http://amazon.com\')">Amazon.com</a>, Inc. or its affiliates. No expiration date or service fees.\n      </span>\n    </ion-item-divider>\n\n    <!-- Japan -->\n    <ion-item-divider text-wrap *ngIf="country == \'japan\'">\n      <span class="terms-of-use">\n        * Amazon Gift Cards Japan  () Amazon ()\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> (PC) 10(0120-999-3731-8-1) (\n        <a (click)="openExternalLink(\'https://www.amazon.co.jp/giftcard/tc\')">www.amazon.co.jp/giftcard/tc</a>)\n        <br>\n        <br>* To use\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">Amazon.co.jp</a> gift cards (Gift Card or Gift Cards) issued by Amazon Gift Cards Japan K.K. (Amazon GC), you need to create an account on\n        <a (click)="openExternalLink(\'http://amazon.co.jp\')">http://www.amazon.co.jp</a> (including PC and mobile sites. Amazon Sites). Gift Cards can only be redeemed through Amazon Sites, but cannot be used to purchase other Gift Cards or to pay certain membership fee available at Amazon Sites. Gift Card balance will expire at 11:59 p.m. (Japan Time) of the date specified as expiration date on each Gift Card. Gift Cards are non-refundable and non-exchangeable. Gift Card cannot be resold or transferred for value. Amazon GC or its affiliates are not responsible if Gift Card is lost, stolen, destroyed or used without your permission. If you want to know your Gift Card balance, expiration date or have any other questions regarding Gift Cards, please call Customer Service (TEL: 0120-999-373, Address: 1-8-1 Shimomeguro, Meguro-ku, Tokyo 153-0064, Japan). For more information, please read the full Terms and Conditions of Gift Cards (\n        <a (click)="openExternalLink(\'http://www.amazon.co.jp/giftcard/tc\')">http://www.amazon.co.jp/giftcard/tc</a>).\n      </span>\n    </ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/amazon/amazon-settings/amazon-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_amazon_amazon__["a" /* AmazonProvider */]])
], AmazonSettingsPage);

//# sourceMappingURL=amazon-settings.js.map

/***/ }),

/***/ 825:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BitPaySettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_bitpay_account_bitpay_account__ = __webpack_require__(358);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_card_bitpay_card__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers





let BitPaySettingsPage = class BitPaySettingsPage {
    constructor(navParams, navCtrl, bitpayAccountProvider, bitPayCardProvider, popupProvider, configProvider, homeIntegrationsProvider) {
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.bitpayAccountProvider = bitpayAccountProvider;
        this.bitPayCardProvider = bitPayCardProvider;
        this.popupProvider = popupProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'debitcard';
        this.service = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showAtHome = !!this.service[0].show;
    }
    ionViewWillEnter() {
        let cardId = this.navParams.data.id;
        if (cardId) {
            this.bitPayCardProvider.getCards(cards => {
                this.bitpayCard = __WEBPACK_IMPORTED_MODULE_2_lodash__["find"](cards, { id: cardId });
            });
        }
        else {
            this.service = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.homeIntegrationsProvider.get(), {
                name: this.serviceName
            });
            this.showAtHome = !!this.service[0].show;
        }
    }
    integrationChange() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showAtHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showAtHome);
        this.configProvider.set(opts);
    }
    unlinkCard(card) {
        let title = 'Unlink BitPay Card?';
        let msg = 'Are you sure you would like to remove your BitPay Card (' +
            card.lastFourDigits +
            ') from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.bitPayCardProvider.remove(card.id, err => {
                    if (err) {
                        this.popupProvider.ionicAlert('Error', 'Could not remove the card');
                        return;
                    }
                    this.navCtrl.pop();
                });
            }
        });
    }
    unlinkAccount(card) {
        let title = 'Unlink BitPay Account?';
        let msg = 'Are you sure you would like to remove your BitPay Account (' +
            card.email +
            ') and all associated cards from this device?';
        this.popupProvider.ionicConfirm(title, msg).then(res => {
            if (res) {
                this.bitpayAccountProvider.removeAccount(card.email, () => {
                    this.navCtrl.pop();
                });
            }
        });
    }
};
BitPaySettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-bitpay-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-settings/bitpay-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Card Settings\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <div *ngIf="!bitpayCard">\n      <ion-item>\n        <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="showAtHome" (ionChange)="integrationChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n    <div *ngIf="bitpayCard">\n      <ion-item>\n        <ion-icon item-start>\n          <img width="60" src="assets/img/bitpay-card/bitpay-card-visa.svg" />\n        </ion-icon>\n        <h2>BitPay Visa&reg; Card</h2>\n        <p>{{bitpayCard.email}}</p>\n      </ion-item>\n      <ion-item>\n        Last four digits\n        <ion-note item-end>\n          {{bitpayCard.lastFourDigits}}\n        </ion-note>\n      </ion-item>\n      \n      <ion-item-divider></ion-item-divider>\n\n      <a ion-item text-center detail-none (click)="unlinkCard(bitpayCard)">\n        <span ion-text color="primary" translate>Unlink card</span>\n      </a>\n      <ion-item-divider margin-bottom>\n        <span translate>Unlink the card will remove it from this device.</span>\n      </ion-item-divider>\n      <a ion-item detail-none text-center (click)="unlinkAccount(bitpayCard)">\n        <span ion-text color="danger" translate>Unlink account</span>\n      </a>\n      <ion-item-divider margin-bottom>\n        <span translate>Unlink the account will remove it and all associated cards from this device.</span>\n      </ion-item-divider>\n\n    </div>\n  </ion-list>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/bitpay-card/bitpay-settings/bitpay-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_bitpay_account_bitpay_account__["a" /* BitPayAccountProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_bitpay_card_bitpay_card__["a" /* BitPayCardProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], BitPaySettingsPage);

//# sourceMappingURL=bitpay-settings.js.map

/***/ }),

/***/ 826:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CoinbaseSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_coinbase_coinbase__ = __webpack_require__(124);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers






let CoinbaseSettingsPage = class CoinbaseSettingsPage {
    constructor(app, navCtrl, popupProvider, logger, coinbaseProvider, configProvider, homeIntegrationsProvider) {
        this.app = app;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.coinbaseProvider = coinbaseProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'coinbase';
        this.service = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidLoad() {
        this.coinbaseProvider.init((err, data) => {
            if (err || __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](data)) {
                if (err) {
                    this.logger.error(err);
                    let errorId = err.errors ? err.errors[0].id : null;
                    err = err.errors ? err.errors[0].message : err;
                    this.popupProvider
                        .ionicAlert('Error connecting to Coinbase', err)
                        .then(() => {
                        if (errorId == 'revoked_token') {
                            this.coinbaseProvider.logout();
                            this.navCtrl.popToRoot({ animate: false });
                        }
                    });
                }
                return;
            }
            let accessToken = data.accessToken;
            let accountId = data.accountId;
            this.coinbaseProvider.getAccount(accessToken, accountId, (_, account) => {
                this.coinbaseAccount = account.data[0];
            });
            this.coinbaseProvider.getCurrentUser(accessToken, (_, user) => {
                this.coinbaseUser = user.data;
            });
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    revokeToken() {
        this.popupProvider
            .ionicConfirm('Coinbase', 'Are you sure you would like to log out of your Coinbase account?')
            .then(res => {
            if (res) {
                this.coinbaseProvider.logout();
                this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_8__tabs_tabs__["a" /* TabsPage */]);
            }
        });
    }
};
CoinbaseSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-coinbase-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Coinbase</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n    </ion-item>\n  </ion-list>\n\n  <ion-list *ngIf="coinbaseAccount && coinbaseAccount.balance">\n    <ion-item-divider>Account</ion-item-divider>\n    <ion-item>\n      <span>ID</span>\n      <ion-note item-end>\n        {{coinbaseAccount.id}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span>Name</span>\n      <ion-note item-end>\n        {{coinbaseAccount.name}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span>Balance</span>\n      <ion-note item-end>\n        {{coinbaseAccount.balance.amount}} {{coinbaseAccount.balance.currency}}\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-list *ngIf="coinbaseUser">\n    <ion-item-divider>User Information</ion-item-divider>\n    <ion-item>\n      <span>ID</span>\n      <ion-note item-end>\n        {{coinbaseUser.id}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span>Email</span>\n      <ion-note item-end>\n        {{coinbaseUser.email}}\n      </ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item (click)="revokeToken()">\n      <span class="assertive">Log out</span>\n    </button>\n  </ion-list>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/coinbase/coinbase-settings/coinbase-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_coinbase_coinbase__["a" /* CoinbaseProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], CoinbaseSettingsPage);

//# sourceMappingURL=coinbase-settings.js.map

/***/ }),

/***/ 827:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GlideraSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__ = __webpack_require__(142);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// Providers





let GlideraSettingsPage = class GlideraSettingsPage {
    constructor(app, navCtrl, popupProvider, logger, glideraProvider, configProvider, homeIntegrationsProvider) {
        this.app = app;
        this.navCtrl = navCtrl;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.glideraProvider = glideraProvider;
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'glidera';
        this.account = {};
        this.service = __WEBPACK_IMPORTED_MODULE_3_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    ionViewDidEnter() {
        this.glideraProvider.init((err, glidera) => {
            if (err || !glidera) {
                if (err)
                    this.showErrorAndBack('Error connecting Glidera', err);
                return;
            }
            this.account.token = glidera.token;
            this.account.permissions = glidera.permissions;
            this.account.status = glidera.status;
            this.glideraProvider.updateStatus(this.account);
        });
    }
    showErrorAndBack(title, msg) {
        title = title ? title : 'Error';
        this.logger.error(msg);
        msg = msg && msg.errors ? msg.errors[0].message : msg;
        this.popupProvider.ionicAlert(title, msg).then(() => {
            this.navCtrl.pop();
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    revokeToken() {
        this.popupProvider
            .ionicConfirm('Glidera', 'Are you sure you would like to log out of your Glidera account?')
            .then(res => {
            if (res) {
                this.glideraProvider.remove();
                this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_8__tabs_tabs__["a" /* TabsPage */]);
            }
        });
    }
};
GlideraSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-glidera-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera-settings/glidera-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Glidera</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n    </ion-item>\n  </ion-list>\n\n  <ion-list *ngIf="account && account.token">\n    <div *ngIf="account && account.permissions">\n      <ion-item-divider>\n        Permissions\n      </ion-item-divider>\n      <ion-item>\n        <span>Email</span>\n        <ion-note item-end>\n          {{account.permissions.view_email_address}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Personal Information</span>\n        <ion-note item-end>\n          {{account.permissions.personal_info}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Buy/Sell</span>\n        <ion-note item-end>\n          {{account.permissions.transact}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Transaction History</span>\n        <ion-note item-end>\n          {{account.permissions.transaction_history}}\n        </ion-note>\n      </ion-item>\n    </div>\n\n    <div *ngIf="account && account.permissions && account.permissions.view_email_address && account.email">\n      <ion-item-divider>\n        Email\n      </ion-item-divider>\n      <ion-item>\n        <span>Email</span>\n        <ion-note item-end>\n          {{account.email.email}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Active</span>\n        <ion-note item-end>\n          {{account.email.userEmailIsSetup}}\n        </ion-note>\n      </ion-item>\n    </div>\n\n    <div *ngIf="account && account.permissions && account.permissions.personal_info && account.personalInfo">\n      <ion-item-divider>\n        Personal Information\n      </ion-item-divider>\n\n      <ion-item>\n        <span>First Name</span>\n        <ion-note item-end>\n          {{account.personalInfo.firstName}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Middle Name</span>\n        <ion-note item-end>\n          {{account.personalInfo.middleName}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Last Name</span>\n        <ion-note item-end>\n          {{account.personalInfo.lastName}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Birth Date</span>\n        <ion-note item-end>\n          {{account.personalInfo.birthDate}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Address 1</span>\n        <ion-note item-end>\n          {{account.personalInfo.address1}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Address 2</span>\n        <ion-note item-end>\n          {{account.personalInfo.address2}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>City</span>\n        <ion-note item-end>\n          {{account.personalInfo.city}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>State</span>\n        <ion-note item-end>\n          {{account.personalInfo.state}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>ZIP Code</span>\n        <ion-note item-end>\n          {{account.personalInfo.zipCode}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Country</span>\n        <ion-note item-end>\n          {{account.personalInfo.countryCode}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Occupation</span>\n        <ion-note item-end>\n          {{account.personalInfo.occupation}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Basic Information State</span>\n        <ion-note item-end>\n          {{account.personalInfo.basicInfoState}}\n        </ion-note>\n      </ion-item>\n    </div>\n\n    <div *ngIf="account && account.status">\n      <ion-item-divider>\n        Status\n      </ion-item-divider>\n\n      <ion-item>\n        <span>Buy/Sell</span>\n        <ion-note item-end>\n          {{account.status.userCanTransact}}\n        </ion-note>\n      </ion-item>\n\n      <ion-item>\n        <span>Buy</span>\n        <ion-note item-end>\n          {{account.status.userCanBuy}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Sell</span>\n        <ion-note item-end>\n          {{account.status.userCanSell}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Email Is Setup</span>\n        <ion-note item-end>\n          {{account.status.userEmailIsSetup}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Phone Is Setup</span>\n        <ion-note item-end>\n          {{account.status.userPhoneIsSetup}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Bank Account Is Setup</span>\n        <ion-note item-end>\n          {{account.status.userBankAccountIsSetup}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Personal Information State</span>\n        <ion-note item-end>\n          {{account.status.personalInfoState}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Bank Account State</span>\n        <ion-note item-end>\n          {{account.status.bankAccountState}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Country</span>\n        <ion-note item-end>\n          {{account.status.country}}\n        </ion-note>\n      </ion-item>\n    </div>\n\n    <div *ngIf="account && account.limits">\n      <ion-item-divider>\n        Limits\n      </ion-item-divider>\n\n      <ion-item>\n        <span>Daily Buy</span>\n        <ion-note item-end>\n          {{account.limits.dailyBuy|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Daily Sell</span>\n        <ion-note item-end>\n          {{account.limits.dailySell|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Monthly Buy</span>\n        <ion-note item-end>\n          {{account.limits.monthlyBuy|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Monthly Sell</span>\n        <ion-note item-end>\n          {{account.limits.monthlySell|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Daily Buy Remaining</span>\n        <ion-note item-end>\n          {{account.limits.dailyBuyRemaining|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Daily Sell Remaining</span>\n        <ion-note item-end>\n          {{account.limits.dailySellRemaining|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Monthly Buy Remaining</span>\n        <ion-note item-end>\n          {{account.limits.monthlyBuyRemaining|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Monthly Sell Remaining</span>\n        <ion-note item-end>\n          {{account.limits.monthlySellRemaining|currency:\'\':2}} {{account.limits.currency}}\n        </ion-note>\n      </ion-item>\n      <ion-item>\n        <span>Buy/Sell Disabled (pending first transaction)</span>\n        <ion-note item-end>\n          {{account.limits.transactDisabledPendingFirstTransaction}}\n        </ion-note>\n      </ion-item>\n    </div>\n\n    <ion-item-divider>\n      Account\n    </ion-item-divider>\n\n    <button ion-item (click)="revokeToken()">\n      <span class="assertive">Log out</span>\n    </button>\n  </ion-list>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/glidera/glidera-settings/glidera-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__providers_glidera_glidera__["a" /* GlideraProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], GlideraSettingsPage);

//# sourceMappingURL=glidera-settings.js.map

/***/ }),

/***/ 828:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MercadoLibreSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mercado_libre_card_details_mercado_libre_card_details__ = __webpack_require__(353);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_mercado_libre_mercado_libre__ = __webpack_require__(143);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Pages

// Providers




let MercadoLibreSettingsPage = class MercadoLibreSettingsPage {
    constructor(configProvider, homeIntegrationsProvider, logger, mercadoLibreProvider, modalCtrl) {
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.logger = logger;
        this.mercadoLibreProvider = mercadoLibreProvider;
        this.modalCtrl = modalCtrl;
        this.serviceName = 'mercadolibre';
        this.service = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
        this.init();
    }
    init() {
        this.mercadoLibreProvider.getPendingGiftCards((err, gcds) => {
            if (err)
                this.logger.error(err);
            this.filterArchivedGiftCards(gcds);
            this.showArchivedCards = !__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](this.archivedGiftCards);
        });
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
    filterArchivedGiftCards(giftCards) {
        this.archivedGiftCards = __WEBPACK_IMPORTED_MODULE_2_lodash__["pickBy"](giftCards, gcdValue => {
            return gcdValue.archived;
        });
    }
    openCardModal(card) {
        this.card = card;
        let modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__mercado_libre_card_details_mercado_libre_card_details__["a" /* MercadoLibreCardDetailsPage */], {
            card: this.card
        });
        modal.present();
        modal.onDidDismiss(() => {
            this.init();
        });
    }
};
MercadoLibreSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-mercado-libre-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre-settings/mercado-libre-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Mercado Livre Brazil Gift Cards</ion-title>\n  </ion-navbar>\n</ion-header>\n\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <ion-icon item-start>\n        <img width="60" src="assets/img/mercado-libre/giftcard-pt.svg" alt="Mercado Livre Brazil Gift Card" />\n      </ion-icon>\n      <h2>Mercado Livre Brazil</h2>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n    </ion-item>\n\n    <ion-item-divider *ngIf="showArchivedCards">{{\'Your Archived Gift Cards\'|translate}}</ion-item-divider>\n    <button ion-item *ngFor="let item of (archivedGiftCards | keys : \'date\') | orderBy : [\'-order\']" (click)="openCardModal(item.value)">\n      <div class="mercado-libre-card">\n        <img src="assets/img/mercado-libre/meli-card-24px.png" alt="" class="avatar">\n        <div class="card-info">\n          <div class="amount">\n            <h2 *ngIf="item.value.amount">\n              {{item.value.amount | currency : \'$ \' : 2}} {{item.value.currency}}\n            </h2>\n          </div>\n          <span class="dark">{{item.value.date | amTimeAgo}}</span>\n        </div>\n      </div>\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/mercado-libre/mercado-libre-settings/mercado-libre-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_mercado_libre_mercado_libre__["a" /* MercadoLibreProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["j" /* ModalController */]])
], MercadoLibreSettingsPage);

//# sourceMappingURL=mercado-libre-settings.js.map

/***/ }),

/***/ 829:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ShapeshiftSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_home_integrations_home_integrations__ = __webpack_require__(54);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// Providers


let ShapeshiftSettingsPage = class ShapeshiftSettingsPage {
    constructor(configProvider, homeIntegrationsProvider) {
        this.configProvider = configProvider;
        this.homeIntegrationsProvider = homeIntegrationsProvider;
        this.serviceName = 'shapeshift';
        this.service = __WEBPACK_IMPORTED_MODULE_1_lodash__["filter"](this.homeIntegrationsProvider.get(), {
            name: this.serviceName
        });
        this.showInHome = !!this.service[0].show;
    }
    showInHomeSwitch() {
        let opts = {
            showIntegration: { [this.serviceName]: this.showInHome }
        };
        this.homeIntegrationsProvider.updateConfig(this.serviceName, this.showInHome);
        this.configProvider.set(opts);
    }
};
ShapeshiftSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-shapeshift-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-settings/shapeshift-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>ShapeShift</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Show in Home\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="showInHome" (ionChange)="showInHomeSwitch()"></ion-toggle>\n    </ion-item>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/integrations/shapeshift/shapeshift-settings/shapeshift-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_home_integrations_home_integrations__["a" /* HomeIntegrationsProvider */]])
], ShapeshiftSettingsPage);

//# sourceMappingURL=shapeshift-settings.js.map

/***/ }),

/***/ 831:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AboutPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__session_log_session_log__ = __webpack_require__(832);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// pages

// providers



let AboutPage = class AboutPage {
    constructor(navCtrl, appProvider, logger, externalLinkProvider, replaceParametersProvider, translate) {
        this.navCtrl = navCtrl;
        this.appProvider = appProvider;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
    }
    ionViewDidLoad() {
        this.logger.debug('ionViewDidLoad AboutPage');
        this.commitHash = this.appProvider.info.commitHash;
        this.version = this.appProvider.info.version;
        this.title = this.replaceParametersProvider.replace(this.translate.instant('About {{appName}}'), { appName: this.appProvider.info.nameCase });
    }
    openExternalLink() {
        let url = 'https://github.com/bitpay/' +
            this.appProvider.info.gitHubRepoName +
            '/tree/' +
            this.appProvider.info.commitHash +
            '';
        let optIn = true;
        let title = this.translate.instant('Open GitHub Project');
        let message = this.translate.instant('You can see the latest developments and contribute to this open source app by visiting our project on GitHub.');
        let okText = this.translate.instant('Open GitHub');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openTermsOfUse() {
        let url = 'https://bitpay.com/about/terms#wallet';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Wallet Terms of Use');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openPrivacyPolicy() {
        let url = 'https://bitpay.com/about/privacy';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Privacy Policy');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    openSessionLog() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__session_log_session_log__["a" /* SessionLogPage */]);
    }
};
AboutPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-about',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/about/about.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{title}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item-divider>{{\'Release information\'| translate}}</ion-item-divider>\n    <ion-item>\n      <ion-icon class="custom-icon" name="ios-download-outline" item-start></ion-icon>\n      {{\'Version\' | translate}}\n      <ion-note item-end>\n        v{{version}}\n      </ion-note>\n    </ion-item>\n    <ion-item class="commit-hash" (click)="openExternalLink()">\n      <ion-icon class="custom-icon" name="logo-github" item-start></ion-icon>\n      Commit hash\n      <ion-note item-end>\n        #{{commitHash}}\n      </ion-note>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item (click)="openTermsOfUse()">\n      <ion-icon class="custom-icon" name="ios-list-box-outline" item-start></ion-icon>\n      {{\'Terms of Use\' | translate }}\n    </button>\n    <button ion-item (click)="openPrivacyPolicy()">\n      <ion-icon class="custom-icon" name="ios-lock-outline" item-start></ion-icon>\n      {{\'Privacy Policy\' | translate }}\n    </button>\n    <button ion-item (click)="openSessionLog()">\n      <ion-icon class="custom-icon" name="ios-copy-outline" item-start></ion-icon>\n      {{ \'Session log\' | translate }}\n    </button>\n  </ion-list>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/about/about.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], AboutPage);

//# sourceMappingURL=about.js.map

/***/ }),

/***/ 832:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SessionLogPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};




// native

// providers





let SessionLogPage = class SessionLogPage {
    constructor(dom, configProvider, logger, socialSharing, actionSheetCtrl, toastCtrl, platformProvider, translate, popupProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.socialSharing = socialSharing;
        this.actionSheetCtrl = actionSheetCtrl;
        this.toastCtrl = toastCtrl;
        this.platformProvider = platformProvider;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.dom = dom;
        this.config = this.configProvider.get();
        this.isCordova = this.platformProvider.isCordova;
        let logLevels = this.logger.getLevels();
        this.logOptions = __WEBPACK_IMPORTED_MODULE_9_lodash__["keyBy"](logLevels, 'weight');
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad SessionLogPage');
    }
    ionViewWillEnter() {
        let selectedLevel = __WEBPACK_IMPORTED_MODULE_9_lodash__["has"](this.config, 'log.weight')
            ? this.logger.getWeight(this.config.log.weight)
            : this.logger.getDefaultWeight();
        this.filterValue = selectedLevel.weight;
        this.setOptionSelected(selectedLevel.weight);
        this.filterLogs(selectedLevel.weight);
    }
    filterLogs(weight) {
        this.filteredLogs = this.logger.get(weight);
    }
    setOptionSelected(weight) {
        this.filterLogs(weight);
        let opts = {
            log: {
                weight
            }
        };
        this.configProvider.set(opts);
    }
    prepareLogs() {
        let log = 'Sqoin Session Logs\n Be careful, this could contain sensitive private data\n\n';
        log += '\n\n';
        log += this.logger
            .get()
            .map(v => {
            return '[' + v.timestamp + '][' + v.level + ']' + v.msg;
        })
            .join('\n');
        return log;
    }
    copyToClipboard() {
        let textarea = this.dom.createElement('textarea');
        this.dom.body.appendChild(textarea);
        textarea.value = this.prepareLogs();
        textarea.select();
        this.dom.execCommand('copy');
        let message = this.translate.instant('Copied to clipboard');
        let showSuccess = this.toastCtrl.create({
            message,
            duration: 1000
        });
        showSuccess.present();
    }
    sendLogs() {
        let body = this.prepareLogs();
        this.socialSharing.shareViaEmail(body, 'Copay Logs', null, // TO: must be null or an array
        null, // CC: must be null or an array
        null, // BCC: must be null or an array
        null // FILES: can be null, a string, or an array
        );
    }
    showOptionsMenu() {
        let copyText = this.translate.instant('Copy to clipboard');
        let emailText = this.translate.instant('Send by email');
        let button = [];
        if (this.isCordova) {
            button = [
                {
                    text: emailText,
                    handler: () => {
                        this.showWarningModal();
                    }
                }
            ];
        }
        else {
            button = [
                {
                    text: copyText,
                    handler: () => {
                        this.showWarningModal();
                    }
                }
            ];
        }
        let actionSheet = this.actionSheetCtrl.create({
            title: '',
            buttons: button
        });
        actionSheet.present();
    }
    showWarningModal() {
        const sessionLogWarningModal = this.popupProvider.createMiniModal('sensitive-info');
        sessionLogWarningModal.present();
        sessionLogWarningModal.onDidDismiss(response => {
            if (response)
                this.isCordova ? this.sendLogs() : this.copyToClipboard();
        });
    }
};
SessionLogPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-session-log',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/about/session-log/session-log.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Session Log\' | translate}}</ion-title>\n    <ion-buttons right>\n      <button (click)="showOptionsMenu()" ion-button icon-only>\n        <ion-icon name="more"></ion-icon>\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div *ngIf="filteredLogs && filteredLogs.length == 0" class="no-entries-message">\n    <span translate>No entries for this log level</span>.\n  </div>\n  <ion-list>\n    <ion-item class="log-entry">\n      <div *ngIf="filteredLogs && filteredLogs.length > 0">\n        <div *ngFor="let l of filteredLogs">\n          <span [ngClass]="{\'energized\': l.level==\'warn\', \'dark\': l.level==\'debug\', \'positive\': l.level==\'info\', \'assertive\': l.level==\'error\'}">\n            <span class="log-timestamp">[{{l.timestamp}}]</span>\n            <span class="log-level">[{{l.level}}]</span> {{l.msg}}\n          </span>\n        </div>\n      </div>\n    </ion-item>\n  </ion-list>\n</ion-content>\n<ion-footer>\n  <ion-toolbar>\n    <div class="filter-container">\n      <div class="labels">\n        <div *ngFor="let option of logOptions | keys" [ngClass]="{\'info-label\': option.value.weight==3}">{{option.value.label}}</div>\n      </div>\n      <ion-range min="1" max="4" step="1" snaps="true" color="secondary" [(ngModel)]="filterValue" (ionChange)="setOptionSelected(filterValue)"></ion-range>\n    </div>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/about/session-log/session-log.html"*/
    }),
    __param(0, Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Inject"])(__WEBPACK_IMPORTED_MODULE_1__angular_platform_browser__["b" /* DOCUMENT */])),
    __metadata("design:paramtypes", [Document,
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["a" /* ActionSheetController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_popup_popup__["a" /* PopupProvider */]])
], SessionLogPage);

//# sourceMappingURL=session-log.js.map

/***/ }),

/***/ 833:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__add_add__ = __webpack_require__(190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__view_view__ = __webpack_require__(834);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};







let AddressbookPage = class AddressbookPage {
    constructor(navCtrl, navParams, alertCtrl, logger, addressbookProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.alertCtrl = alertCtrl;
        this.logger = logger;
        this.addressbookProvider = addressbookProvider;
        this.cache = false;
        this.addressbook = [];
        this.filteredAddressbook = [];
        this.initAddressbook();
    }
    ionViewDidEnter() {
        if (this.cache)
            this.initAddressbook();
        this.cache = true;
    }
    initAddressbook() {
        this.addressbookProvider
            .list()
            .then(addressBook => {
            this.isEmptyList = __WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](addressBook);
            let contacts = [];
            __WEBPACK_IMPORTED_MODULE_2_lodash__["each"](addressBook, (contact, k) => {
                contacts.push({
                    name: __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](contact) ? contact.name : contact,
                    address: k,
                    email: __WEBPACK_IMPORTED_MODULE_2_lodash__["isObject"](contact) ? contact.email : null
                });
            });
            this.addressbook = __WEBPACK_IMPORTED_MODULE_2_lodash__["clone"](contacts);
            this.filteredAddressbook = __WEBPACK_IMPORTED_MODULE_2_lodash__["clone"](this.addressbook);
        })
            .catch(err => {
            this.logger.error(err);
            let alertError = this.alertCtrl.create({
                title: err,
                buttons: [
                    {
                        text: 'Go back',
                        handler: () => {
                            this.navCtrl.pop();
                        }
                    }
                ]
            });
            alertError.present();
        });
    }
    addEntry() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__add_add__["a" /* AddressbookAddPage */]);
    }
    viewEntry(contact) {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__view_view__["a" /* AddressbookViewPage */], { contact });
    }
    getItems(event) {
        // set val to the value of the searchbar
        let val = event.target.value;
        // if the value is an empty string don't filter the items
        if (val && val.trim() != '') {
            let result = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.addressbook, item => {
                let name = item['name'];
                return __WEBPACK_IMPORTED_MODULE_2_lodash__["includes"](name.toLowerCase(), val.toLowerCase());
            });
            this.filteredAddressbook = result;
        }
        else {
            // Reset items back to all of the items
            this.initAddressbook();
        }
    }
};
AddressbookPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-addressbook',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/addressbook.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>{{ \'Address Book\' | translate }}</ion-title>\n    <ion-buttons *ngIf="!isEmptyList" right>\n      <button ion-button (click)="addEntry()">\n        {{\'Add\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n\n</ion-header>\n\n<ion-content>\n\n  <div class="zero-state" *ngIf="isEmptyList">\n    <ion-icon class="zero-state-icon">\n      <img class="svg" src="assets/img/address-book-add.svg" />\n    </ion-icon>\n    <div class="zero-state-heading" translate>No contacts yet</div>\n    <div class="zero-state-description" translate>Get started by adding your first one.</div>\n    <button ion-button class="button-standard" (click)="addEntry()">\n      {{\'Add Contact\' | translate}}\n    </button>\n  </div>\n\n  <div *ngIf="!isEmptyList">\n    <ion-searchbar placeholder="{{\'Search a contact\' | translate}}" (ionInput)="getItems($event)"></ion-searchbar>\n    <ion-list>\n      <button class="contact" ion-item *ngFor="let entry of filteredAddressbook" (click)="viewEntry(entry)">\n        <gravatar [name]="entry.name" [height]="30" [width]="30" [email]="entry.email"></gravatar>\n        <div>\n          <div clss="item-title">{{ entry.name }}</div>\n          <div class="item-subtitle">{{ entry.address }}</div>\n        </div>\n      </button>\n    </ion-list>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/addressbook.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_address_book_address_book__["a" /* AddressBookProvider */]])
], AddressbookPage);

//# sourceMappingURL=addressbook.js.map

/***/ }),

/***/ 834:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressbookViewPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pages_send_amount_amount__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_address_address__ = __webpack_require__(254);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Pages

// Providers




let AddressbookViewPage = class AddressbookViewPage {
    constructor(addressBookProvider, addressProvider, bwcProvider, navCtrl, navParams, popupProvider, translate) {
        this.addressBookProvider = addressBookProvider;
        this.addressProvider = addressProvider;
        this.bwcProvider = bwcProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.translate = translate;
        this.bitcoreCash = this.bwcProvider.getBitcoreCash();
        this.address = this.navParams.data.contact.address;
        this.name = this.navParams.data.contact.name;
        this.email = this.navParams.data.contact.email;
        const cashAddress = this.bitcoreCash.Address.isValid(this.address, 'livenet');
        this.coin = cashAddress ? 'bch' : 'btc';
    }
    ionViewDidLoad() { }
    sendTo() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_3__pages_send_amount_amount__["a" /* AmountPage */], {
            toAddress: this.address,
            name: this.name,
            email: this.email,
            coin: this.coin,
            recipientType: 'contact',
            network: this.addressProvider.validateAddress(this.address).network
        });
    }
    remove(addr) {
        var title = this.translate.instant('Warning!');
        var message = this.translate.instant('Are you sure you want to delete this contact?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (!res)
                return;
            this.addressBookProvider
                .remove(addr)
                .then(() => {
                this.navCtrl.pop();
            })
                .catch(err => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return;
            });
        });
    }
};
AddressbookViewPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-addressbook-view',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/view/view.html"*/'<ion-header no-border>\n  <ion-navbar>\n    <ion-title>{{ name }}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div class="contact-view-header">\n    <gravatar [name]="name" [height]="80" [width]="80" [email]="email"></gravatar>\n  </div>\n  <ion-list>\n    <ion-item>\n      {{\'Name\' | translate}}\n      <ion-note item-end>\n        {{ name }}\n      </ion-note>\n    </ion-item>\n    <ion-item *ngIf="email">\n      {{\'Email\' | translate}}\n      <ion-note item-end>\n        {{ email }}\n      </ion-note>\n    </ion-item>\n    <ion-item copy-to-clipboard="{{ address }}">\n      {{\'Address\' | translate}}\n      <div class="comment ellipsis">\n        {{ address }}\n      </div>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item class="btn-send" (click)="sendTo()">\n      {{\'Send Money\' | translate}}\n    </button>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item class="btn-remove" (click)="remove(address)">\n      {{\'Remove\' | translate}}\n    </button>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/addressbook/view/view.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_address_book_address_book__["a" /* AddressBookProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_address_address__["a" /* AddressProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], AddressbookViewPage);

//# sourceMappingURL=view.js.map

/***/ }),

/***/ 835:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AdvancedPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_config_config__ = __webpack_require__(10);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// providers

let AdvancedPage = class AdvancedPage {
    constructor(configProvider, logger) {
        this.configProvider = configProvider;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AdvancedPage');
    }
    ionViewWillEnter() {
        let config = this.configProvider.get();
        this.spendUnconfirmed = config.wallet.spendUnconfirmed;
        this.recentTransactionsEnabled = config.recentTransactions.enabled;
        this.useLegacyAddress = config.wallet.useLegacyAddress;
    }
    spendUnconfirmedChange() {
        let opts = {
            wallet: {
                spendUnconfirmed: this.spendUnconfirmed
            }
        };
        this.configProvider.set(opts);
    }
    recentTransactionsChange() {
        let opts = {
            recentTransactions: {
                enabled: this.recentTransactionsEnabled
            }
        };
        this.configProvider.set(opts);
    }
    useLegacyAddressChange() {
        let opts = {
            wallet: {
                useLegacyAddress: this.useLegacyAddress
            }
        };
        this.configProvider.set(opts);
    }
};
AdvancedPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-advanced',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/advanced/advanced.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Advanced\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item>\n      <ion-label>{{\'Use Unconfirmed Funds\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="spendUnconfirmed" (ionChange)="spendUnconfirmedChange()"></ion-toggle>\n    </ion-item>\n    <ion-item-divider>\n      <span translate>If enabled, wallets will also try to spend unconfirmed funds.</span>\n    </ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Use Bastoji Cash Sqoin Style Addresses\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="useLegacyAddress" (ionChange)="useLegacyAddressChange()"></ion-toggle>\n    </ion-item>\n    <ion-item-divider>\n      <span translate>If enabled, Bastoji Cash addresses will be shown using Sqoin style address, and not the new cashaddr format.</span>\n    </ion-item-divider>\n    <ion-item>\n      <ion-label>{{\'Recent Transaction Card\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="recentTransactionsEnabled" (ionChange)="recentTransactionsChange()"></ion-toggle>\n    </ion-item>\n    <ion-item-divider>\n      <span translate>\n        If enabled, the Recent Transactions card - a list of transactions occuring across all wallets - will appear in the Home tab.\n      </span>\n    </ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/advanced/advanced.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_config_config__["a" /* ConfigProvider */], __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */]])
], AdvancedPage);

//# sourceMappingURL=advanced.js.map

/***/ }),

/***/ 836:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AltCurrencyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_rate_rate__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers






let AltCurrencyPage = class AltCurrencyPage {
    constructor(configProvider, logger, navCtrl, rate, profileProvider, persistenceProvider, walletProvider) {
        this.configProvider = configProvider;
        this.logger = logger;
        this.navCtrl = navCtrl;
        this.rate = rate;
        this.profileProvider = profileProvider;
        this.persistenceProvider = persistenceProvider;
        this.walletProvider = walletProvider;
        this.PAGE_COUNTER = 3;
        this.SHOW_LIMIT = 10;
        this.completeAlternativeList = [];
        this.altCurrencyList = [];
        this.unusedCurrencyList = [
            {
                isoCode: 'LTL'
            },
            {
                isoCode: 'BTJ'
            }
        ];
    }
    ionViewWillEnter() {
        this.rate
            .whenRatesAvailable('btc')
            .then(() => {
            this.completeAlternativeList = this.rate.listAlternatives(true);
            let idx = __WEBPACK_IMPORTED_MODULE_8_lodash__["keyBy"](this.unusedCurrencyList, 'isoCode');
            let idx2 = __WEBPACK_IMPORTED_MODULE_8_lodash__["keyBy"](this.lastUsedAltCurrencyList, 'isoCode');
            this.completeAlternativeList = __WEBPACK_IMPORTED_MODULE_8_lodash__["reject"](this.completeAlternativeList, c => {
                return idx[c.isoCode] || idx2[c.isoCode];
            });
            this.altCurrencyList = this.completeAlternativeList.slice(0, 20);
        })
            .catch(err => {
            this.logger.error(err);
        });
        let config = this.configProvider.get();
        this.currentCurrency = config.wallet.settings.alternativeIsoCode;
        this.persistenceProvider
            .getLastCurrencyUsed()
            .then(lastUsedAltCurrency => {
            this.lastUsedAltCurrencyList = lastUsedAltCurrency
                ? lastUsedAltCurrency
                : [];
        })
            .catch(err => {
            this.logger.error(err);
        });
    }
    loadAltCurrencies(loading) {
        if (this.altCurrencyList.length === this.completeAlternativeList.length) {
            loading.complete();
            return;
        }
        setTimeout(() => {
            this.altCurrencyList = this.completeAlternativeList.slice(0, this.PAGE_COUNTER * this.SHOW_LIMIT);
            this.PAGE_COUNTER++;
            loading.complete();
        }, 300);
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad AltCurrencyPage');
    }
    save(newAltCurrency) {
        var opts = {
            wallet: {
                settings: {
                    alternativeName: newAltCurrency.name,
                    alternativeIsoCode: newAltCurrency.isoCode
                }
            }
        };
        this.configProvider.set(opts);
        this.saveLastUsed(newAltCurrency);
        this.walletProvider.updateRemotePreferences(this.profileProvider.getWallets());
        this.navCtrl.pop();
    }
    saveLastUsed(newAltCurrency) {
        this.lastUsedAltCurrencyList.unshift(newAltCurrency);
        this.lastUsedAltCurrencyList = __WEBPACK_IMPORTED_MODULE_8_lodash__["uniqBy"](this.lastUsedAltCurrencyList, 'isoCode');
        this.lastUsedAltCurrencyList = this.lastUsedAltCurrencyList.slice(0, 3);
        this.persistenceProvider
            .setLastCurrencyUsed(JSON.stringify(this.lastUsedAltCurrencyList))
            .then(() => { });
    }
    findCurrency(searchedAltCurrency) {
        this.altCurrencyList = __WEBPACK_IMPORTED_MODULE_8_lodash__["filter"](this.completeAlternativeList, item => {
            var val = item.name;
            var val2 = item.isoCode;
            return (__WEBPACK_IMPORTED_MODULE_8_lodash__["includes"](val.toLowerCase(), searchedAltCurrency.toLowerCase()) ||
                __WEBPACK_IMPORTED_MODULE_8_lodash__["includes"](val2.toLowerCase(), searchedAltCurrency.toLowerCase()));
        });
    }
};
AltCurrencyPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-alt-currency',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/alt-currency/alt-currency.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Alternative currency\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-searchbar placeholder="{{\'Search your currency\' | translate}}" [(ngModel)]="searchedAltCurrency" (ngModelChange)="findCurrency(searchedAltCurrency)"></ion-searchbar>\n  <ion-list>\n    <ion-item *ngFor="let lastUsedAltCurrency of lastUsedAltCurrencyList" (click)="save(lastUsedAltCurrency)">\n      {{ lastUsedAltCurrency.name }}\n      <span item-end>{{lastUsedAltCurrency.isoCode}}</span>\n    </ion-item>\n  </ion-list>\n  <ion-item-divider *ngIf="altCurrencyList[0] && lastUsedAltCurrencyList[0]"></ion-item-divider>\n  <ion-list>\n    <ion-item *ngFor="let alt of altCurrencyList" (click)="save(alt)">\n      {{ alt.name }}\n      <ion-note item-end>{{alt.isoCode}}</ion-note>\n    </ion-item>\n  </ion-list>\n\n  <ion-spinner class="loading" *ngIf="!altCurrencyList[0]" name="crescent"></ion-spinner>\n\n  <ion-infinite-scroll (ionInfinite)="loadAltCurrencies($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/alt-currency/alt-currency.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_wallet_wallet__["a" /* WalletProvider */]])
], AltCurrencyPage);

//# sourceMappingURL=alt-currency.js.map

/***/ }),

/***/ 837:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeePolicyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_fee_fee__ = __webpack_require__(82);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers


const COIN = 'btc';
const NETWORK = 'livenet';
let FeePolicyPage = class FeePolicyPage {
    constructor(logger, feeProvider, configProvider) {
        this.logger = logger;
        this.feeProvider = feeProvider;
        this.configProvider = configProvider;
        this.feeOpts = this.feeProvider.getFeeOpts();
        delete this.feeOpts['custom']; // Remove custom level
        this.currentFeeLevel = this.feeProvider.getCurrentFeeLevel();
    }
    ionViewDidEnter() {
        this.error = null;
        return this.feeProvider
            .getFeeLevels(COIN)
            .then(data => {
            this.feeLevels = data['levels'];
            this.updateCurrentValues();
        })
            .catch(err => {
            this.logger.error(err);
            this.error = err;
        });
    }
    save() {
        if (__WEBPACK_IMPORTED_MODULE_1_lodash__["isEmpty"](this.currentFeeLevel) ||
            this.currentFeeLevel == this.feeProvider.getCurrentFeeLevel())
            return;
        this.logger.debug('New fee level: ' + this.currentFeeLevel);
        this.updateCurrentValues();
        this.setFee();
    }
    updateCurrentValues() {
        if (__WEBPACK_IMPORTED_MODULE_1_lodash__["isEmpty"](this.feeLevels) || __WEBPACK_IMPORTED_MODULE_1_lodash__["isEmpty"](this.currentFeeLevel))
            return;
        let value = __WEBPACK_IMPORTED_MODULE_1_lodash__["find"](this.feeLevels[NETWORK], {
            level: this.currentFeeLevel
        });
        if (__WEBPACK_IMPORTED_MODULE_1_lodash__["isEmpty"](value))
            return;
        this.feePerSatByte = (value['feePerKb'] / 1000).toFixed();
        this.avgConfirmationTime = value['nbBlocks'] * 10;
    }
    setFee() {
        let opts = {
            wallet: {
                settings: {
                    feeLevel: this.currentFeeLevel
                }
            }
        };
        this.configProvider.set(opts);
    }
};
FeePolicyPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-fee-policy',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/fee-policy/fee-policy.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>\n      {{\'Bastoji Network Fee Policy\'|translate}}\n    </ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n\n  <div class="explanation" padding>\n    <div class="heading" translate>Bastoji transactions include a fee collected by miners on the network.</div>\n    <div class="description" translate>The higher the fee, the greater the incentive a miner has to include that transaction in a block. Current fees are determined based on network load and the selected policy.</div>\n    <div class="estimates">\n      <div>\n        <span translate>Average confirmation time</span>:\n        <span class="fee-minutes" *ngIf="avgConfirmationTime">{{avgConfirmationTime | amDuration: \'minute\'}}</span>\n        <span class="fee-minutes" *ngIf="!avgConfirmationTime && !error">...</span>\n        <span class="fee-minutes error" *ngIf="!avgConfirmationTime && error" translate>Error</span>\n      </div>\n      <div>\n        <span translate>Current fee rate for this policy</span>:\n        <span class="fee-rate" *ngIf="feePerSatByte">{{feePerSatByte}} satoshis/byte</span>\n        <span class="fee-rate" *ngIf="!feePerSatByte && !error">...</span>\n        <span class="fee-rate error" *ngIf="!feePerSatByte && error" translate>Error</span>\n      </div>\n    </div>\n  </div>\n\n  <ion-list radio-group [(ngModel)]="currentFeeLevel" (ionChange)="save()">\n    <ion-item *ngFor="let data of feeOpts | keys">\n      <ion-label>{{data.value}}</ion-label>\n      <ion-radio [value]="data.key"></ion-radio>\n    </ion-item>\n  </ion-list>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/fee-policy/fee-policy.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_fee_fee__["a" /* FeeProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */]])
], FeePolicyPage);

//# sourceMappingURL=fee-policy.js.map

/***/ }),

/***/ 838:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LanguagePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_language_language__ = __webpack_require__(135);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers




let LanguagePage = class LanguagePage {
    constructor(navCtrl, languageProvider, externalLinkProvider, profileProvider, walletProvider, translate) {
        this.navCtrl = navCtrl;
        this.languageProvider = languageProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.translate = translate;
        this.currentLanguage = this.languageProvider.getCurrent();
        this.languages = this.languageProvider.getAvailables();
    }
    openExternalLink() {
        let url = 'https://crowdin.com/project/copay';
        let optIn = true;
        let title = this.translate.instant('Open Translation Community');
        let message = this.translate.instant('You can make contributions by signing up on our Crowdin community translation website. Were looking forward to hearing from you!');
        let okText = this.translate.instant('Open Crowdin');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    save(newLang) {
        this.languageProvider.set(newLang);
        this.navCtrl.pop();
        setTimeout(() => {
            let wallets = this.profileProvider.getWallets();
            this.walletProvider.updateRemotePreferences(wallets);
        }, 1000);
    }
};
LanguagePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-language',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/language/language.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Language\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list radio-group [(ngModel)]="currentLanguage">\n    <ion-item *ngFor="let language of languages">\n      <ion-label>\n        {{ language.name }}\n      </ion-label>\n      <ion-radio (click)="save(language.isoCode)" [value]="language.isoCode"></ion-radio>\n    </ion-item>\n    <ion-item-divider>\n      <div translate>\n        We are always looking for translation contributions! You can make corrections or help to make this app available in your native language by joining our community on Crowdin.\n      </div>\n      <div translate>\n        Don\'t see your language on Crowdin? Contact the Owner on Crowdin! We\'d love to support your language.\n      </div>\n    </ion-item-divider>\n  </ion-list>\n\n  <button ion-button class="button-standard" (click)="openExternalLink()">\n    {{\'Contribute translations\' | translate}}\n  </button>\n  <ion-item-divider></ion-item-divider>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/language/language.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_4__providers_language_language__["a" /* LanguageProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], LanguagePage);

//# sourceMappingURL=language.js.map

/***/ }),

/***/ 839:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return LockPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__pin_pin_modal_pin_modal__ = __webpack_require__(258);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// pages

// providers




let LockPage = class LockPage {
    constructor(configProvider, modalCtrl, touchIdProvider, profileProvider, translate) {
        this.configProvider = configProvider;
        this.modalCtrl = modalCtrl;
        this.touchIdProvider = touchIdProvider;
        this.profileProvider = profileProvider;
        this.translate = translate;
        this.options = [];
        this.checkLockOptions();
    }
    checkLockOptions() {
        this.lockOptions = this.configProvider.get().lock;
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            let needsBackup = this.needsBackup();
            this.options = [
                {
                    label: this.translate.instant('Disabled'),
                    method: 'disabled',
                    enabled: !this.lockOptions.method ||
                        (this.lockOptions.method &&
                            this.lockOptions.method.toLowerCase() == 'disabled'
                            ? true
                            : false),
                    disabled: false
                },
                {
                    label: this.translate.instant('PIN'),
                    method: 'pin',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'pin'
                        ? true
                        : false,
                    disabled: needsBackup
                },
                {
                    label: this.translate.instant('Fingerprint'),
                    method: 'fingerprint',
                    enabled: this.lockOptions.method &&
                        this.lockOptions.method.toLowerCase() == 'fingerprint'
                        ? true
                        : false,
                    disabled: !isAvailable || needsBackup
                }
            ];
        });
    }
    select(method) {
        switch (method) {
            case 'disabled':
                this.removeLockMethod();
                break;
            case 'pin':
                this.openPinModal('pinSetUp');
                break;
            case 'fingerprint':
                this.lockByFingerprint();
                break;
        }
    }
    removeLockMethod() {
        let lock = { method: 'disabled', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    openPinModal(action) {
        const modal = this.modalCtrl.create(__WEBPACK_IMPORTED_MODULE_3__pin_pin_modal_pin_modal__["a" /* PinModalPage */], { action }, { cssClass: 'fullscreen-modal' });
        modal.present();
        modal.onDidDismiss(() => {
            this.checkLockOptions();
        });
    }
    lockByFingerprint() {
        let lock = { method: 'fingerprint', value: null, bannedUntil: null };
        this.configProvider.set({ lock });
        this.checkLockOptions();
    }
    needsBackup() {
        let wallets = this.profileProvider.getWallets();
        let singleLivenetWallet = wallets.length == 1 &&
            wallets[0].network == 'livenet' &&
            wallets[0].needsBackup;
        let atLeastOneLivenetWallet = __WEBPACK_IMPORTED_MODULE_7_lodash__["find"](wallets, w => {
            return w.network == 'livenet' && w.needsBackup;
        });
        if (singleLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Backup your wallet before using this function');
            return true;
        }
        else if (atLeastOneLivenetWallet) {
            this.needsBackupMsg = this.translate.instant('Backup all your wallets before using this function');
            return true;
        }
        else {
            this.needsBackupMsg = null;
            return false;
        }
    }
};
LockPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-lock',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/lock/lock.html"*/'<ion-header>\n\n  <ion-navbar>\n    <ion-title>{{\'Lock\'|translate}}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n<ion-content>\n  <ion-list radio-group>\n    <ion-item *ngFor="let opt of options">\n      <ion-label>{{opt.label}}</ion-label>\n      <ion-radio (click)="select(opt.method)" value="{{opt.method}}" checked="{{opt.enabled}}" disabled="{{opt.disabled}}"></ion-radio>\n    </ion-item>\n  </ion-list>\n\n  <div *ngIf="needsBackupMsg" class="msg-container" text-wrap>\n    <span class="assertive">{{needsBackupMsg}}</span>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/lock/lock.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["j" /* ModalController */],
        __WEBPACK_IMPORTED_MODULE_6__providers_touchid_touchid__["b" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], LockPage);

//# sourceMappingURL=lock.js.map

/***/ }),

/***/ 840:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return NotificationsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__validators_email__ = __webpack_require__(1189);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers







// validators

let NotificationsPage = class NotificationsPage {
    constructor(navCtrl, formBuilder, configProvider, appProvider, platformProvider, pushProvider, emailProvider, externalLinkProvider, logger, persistenceProvider, translate) {
        this.navCtrl = navCtrl;
        this.formBuilder = formBuilder;
        this.configProvider = configProvider;
        this.appProvider = appProvider;
        this.platformProvider = platformProvider;
        this.pushProvider = pushProvider;
        this.emailProvider = emailProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.emailForm = this.formBuilder.group({
            email: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([
                    __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required,
                    new __WEBPACK_IMPORTED_MODULE_12__validators_email__["a" /* EmailValidator */](configProvider, emailProvider).isValid
                ])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad NotificationsPage');
        this.updateConfig();
    }
    updateConfig() {
        let config = this.configProvider.get();
        this.appName = this.appProvider.info.nameCase;
        this.usePushNotifications = this.platformProvider.isCordova;
        this.isIOSApp =
            this.platformProvider.isIOS && this.platformProvider.isCordova;
        this.pushNotifications = config.pushNotificationsEnabled;
        this.confirmedTxsNotifications = config.confirmedTxsNotifications
            ? config.confirmedTxsNotifications.enabled
            : false;
        this.emailForm.setValue({
            email: this.emailProvider.getEmailIfEnabled(config) || ''
        });
        this.emailNotifications = config.emailNotifications
            ? config.emailNotifications.enabled
            : false;
    }
    pushNotificationsChange() {
        let opts = {
            pushNotificationsEnabled: this.pushNotifications
        };
        this.configProvider.set(opts);
        if (opts.pushNotificationsEnabled)
            this.pushProvider.init();
        else
            this.pushProvider.disable();
    }
    confirmedTxsNotificationsChange() {
        let opts = {
            confirmedTxsNotifications: {
                enabled: this.confirmedTxsNotifications
            }
        };
        this.configProvider.set(opts);
    }
    emailNotificationsChange() {
        let opts = {
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        };
        this.emailProvider.updateEmail(opts);
    }
    saveEmail() {
        this.persistenceProvider.setEmailLawCompliance('accepted');
        this.emailProvider.updateEmail({
            enabled: this.emailNotifications,
            email: this.emailForm.value.email
        });
        this.navCtrl.pop();
    }
    openPrivacyPolicy() {
        let url = 'https://bitpay.com/about/privacy';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('View Privacy Policy');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
NotificationsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-notifications',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/notifications/notifications.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Notifications\' | translate}}</ion-title>\n  </ion-navbar>\n\n</ion-header>\n\n\n<ion-content>\n  <ion-item-divider></ion-item-divider>\n  <ion-list>\n    <div *ngIf="usePushNotifications">\n      <ion-item>\n        <ion-label>{{ \'Enable push notifications\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="pushNotifications" (ionChange)="pushNotificationsChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n    <ion-item-divider *ngIf="!usePushNotifications && isIOSApp">\n      <span translate>\n        Push notifications for {{appName}} are currently disabled. Enable them in the Settings app.\n      </span>\n    </ion-item-divider>\n\n    <div *ngIf="usePushNotifications && pushNotifications">\n      <ion-item>\n        <ion-label>{{ \'Notify me when transactions are confirmed\' | translate }}</ion-label>\n        <ion-toggle [(ngModel)]="confirmedTxsNotifications" (ionChange)="confirmedTxsNotificationsChange()"></ion-toggle>\n      </ion-item>\n    </div>\n\n\n    <ion-item>\n      <ion-label>{{ \'Enable email notifications\' | translate }}</ion-label>\n      <ion-toggle [(ngModel)]="emailNotifications" (ionChange)="emailNotificationsChange()"></ion-toggle>\n    </ion-item>\n\n    <div *ngIf="emailNotifications">\n      <ion-item-divider>\n        <span translate>\n          By providing your email address, you give explicit consent to BitPay to use your email address to send you email notifications about payments.\n        </span> \n        <a class="externalLink" (click)="openPrivacyPolicy()" translate>View Privacy Policy</a>\n      </ion-item-divider>\n\n      <form [formGroup]="emailForm">\n        <ion-item>\n          <ion-label stacked>{{ \'Email\' | translate }}</ion-label>\n          <ion-input formControlName="email" type="email"></ion-input>\n        </ion-item>\n        <div text-center>\n          <button ion-button class="button-standard" (click)="saveEmail()" [disabled]="emailForm.invalid">\n            {{\'Save\' | translate}}\n          </button>\n        </div>\n      </form>\n    </div>\n  </ion-list>\n\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/notifications/notifications.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
], NotificationsPage);

//# sourceMappingURL=notifications.js.map

/***/ }),

/***/ 841:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSettingsPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__ = __webpack_require__(114);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__backup_backup_warning_backup_warning__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__wallet_color_wallet_color__ = __webpack_require__(842);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__wallet_name_wallet_name__ = __webpack_require__(843);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__wallet_settings_advanced_wallet_settings_advanced__ = __webpack_require__(844);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers





// pages




let WalletSettingsPage = class WalletSettingsPage {
    constructor(profileProvider, logger, walletProvider, externalLinkProvider, configProvider, navCtrl, navParams, touchIdProvider, translate) {
        this.profileProvider = profileProvider;
        this.logger = logger;
        this.walletProvider = walletProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.configProvider = configProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.touchIdProvider = touchIdProvider;
        this.translate = translate;
        this.deleted = false;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletSettingsPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.walletName = this.wallet.name;
        this.canSign = this.wallet.canSign();
        this.needsBackup = this.wallet.needsBackup;
        this.hiddenBalance = this.wallet.balanceHidden;
        this.encryptEnabled = this.walletProvider.isEncrypted(this.wallet);
        this.touchIdProvider.isAvailable().then((isAvailable) => {
            this.touchIdAvailable = isAvailable;
        });
        this.config = this.configProvider.get();
        this.touchIdEnabled = this.config.touchIdFor
            ? this.config.touchIdFor[this.wallet.credentials.walletId]
            : null;
        this.touchIdPrevValue = this.touchIdEnabled;
        if (this.wallet.credentials &&
            !this.wallet.credentials.mnemonicEncrypted &&
            !this.wallet.credentials.mnemonic) {
            this.deleted = true;
        }
    }
    hiddenBalanceChange() {
        this.profileProvider.toggleHideBalanceFlag(this.wallet.credentials.walletId);
    }
    encryptChange() {
        if (!this.wallet)
            return;
        let val = this.encryptEnabled;
        if (val && !this.walletProvider.isEncrypted(this.wallet)) {
            this.logger.debug('Encrypting private key for', this.wallet.name);
            this.walletProvider
                .encrypt(this.wallet)
                .then(() => {
                this.profileProvider.updateCredentials(JSON.parse(this.wallet.export()));
                this.logger.debug('Wallet encrypted');
            })
                .catch(err => {
                this.logger.warn('Could not encrypt wallet', err);
                this.encryptEnabled = false;
            });
        }
        else if (!val && this.walletProvider.isEncrypted(this.wallet)) {
            this.walletProvider
                .decrypt(this.wallet)
                .then(() => {
                this.profileProvider.updateCredentials(JSON.parse(this.wallet.export()));
                this.logger.debug('Wallet decrypted');
            })
                .catch(err => {
                this.logger.warn('Could not decrypt wallet', err);
                this.encryptEnabled = true;
            });
        }
    }
    openSupportSpendingPassword() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/360000244506-What-Does-a-Spending-Password-Do-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Read more in our support page');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
    touchIdChange() {
        if (this.touchIdPrevValue == this.touchIdEnabled)
            return;
        let newStatus = this.touchIdEnabled;
        this.walletProvider
            .setTouchId(this.wallet, newStatus)
            .then(() => {
            this.touchIdPrevValue = this.touchIdEnabled;
            this.logger.debug('Touch Id status changed: ' + newStatus);
        })
            .catch(() => {
            this.touchIdEnabled = this.touchIdPrevValue;
        });
    }
    openAdvancedSettings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__wallet_settings_advanced_wallet_settings_advanced__["a" /* WalletSettingsAdvancedPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletName() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__wallet_name_wallet_name__["a" /* WalletNamePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletColor() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__wallet_color_wallet_color__["a" /* WalletColorPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openBackupSettings() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__backup_backup_warning_backup_warning__["a" /* BackupWarningPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
};
WalletSettingsPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-settings',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Settings\'|translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item (click)="openWalletName()">\n      <div translate float-left>Name</div>\n      <div text-end text-wrap ion-text color="light-grey">\n        {{walletName}}\n      </div>\n    </button>\n    <button ion-item (click)="openWalletColor()">\n      <span translate>Color</span>\n      <span item-end [ngStyle]="{\'background-color\': wallet?.color}" class="settings-color-block"></span>\n    </button>\n    <ion-item>\n      <ion-label>{{\'Hide Balance\' | translate}}</ion-label>\n      <ion-toggle [(ngModel)]="hiddenBalance" (ionChange)="hiddenBalanceChange()"></ion-toggle>\n    </ion-item>\n    <ion-item-divider>{{\'Security\' | translate}}</ion-item-divider>\n    <button ion-item (click)="openBackupSettings()">\n      <span translate>Backup</span>\n      <ion-note *ngIf="needsBackup" class="wallet-warning" item-end>\n        {{\'Needs backup\' | translate}}\n      </ion-note>\n    </button>\n    <div *ngIf="canSign">\n      <ion-item>\n        <ion-label>{{\'Request Encrypt Password\' | translate}}</ion-label>\n        <ion-toggle [(ngModel)]="encryptEnabled" (ionChange)="encryptChange()" [disabled]="(needsBackup || !wallet.isComplete()) && !encryptEnabled"></ion-toggle>\n      </ion-item>\n      <ion-item-divider>\n        <span class="item-text" translate>\n          If enabled, all sensitive information (private key and recovery phrase) and actions (spending and exporting) associated with this wallet will be protected.\n        </span>\n        <a (click)="openSupportSpendingPassword()" translate>Learn more</a>\n      </ion-item-divider>\n    </div>\n    <div *ngIf="canSign && touchIdAvailable">\n      <ion-item>\n        <ion-label [ngClass]="{\'disabled\': needsBackup}">{{\'Request Fingerprint\'| translate}}</ion-label>\n        <ion-toggle [(ngModel)]="touchIdEnabled" (ionChange)="touchIdChange()"></ion-toggle>\n      </ion-item>\n      <ion-item-divider></ion-item-divider>\n    </div>\n    <button ion-item (click)="openAdvancedSettings()">\n      <span translate>More Options</span>\n    </button>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_touchid_touchid__["b" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], WalletSettingsPage);

//# sourceMappingURL=wallet-settings.js.map

/***/ }),

/***/ 842:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletColorPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__ = __webpack_require__(14);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers


let WalletColorPage = class WalletColorPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, logger, events) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.logger = logger;
        this.events = events;
        this.retries = 3;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletColorPage');
    }
    ionViewWillEnter() {
        const COLOR_COUNT = 14;
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.colorCount = Array(COLOR_COUNT)
            .fill(0)
            .map((_, i) => i);
        this.setCurrentColorIndex();
    }
    save(i) {
        let color = this.indexToColor(i);
        if (!color)
            return;
        let opts = {
            colorFor: {}
        };
        opts.colorFor[this.wallet.credentials.walletId] = color;
        this.configProvider.set(opts);
        this.events.publish('wallet:updated', this.wallet.credentials.walletId);
        this.navCtrl.pop();
    }
    setCurrentColorIndex() {
        try {
            this.currentColorIndex = this.colorToIndex(this.wallet.color);
        }
        catch (e) {
            // Wait for DOM to render and try again.
            setTimeout(() => {
                if (this.retries > 0) {
                    this.retries -= 1;
                    this.setCurrentColorIndex();
                }
            }, 100);
        }
    }
    colorToIndex(color) {
        for (let i = 0; i < this.colorCount.length; i++) {
            if (this.indexToColor(i) == color.toLowerCase()) {
                return i;
            }
        }
        return undefined;
    }
    indexToColor(i) {
        // Expect an exception to be thrown if can't getComputedStyle().
        return this.rgb2hex(window.getComputedStyle(document.getElementsByClassName('wallet-color-' + i)[0]).backgroundColor);
    }
    rgb2hex(rgb) {
        rgb = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return rgb && rgb.length === 4
            ? '#' +
                ('0' + parseInt(rgb[1], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[2], 10).toString(16)).slice(-2) +
                ('0' + parseInt(rgb[3], 10).toString(16)).slice(-2)
            : '';
    }
};
WalletColorPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-color',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-color/wallet-color.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Color\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list radio-group [(ngModel)]="currentColorIndex">\n    <ion-item *ngFor="let i of colorCount">\n      <ion-label>\n        <span class="settings-color-block wallet-color-{{i}}"></span>\n      </ion-label>\n      <ion-radio (click)="save(i)" [value]="i"></ion-radio>\n    </ion-item>\n  </ion-list>\n  <ion-item-divider></ion-item-divider>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-color/wallet-color.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */]])
], WalletColorPage);

//# sourceMappingURL=wallet-color.js.map

/***/ }),

/***/ 843:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletNamePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers



let WalletNamePage = class WalletNamePage {
    constructor(profileProvider, navCtrl, navParams, configProvider, formBuilder, events, logger, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.logger = logger;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.walletNameForm = this.formBuilder.group({
            walletName: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletNamePage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.config = this.configProvider.get();
        let alias = this.config.aliasFor &&
            this.config.aliasFor[this.wallet.credentials.walletId];
        this.walletNameForm.value.walletName = alias
            ? alias
            : this.wallet.credentials.walletName;
        this.walletName = this.wallet.credentials.walletName;
        this.description = this.replaceParametersProvider.replace(this.translate.instant('When this wallet was created, it was called "{{walletName}}". You can change the name displayed on this device below.'), { walletName: this.walletName });
    }
    save() {
        let opts = {
            aliasFor: {}
        };
        opts.aliasFor[this.wallet.credentials.walletId] = this.walletNameForm.value.walletName;
        this.configProvider.set(opts);
        this.events.publish('wallet:updated', this.wallet.credentials.walletId);
        this.navCtrl.pop();
    }
};
WalletNamePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-name',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Name\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <ion-list>\n    <ion-item-divider class="settings-explanation">\n      <div class="settings-heading" translate>What do you call this wallet?</div>\n      <div class="settings-description">\n        {{description}}\n      </div>\n    </ion-item-divider>\n    <form [formGroup]="walletNameForm">\n      <ion-item>\n        <ion-label stacked>{{\'Name\' | translate}}</ion-label>\n        <ion-input type="text" formControlName="walletName" [value]="walletNameForm.value.walletName" required></ion-input>\n      </ion-item>\n      <button ion-button class="button-standard" (click)="save()" [disabled]="!walletNameForm.valid">\n        {{\'Save\' | translate}}\n      </button>\n    </form>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-name/wallet-name.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
], WalletNamePage);

//# sourceMappingURL=wallet-name.js.map

/***/ }),

/***/ 844:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletSettingsAdvancedPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bastoji_cash_bastoji_cash__ = __webpack_require__(845);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wallet_addresses_wallet_addresses__ = __webpack_require__(369);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__wallet_delete_wallet_delete__ = __webpack_require__(847);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__wallet_export_wallet_export__ = __webpack_require__(848);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__wallet_information_wallet_information__ = __webpack_require__(850);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__wallet_service_url_wallet_service_url__ = __webpack_require__(852);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__wallet_transaction_history_wallet_transaction_history__ = __webpack_require__(853);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers

// pages







let WalletSettingsAdvancedPage = class WalletSettingsAdvancedPage {
    constructor(profileProvider, navCtrl, navParams, logger) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletSettingsAdvancedPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
    }
    openWalletInformation() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__wallet_information_wallet_information__["a" /* WalletInformationPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletAddresses() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__wallet_addresses_wallet_addresses__["a" /* WalletAddressesPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openExportWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_7__wallet_export_wallet_export__["a" /* WalletExportPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openWalletServiceUrl() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_9__wallet_service_url_wallet_service_url__["a" /* WalletServiceUrlPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openTransactionHistory() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__wallet_transaction_history_wallet_transaction_history__["a" /* WalletTransactionHistoryPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openDeleteWallet() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__wallet_delete_wallet_delete__["a" /* WalletDeletePage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
    openBastojiCashPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__bastoji_cash_bastoji_cash__["a" /* BastojiCashPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
};
WalletSettingsAdvancedPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-settings-advanced',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-settings-advanced.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'More Options\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <button ion-item (click)="openWalletInformation()">\n      <span translate>Wallet Information</span>\n    </button>\n    <button ion-item (click)="openWalletAddresses()">\n      <span translate>Wallet Addresses</span>\n    </button>\n    <button ion-item (click)="openExportWallet()">\n      <span translate>Export Wallet</span>\n    </button>\n    <button ion-item (click)="openWalletServiceUrl()">\n      <span translate>Wallet Service URL</span>\n    </button>\n    <button ion-item (click)="openTransactionHistory()">\n      <span translate>Transaction History</span>\n    </button>\n    <button ion-item *ngIf="wallet && wallet.network == \'livenet\' && wallet.isComplete() && wallet.coin == \'btc\'" (click)="openBastojiCashPage()">\n      <span translate>Duplicate ( Bastoji Cash )</span>\n    </button>\n    <button ion-item (click)="openDeleteWallet()">\n      <span translate>Delete Wallet</span>\n    </button>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-settings-advanced.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], WalletSettingsAdvancedPage);

//# sourceMappingURL=wallet-settings-advanced.js.map

/***/ }),

/***/ 845:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BastojiCashPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// Providers










let BastojiCashPage = class BastojiCashPage {
    constructor(app, walletProvider, profileProvider, txFormatProvider, onGoingProcessProvider, popupProvider, pushNotificationsProvider, externalLinkProvider, bwcErrorProvider, bwcProvider, logger, translate, events, navParams) {
        this.app = app;
        this.walletProvider = walletProvider;
        this.profileProvider = profileProvider;
        this.txFormatProvider = txFormatProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.popupProvider = popupProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.externalLinkProvider = externalLinkProvider;
        this.bwcErrorProvider = bwcErrorProvider;
        this.bwcProvider = bwcProvider;
        this.logger = logger;
        this.translate = translate;
        this.events = events;
        this.navParams = navParams;
        this.errors = this.bwcProvider.getErrors();
    }
    ionViewWillEnter() {
        let wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        // Filter out already duplicated wallets
        let walletsBCH = this.profileProvider.getWallets({
            coin: 'bch',
            network: 'livenet'
        });
        let xPubKeyIndex = __WEBPACK_IMPORTED_MODULE_3_lodash__["keyBy"](walletsBCH, 'credentials.xPubKey');
        if (xPubKeyIndex[wallet.credentials.xPubKey]) {
            wallet.excludeReason = this.translate.instant('Already duplicated');
            this.nonEligibleWallet = wallet;
        }
        else if (wallet.credentials.derivationStrategy != 'BIP44') {
            wallet.excludeReason = this.translate.instant('Non BIP44 wallet');
            this.nonEligibleWallet = wallet;
        }
        else if (!wallet.canSign()) {
            wallet.excludeReason = this.translate.instant('Read only wallet');
            this.nonEligibleWallet = wallet;
        }
        else if (wallet.needsBackup) {
            wallet.excludeReason = this.translate.instant('Needs backup');
            this.nonEligibleWallet = wallet;
        }
        else {
            this.availableWallet = wallet;
        }
        if (!this.availableWallet)
            return;
        this.walletProvider
            .getBalance(this.availableWallet, { coin: 'bch' })
            .then(balance => {
            this.availableWallet.bchBalance = this.txFormatProvider.formatAmountStr('bch', balance.availableAmount);
            this.availableWallet.error = null;
        })
            .catch(err => {
            this.availableWallet.error =
                err === 'WALLET_NOT_REGISTERED'
                    ? this.translate.instant('Wallet not registered')
                    : this.bwcErrorProvider.msg(err);
            this.logger.error(err);
        });
    }
    duplicate(wallet) {
        this.logger.debug('Duplicating wallet for BCH: ' + wallet.id + ': ' + wallet.name);
        let opts = {
            name: wallet.name + '[BCH]',
            m: wallet.m,
            n: wallet.n,
            myName: wallet.credentials.copayerName,
            networkName: wallet.network,
            coin: 'bch',
            walletPrivKey: wallet.credentials.walletPrivKey,
            compliantDerivation: wallet.credentials.compliantDerivation
        };
        const setErr = err => {
            this.bwcErrorProvider.cb(err, 'Could not duplicate').then(errorMsg => {
                this.logger.warn('Duplicate BCH', errorMsg);
                this.popupProvider.ionicAlert(errorMsg, null, 'OK');
                return;
            });
        };
        const importOrCreate = () => {
            return new Promise((resolve, reject) => {
                this.walletProvider
                    .getStatus(wallet, {})
                    .then(status => {
                    opts.singleAddress = status.wallet.singleAddress;
                    // first try to import
                    this.profileProvider
                        .importExtendedPrivateKey(opts.extendedPrivateKey, opts)
                        .then(newWallet => {
                        return resolve({ newWallet });
                    })
                        .catch(err => {
                        if (!(err instanceof this.errors.NOT_AUTHORIZED)) {
                            return reject(err);
                        }
                        // create and store a wallet
                        this.profileProvider
                            .createWallet(opts)
                            .then(newWallet => {
                            return resolve({ newWallet, isNew: true });
                        })
                            .catch(err => {
                            return reject(err);
                        });
                    });
                })
                    .catch(err => {
                    return reject(err);
                });
            });
        };
        // Multisig wallets? add Sqoiners
        function addCopayers(newWallet, isNew, cb) {
            if (!isNew)
                return cb();
            if (wallet.n == 1)
                return cb();
            this.logger.info('Adding sqoiners for BCH wallet config:' + wallet.m + '-' + wallet.n);
            this.walletProvider.copyCopayers(wallet, newWallet, err => {
                if (err) {
                    return cb(err);
                }
                return cb();
            });
        }
        this.walletProvider
            .getKeys(wallet)
            .then(keys => {
            opts.extendedPrivateKey = keys.xPrivKey;
            this.onGoingProcessProvider.set('duplicatingWallet');
            importOrCreate()
                .then(result => {
                let newWallet = result.newWallet;
                let isNew = result.isNew;
                this.walletProvider.updateRemotePreferences(newWallet);
                this.pushNotificationsProvider.updateSubscription(newWallet);
                addCopayers(newWallet, isNew, err => {
                    this.onGoingProcessProvider.clear();
                    if (err) {
                        return setErr(err);
                    }
                    if (isNew) {
                        this.walletProvider.startScan(newWallet);
                    }
                    this.events.publish('status:updated');
                    this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_14__tabs_tabs__["a" /* TabsPage */]);
                });
            })
                .catch(err => {
                this.onGoingProcessProvider.clear();
                setErr(err);
            });
        })
            .catch(err => {
            setErr(err);
        });
    }
    openHelpExternalLink() {
        let url = 'https://support.bitpay.com/hc/en-us/articles/115005019583-How-Can-I-Recover-Bastoji-Cash-BCH-from-My-Wallet-';
        let optIn = true;
        let title = null;
        let message = this.translate.instant('Help and support information is available at the website');
        let okText = this.translate.instant('Open');
        let cancelText = this.translate.instant('Go Back');
        this.externalLinkProvider.open(url, optIn, title, message, okText, cancelText);
    }
};
BastojiCashPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-bastoji-cash',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/bastoji-cash/bastoji-cash.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Bastoji Cash</ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div *ngIf="availableWallet">\n    <ion-item *ngIf="availableWallet">\n      <ion-icon class="item-img" item-start>\n        <img [ngStyle]="{\'background-color\': availableWallet.color}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n      </ion-icon>\n      <div class="item-title">{{availableWallet.name}}</div>\n      <div class="item-subtitle">\n        <span *ngIf="!availableWallet.error">\n          <span class="success" *ngIf="!availableWallet.balanceHidden">\n            {{availableWallet.bchBalance || (\'Checking...\' | translate)}}\n          </span>\n          <span *ngIf="availableWallet.balanceHidden">[\n            <span translate>Balance Hidden</span>]</span>\n          <span class="text-gray" *ngIf="availableWallet.credentials.m > 1">{{availableWallet.credentials.m}}-of-{{availableWallet.credentials.n}}</span>\n        </span>\n        <span *ngIf="availableWallet.error" class="wallet-warning">{{availableWallet.error}}</span>\n      </div>\n      <ion-note item-end>\n        <button ion-button clear (click)="duplicate(availableWallet)">\n          {{\'Duplicate\' | translate}}\n        </button>\n      </ion-note>\n    </ion-item>\n  </div>\n\n  <div *ngIf="nonEligibleWallet">\n    <ion-item-divider>\n      <span translate>Non eligible BTJ wallet</span>\n    </ion-item-divider>\n\n    <ion-item *ngIf="nonEligibleWallet">\n      <ion-icon class="item-img" item-start>\n        <img [ngStyle]="{\'background-color\': \'gray\'}" src="assets/img/icon-wallet.svg" class="icon-wallet" />\n      </ion-icon>\n      <div class="item-title text-disabled">{{nonEligibleWallet.name}}</div>\n      <div class="item-subtitle">\n        <span class="text-disabled">{{nonEligibleWallet.excludeReason}}</span>\n      </div>\n    </ion-item>\n  </div>\n\n  <ion-item-divider></ion-item-divider>\n\n  <button ion-item (click)="openHelpExternalLink()">\n    <span translate>Help &amp; support</span>\n  </button>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/bastoji-cash/bastoji-cash.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_12__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_bwc_error_bwc_error__["a" /* BwcErrorProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */]])
], BastojiCashPage);

//# sourceMappingURL=bastoji-cash.js.map

/***/ }),

/***/ 846:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AllAddressesPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__ = __webpack_require__(15);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// native

// providers



let AllAddressesPage = class AllAddressesPage {
    constructor(navParams, viewCtrl, onGoingProcessProvider, socialSharing, appProvider, logger, platformProvider) {
        this.navParams = navParams;
        this.viewCtrl = viewCtrl;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.walletName = this.navParams.data.walletName;
        this.noBalance = this.navParams.data.noBalance;
        this.withBalance = this.navParams.data.withBalance;
        this.coin = this.navParams.data.coin;
        this.allAddresses = this.noBalance.concat(this.withBalance);
        this.isCordova = this.platformProvider.isCordova;
    }
    dismiss() {
        this.viewCtrl.dismiss();
    }
    formatDate(ts) {
        var dateObj = new Date(ts * 1000);
        if (!dateObj) {
            this.logger.debug('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    sendByEmail() {
        this.onGoingProcessProvider.set('sendingByEmail');
        setTimeout(() => {
            this.onGoingProcessProvider.clear();
            let appName = this.appProvider.info.nameCase;
            let body = appName +
                ' Wallet "' +
                this.walletName +
                '" Addresses\n  Only Main Addresses are  shown.\n\n';
            body += '\n';
            body += this.allAddresses
                .map(v => {
                return ('* ' +
                    v.address +
                    ' xpub' +
                    v.path.substring(1) +
                    ' ' +
                    this.formatDate(v.createdOn));
            })
                .join('\n');
            this.socialSharing.shareViaEmail(body, appName + ' Addresses', null, // TO: must be null or an array
            null, // CC: must be null or an array
            null, // BCC: must be null or an array
            null // FILES: can be null, a string, or an array
            );
        });
    }
};
AllAddressesPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-all-addresses',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/'<ion-header>\n  <ion-toolbar>\n    <ion-title>{{\'All addresses\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button ion-button (click)="dismiss()">\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-toolbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n    <ion-item-divider *ngIf="withBalance && withBalance[0]">{{\'Addresses with balance\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let w of withBalance" copy-to-clipboard="{{w.address}}">\n      <div>{{w.address}}</div>\n      <p class="info">\n        {{w.amount | satToUnit: coin}}\n      </p>\n    </ion-item>\n\n    <ion-item-divider>{{\'Unused addresses\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let u of noBalance" copy-to-clipboard="{{u.address}}">\n      <div>{{u.address}}</div>\n      <ion-note>\n        {{u.path}} {{u.createdOn * 1000 | amDateFormat:\'MMMM Do YYYY, hh:mm a\'}}\n      </ion-note>\n    </ion-item>\n  </ion-list>\n</ion-content>\n<ion-footer>\n  <ion-toolbar *ngIf="isCordova && allAddresses[0]">\n    <button ion-button full class="button-footer" (click)="sendByEmail()">\n      <span translate>Send addresses by email</span>\n    </button>\n  </ion-toolbar>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-addresses/all-addresses/all-addresses.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */],
        __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_3__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_4__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_6__providers_platform_platform__["a" /* PlatformProvider */]])
], AllAddressesPage);

//# sourceMappingURL=all-addresses.js.map

/***/ }),

/***/ 847:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletDeletePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_push_notifications_push_notifications__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// providers





let WalletDeletePage = class WalletDeletePage {
    constructor(app, profileProvider, navParams, popupProvider, onGoingProcessProvider, pushNotificationsProvider, logger, events, translate) {
        this.app = app;
        this.profileProvider = profileProvider;
        this.navParams = navParams;
        this.popupProvider = popupProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.pushNotificationsProvider = pushNotificationsProvider;
        this.logger = logger;
        this.events = events;
        this.translate = translate;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletDeletePage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.walletName = this.wallet.name;
    }
    showDeletePopup() {
        let title = this.translate.instant('Warning!');
        let message = this.translate.instant('Are you sure you want to delete this wallet?');
        this.popupProvider.ionicConfirm(title, message, null, null).then(res => {
            if (res)
                this.deleteWallet();
        });
    }
    deleteWallet() {
        this.onGoingProcessProvider.set('deletingWallet');
        this.profileProvider
            .deleteWalletClient(this.wallet)
            .then(() => {
            this.events.publish('status:updated');
            this.onGoingProcessProvider.clear();
            this.pushNotificationsProvider.unsubscribe(this.wallet);
            this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_8__tabs_tabs__["a" /* TabsPage */]);
        })
            .catch(err => {
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err.message || err);
        });
    }
};
WalletDeletePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-delete',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-delete/wallet-delete.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Delete Wallet\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <h3 class="assertive" translate>Warning!</h3>\n  <p translate>\n    Permanently delete this wallet.\n  </p>\n  <p translate>\n    THIS ACTION CANNOT BE REVERSED\n  </p>\n  <button ion-button class="button-standard" color="danger" (click)="showDeletePopup()">\n    {{\'Delete\' | translate}}\n  </button>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-delete/wallet-delete.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_6__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_5__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_push_notifications_push_notifications__["a" /* PushNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], WalletDeletePage);

//# sourceMappingURL=wallet-delete.js.map

/***/ }),

/***/ 848:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletExportPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_clipboard__ = __webpack_require__(370);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ionic_native_social_sharing__ = __webpack_require__(129);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_backup_backup__ = __webpack_require__(849);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// native


// providers








let WalletExportPage = class WalletExportPage {
    constructor(app, profileProvider, walletProvider, navParams, formBuilder, popupProvider, logger, persistenceProvider, backupProvider, platformProvider, socialSharing, appProvider, clipboard, toastCtrl, translate) {
        this.app = app;
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.navParams = navParams;
        this.formBuilder = formBuilder;
        this.popupProvider = popupProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.backupProvider = backupProvider;
        this.platformProvider = platformProvider;
        this.socialSharing = socialSharing;
        this.appProvider = appProvider;
        this.clipboard = clipboard;
        this.toastCtrl = toastCtrl;
        this.translate = translate;
        this.segments = 'file/text';
        this.password = '';
        this.result = '';
        this.showAdv = false;
        this.showAdvanced = false;
        this.exportWalletForm = this.formBuilder.group({
            password: ['', __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            confirmPassword: ['', __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required],
            noSignEnabled: [false]
        }, { validator: this.matchingPasswords('password', 'confirmPassword') });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletExportPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.isEncrypted = this.wallet.isPrivKeyEncrypted();
        this.canSign = this.wallet.canSign();
        this.isCordova = this.platformProvider.isCordova;
        this.isSafari = this.platformProvider.isSafari;
        this.isIOS = this.platformProvider.isIOS;
    }
    matchingPasswords(passwordKey, confirmPasswordKey) {
        return (group) => {
            let password = group.controls[passwordKey];
            let confirmPassword = group.controls[confirmPasswordKey];
            if (password.value !== confirmPassword.value) {
                return {
                    mismatchedPasswords: true
                };
            }
            return undefined;
        };
    }
    showAdvChange() {
        this.showAdv = !this.showAdv;
    }
    getPassword() {
        return new Promise((resolve, reject) => {
            if (this.password)
                return resolve(this.password);
            this.walletProvider
                .prepare(this.wallet)
                .then(password => {
                this.password = password;
                return resolve(password);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    generateQrCode() {
        if (this.exportWalletInfo || !this.isEncrypted) {
            this.segments = 'qr-code';
        }
        this.getPassword()
            .then((password) => {
            this.walletProvider
                .getEncodedWalletInfo(this.wallet, password)
                .then(code => {
                if (!code)
                    this.supported = false;
                else {
                    this.supported = true;
                    this.exportWalletInfo = code;
                }
                this.segments = 'qr-code';
            })
                .catch((err) => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
            });
        })
            .catch((err) => {
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
        });
    }
    /*
      EXPORT WITHOUT PRIVATE KEY - PENDING
    */
    noSignEnabledChange() {
        if (!this.supported)
            return;
        this.walletProvider
            .getEncodedWalletInfo(this.wallet)
            .then((code) => {
            this.supported = true;
            this.exportWalletInfo = code;
        })
            .catch(err => {
            this.logger.error(err);
            this.supported = false;
            this.exportWalletInfo = null;
        });
    }
    downloadWalletBackup() {
        this.getPassword()
            .then((password) => {
            this.getAddressBook()
                .then(localAddressBook => {
                let opts = {
                    noSign: this.exportWalletForm.value.noSignEnabled,
                    addressBook: localAddressBook,
                    password
                };
                this.backupProvider
                    .walletDownload(this.exportWalletForm.value.password, opts, this.navParams.data.walletId)
                    .then(() => {
                    this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_14__tabs_tabs__["a" /* TabsPage */]);
                })
                    .catch(() => {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('Failed to export'));
                });
            })
                .catch(() => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('Failed to export'));
            });
        })
            .catch((err) => {
            this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
        });
    }
    getAddressBook() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook(this.wallet.credentials.network)
                .then(addressBook => {
                let localAddressBook = [];
                try {
                    localAddressBook = JSON.parse(addressBook);
                }
                catch (ex) {
                    this.logger.warn('Wallet Export: JSON Parse addressBook is not necessary', ex);
                }
                return resolve(localAddressBook);
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    getBackup() {
        return new Promise(resolve => {
            this.getPassword()
                .then((password) => {
                this.getAddressBook()
                    .then(localAddressBook => {
                    let opts = {
                        noSign: this.exportWalletForm.value.noSignEnabled,
                        addressBook: localAddressBook,
                        password
                    };
                    var ew = this.backupProvider.walletExport(this.exportWalletForm.value.password, opts, this.navParams.data.walletId);
                    if (!ew) {
                        this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('Failed to export'));
                    }
                    return resolve(ew);
                })
                    .catch(() => {
                    this.popupProvider.ionicAlert(this.translate.instant('Error'), this.translate.instant('Failed to export'));
                    return resolve();
                });
            })
                .catch((err) => {
                this.popupProvider.ionicAlert(this.translate.instant('Error'), err);
                return resolve();
            });
        });
    }
    viewWalletBackup() {
        this.getBackup().then(backup => {
            var ew = backup;
            if (!ew)
                return;
            this.backupWalletPlainText = ew;
        });
    }
    copyWalletBackup() {
        this.getBackup().then(backup => {
            var ew = backup;
            if (!ew)
                return;
            this.clipboard.copy(ew);
            let copyMessage = this.translate.instant('Copied to clipboard');
            let showSuccess = this.toastCtrl.create({
                message: copyMessage,
                duration: 1000
            });
            showSuccess.present();
        });
    }
    sendWalletBackup() {
        let preparingMessage = this.translate.instant('Preparing backup...');
        let showSuccess = this.toastCtrl.create({
            message: preparingMessage,
            duration: 1000
        });
        showSuccess.present();
        let name = this.wallet.credentials.walletName || this.wallet.credentials.walletId;
        if (this.wallet.alias) {
            name = this.wallet.alias + ' [' + name + ']';
        }
        this.getBackup().then(backup => {
            let ew = backup;
            if (!ew)
                return;
            if (this.exportWalletForm.value.noSignEnabled)
                name = name + '(No Private Key)';
            let subject = this.appProvider.info.nameCase + ' Wallet Backup: ' + name;
            let body = 'Here is the encrypted backup of the wallet ' +
                name +
                ': \n\n' +
                ew +
                '\n\n To import this backup, copy all text between {...}, including the symbols {}';
            this.socialSharing.shareViaEmail(body, subject, null, // TO: must be null or an array
            null, // CC: must be null or an array
            null, // BCC: must be null or an array
            null // FILES: can be null, a string, or an array
            );
        });
    }
};
WalletExportPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-export',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Export wallet\' | translate}}</ion-title>\n  </ion-navbar>\n  <ion-toolbar>\n    <ion-segment [(ngModel)]="segments" color="blank">\n      <ion-segment-button value="file/text">\n        {{\'File/Text\' | translate}}\n      </ion-segment-button>\n      <ion-segment-button value="qr-code" (click)="generateQrCode()">\n        {{\'QR Code\' | translate}}\n      </ion-segment-button>\n    </ion-segment>\n  </ion-toolbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <div [ngSwitch]="segments">\n    <ion-list *ngSwitchCase="\'file/text\'">\n      <ion-item-divider></ion-item-divider>\n      <div *ngIf="!backupWalletPlainText">\n        <form [formGroup]="exportWalletForm">\n          <ion-item>\n            <ion-label stacked>{{\'Set up a password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="password" required></ion-input>\n          </ion-item>\n          <ion-item>\n            <ion-label stacked>{{\'Repeat the password\' | translate}}</ion-label>\n            <ion-input type="password" formControlName="confirmPassword" required></ion-input>\n          </ion-item>\n          <ion-item *ngIf="exportWalletForm.controls.confirmPassword.touched && exportWalletForm.hasError(\'mismatchedPasswords\') && exportWalletForm.controls.password.valid">\n            <span ion-text color="warning" translate>Passwords do not match</span>\n          </ion-item>\n          <div *ngIf="canSign">\n            <ion-item-divider></ion-item-divider>\n            <ion-item (click)="showAdvChange()">\n              <span translate *ngIf="!showAdv">Show advanced options</span>\n              <span translate *ngIf="showAdv">Hide advanced options</span>\n              <div item-end>\n                <ion-icon color="grey" *ngIf="!showAdv" name="ios-arrow-down-outline"></ion-icon>\n                <ion-icon color="grey" *ngIf="showAdv" name="ios-arrow-up-outline"></ion-icon>\n              </div>\n            </ion-item>\n            <ion-item *ngIf="showAdv">\n              <ion-label stacked>{{\'Do not include private key\' | translate}}</ion-label>\n              <ion-checkbox formControlName="noSignEnabled" (ionChange)="noSignEnabledChange()"></ion-checkbox>\n            </ion-item>\n          </div>\n          <ion-item-divider *ngIf="!canSign || exportWalletForm.value.noSignEnabled">\n            <div class="warning-container" *ngIf="!canSign">\n              <ion-icon name="ios-warning-outline"></ion-icon>\n              <span translate>WARNING: The private key of this wallet is not available. The export allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.</span>\n            </div>\n            <div class="warning-container" *ngIf="exportWalletForm.value.noSignEnabled">\n              <ion-icon name="ios-warning-outline"></ion-icon>\n              <span translate>WARNING: Not including the private key allows to check the wallet balance, transaction history, and create spend proposals from the export. However, does not allow to approve (sign) proposals, so funds will not be accessible from the export.</span>\n            </div>\n          </ion-item-divider>\n          <button *ngIf="!isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="downloadWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid "><span translate>Download</span></button>\n          <button *ngIf="isSafari && !isCordova" class="button-standard" ion-button type="submit" (click)="viewWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid "><span translate>View</span></button>\n          <div *ngIf="isCordova">\n            <button class="button-standard" ion-button type="submit" (click)="copyWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid "><span translate>Copy to clipboard</span></button>\n            <button class="button-standard" ion-button type="submit" (click)="sendWalletBackup()" [disabled]="(!exportWalletForm.value.password || exportWalletForm.value.password != exportWalletForm.value.confirmPassword) || !exportWalletForm.valid "><span translate>Send by email</span></button>\n          </div>\n        </form>\n      </div>\n      <div *ngIf="backupWalletPlainText">\n        <span translate>Backup wallet</span>\n        <p translate>Copy this text as it is to a safe place (notepad or email)</p>\n        <ion-textarea rows="12">{{backupWalletPlainText}}</ion-textarea>\n      </div>\n    </ion-list>\n    <ion-list *ngSwitchCase="\'qr-code\'">\n      <div class="qrCode" *ngIf="supported">\n        <ngx-qrcode qrc-value="{{exportWalletInfo}}" qrc-class="aclass" qrc-errorCorrectionLevel="M"></ngx-qrcode>\n        <ion-item-divider>\n          <span translate>From the destination device, go to Add wallet &gt; Import wallet and scan this QR code</span>\n        </ion-item-divider>\n      </div>\n      <div class="not-supported-message" *ngIf="!supported">\n        <span translate>Exporting via QR not supported for this wallet</span>\n      </div>\n    </ion-list>\n  </div>\n  <ion-item-divider></ion-item-divider>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-export/wallet-export.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_12__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_13__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_11__providers_popup_popup__["a" /* PopupProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_9__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_8__providers_backup_backup__["a" /* BackupProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_6__ionic_native_social_sharing__["a" /* SocialSharing */],
        __WEBPACK_IMPORTED_MODULE_7__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_clipboard__["a" /* Clipboard */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["p" /* ToastController */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
], WalletExportPage);

//# sourceMappingURL=wallet-export.js.map

/***/ }),

/***/ 849:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__ = __webpack_require__(14);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// Providers



let BackupProvider = class BackupProvider {
    constructor(appProvider, bwcProvider, logger, profileProvider) {
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.logger = logger;
        this.profileProvider = profileProvider;
        this.logger.info('BackupProvider initialized.');
    }
    walletDownload(password, opts, walletId) {
        return new Promise((resolve, reject) => {
            let wallet = this.profileProvider.getWallet(walletId);
            let ew = this.walletExport(password, opts, walletId);
            if (!ew)
                return reject('Could not create backup');
            let walletName = (wallet.alias || '') +
                (wallet.alias ? '-' : '') +
                wallet.credentials.walletName;
            if (opts.noSign)
                walletName = walletName + '-noSign';
            let filename = walletName + '-' + this.appProvider.info.nameCase + 'backup.aes.json';
            this._download(ew, filename).then(() => {
                return resolve();
            });
        });
    }
    walletExport(password, opts, walletId) {
        if (!password) {
            return null;
        }
        let wallet = this.profileProvider.getWallet(walletId);
        try {
            opts = opts ? opts : {};
            let b = wallet.export(opts);
            if (opts.addressBook)
                b = this.addMetadata(b, opts);
            let e = this.bwcProvider.getSJCL().encrypt(password, b, {
                iter: 10000
            });
            return e;
        }
        catch (err) {
            this.logger.debug('Error exporting wallet: ', err);
            return null;
        }
    }
    addMetadata(b, opts) {
        b = JSON.parse(b);
        if (opts.addressBook)
            b.addressBook = opts.addressBook;
        return JSON.stringify(b);
    }
    _download(ew, fileName) {
        return new Promise(resolve => {
            let a = document.createElement('a');
            let blob = this.NewBlob(ew, 'text/plain;charset=utf-8');
            let url = window.URL.createObjectURL(blob);
            document.body.appendChild(a);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
            return resolve();
        });
    }
    NewBlob(data, datatype) {
        let out;
        try {
            out = new Blob([data], {
                type: datatype
            });
            this.logger.debug('case 1');
        }
        catch (e) {
            if (e.name == 'InvalidStateError') {
                // InvalidStateError (tested on FF13 WinXP)
                out = new Blob([data], {
                    type: datatype
                });
                this.logger.debug('case 2');
            }
            else {
                // We're screwed, blob constructor unsupported entirely
                this.logger.debug('Error');
            }
        }
        return out;
    }
};
BackupProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_1__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__["a" /* ProfileProvider */]])
], BackupProvider);

//# sourceMappingURL=backup.js.map

/***/ }),

/***/ 850:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletInformationPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__wallet_extended_private_key_wallet_extended_private_key__ = __webpack_require__(851);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__tabs_tabs__ = __webpack_require__(67);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers


// pages



let WalletInformationPage = class WalletInformationPage {
    constructor(app, profileProvider, configProvider, navParams, navCtrl, events, logger) {
        this.app = app;
        this.profileProvider = profileProvider;
        this.configProvider = configProvider;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
        this.events = events;
        this.logger = logger;
        this.colorCounter = 1;
        this.BLACK_WALLET_COLOR = '#202020';
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletInformationPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.walletName = this.wallet.name;
        this.coin = this.wallet.coin;
        this.walletId = this.wallet.credentials.walletId;
        this.N = this.wallet.credentials.n;
        this.M = this.wallet.credentials.m;
        this.copayers = this.wallet.cachedStatus.wallet.copayers;
        this.copayerId = this.wallet.credentials.copayerId;
        this.balanceByAddress = this.wallet.balanceByAddress;
        this.account = this.wallet.credentials.account;
        this.network = this.wallet.credentials.network;
        this.addressType = this.wallet.credentials.addressType || 'P2SH';
        this.derivationStrategy =
            this.wallet.credentials.derivationStrategy || 'BIP45';
        this.basePath = this.wallet.credentials.getBaseAddressDerivationPath();
        this.pubKeys = __WEBPACK_IMPORTED_MODULE_6_lodash__["map"](this.wallet.credentials.publicKeyRing, 'xPubKey');
        this.externalSource = null;
        this.canSign = this.wallet.canSign();
        this.needsBackup = this.wallet.needsBackup;
    }
    saveBlack() {
        if (this.colorCounter != 5) {
            this.colorCounter++;
            return;
        }
        this.save(this.BLACK_WALLET_COLOR);
    }
    save(color) {
        let opts = {
            colorFor: {}
        };
        opts.colorFor[this.wallet.credentials.walletId] = color;
        this.configProvider.set(opts);
        this.events.publish('wallet:updated', this.wallet.credentials.walletId);
        this.app.getRootNavs()[0].setRoot(__WEBPACK_IMPORTED_MODULE_7__tabs_tabs__["a" /* TabsPage */]);
    }
    openWalletExtendedPrivateKey() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__wallet_extended_private_key_wallet_extended_private_key__["a" /* WalletExtendedPrivateKeyPage */], {
            walletId: this.wallet.credentials.walletId
        });
    }
};
WalletInformationPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-information',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Wallet Information\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item *ngIf="wallet" [wallet]="wallet"></page-wallet-item>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <ion-item (click)="saveBlack()">\n      <div translate float-left>Name (at creation)</div>\n      <div text-end text-wrap ion-text color="light-grey">\n        {{walletName}}\n      </div>\n    </ion-item>\n    <ion-item>\n      <span translate>Coin</span>\n      <ion-note item-end>\n        {{coin}}\n      </ion-note>\n    </ion-item>\n    <ion-item copy-to-clipboard="{{walletId}}">\n      <span>Wallet Id</span>\n      <div padding-top>\n        <ion-note text-wrap>\n          {{walletId}}\n        </ion-note>\n      </div>\n    </ion-item>\n    <ion-item>\n      <span translate>Configuration (m-n)</span>\n      <ion-note item-end>\n        {{M}}-{{N}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Network</span>\n      <ion-note item-end>\n        {{network}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Address Type</span>\n      <ion-note item-end>\n        {{addressType}}\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Derivation Strategy</span>\n      <ion-note item-end>\n        {{derivationStrategy}}\n      </ion-note>\n    </ion-item>\n    <ion-item *ngIf="!canSign">\n      <span></span>\n      <ion-note item-end>\n        <span translate>No private key</span>\n      </ion-note>\n    </ion-item>\n    <ion-item>\n      <span translate>Account</span>({{derivationStrategy}})\n      <ion-note item-end>\n        #{{account}}\n      </ion-note>\n    </ion-item>\n    <ion-item-divider *ngIf="copayers">Sqoiners</ion-item-divider>\n    <ion-item *ngFor="let copayer of copayers">\n      <span>{{copayer.name}}</span>\n      <ion-note *ngIf="copayer.id == copayerId" item-end>\n        ({{\'Me\' | translate}})\n      </ion-note>\n    </ion-item>\n    <ion-item-divider>{{\'Extended Public Keys\' | translate}}</ion-item-divider>\n    <ion-item *ngFor="let pk of pubKeys; let i=index" copy-to-clipboard="{{pk}}">\n      <span>Sqoiner {{i}}</span>\n      <div padding-top>\n        <ion-note text-wrap>\n          {{pk}}\n        </ion-note>\n      </div>\n      <span *ngIf="$index == 0">({{basePath}})</span>\n    </ion-item>\n    <div *ngIf="!needsBackup && canSign">\n      <ion-item-divider></ion-item-divider>\n      <button ion-item (click)="openWalletExtendedPrivateKey()">\n        <span translate>Extended Private Key</span>\n      </button>\n    </div>\n    <ion-item-divider *ngIf="balanceByAddress">Balance By Address</ion-item-divider>\n    <ion-item class="item" *ngFor="let a of balanceByAddress" copy-to-clipboard="{{a.address}}">\n      <span>{{a.address}}</span>\n      <ion-note item-end>\n        {{(a.amount/1e8).toFixed(8)}} BTJ\n      </ion-note>\n    </ion-item>\n    <ion-item-divider></ion-item-divider>\n  </ion-list>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-information.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["c" /* App */],
        __WEBPACK_IMPORTED_MODULE_4__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */]])
], WalletInformationPage);

//# sourceMappingURL=wallet-information.js.map

/***/ }),

/***/ 851:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletExtendedPrivateKeyPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_wallet_wallet__ = __webpack_require__(21);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers


let WalletExtendedPrivateKeyPage = class WalletExtendedPrivateKeyPage {
    constructor(profileProvider, walletProvider, logger, navParams, navCtrl) {
        this.profileProvider = profileProvider;
        this.walletProvider = walletProvider;
        this.logger = logger;
        this.navParams = navParams;
        this.navCtrl = navCtrl;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletExtendedPrivateKeyPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.credentialsEncrypted = this.wallet.isPrivKeyEncrypted();
    }
    ionViewDidEnter() {
        this.walletProvider
            .getKeys(this.wallet)
            .then(k => {
            this.xPrivKey = k.xPrivKey;
            this.credentialsEncrypted = false;
        })
            .catch(err => {
            this.logger.error('Could not get keys: ', err);
            this.navCtrl.pop();
        });
    }
};
WalletExtendedPrivateKeyPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-extended-private-key',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-extended-private-key/wallet-extended-private-key.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Extended Private Key\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <div class="container">\n    <h3 translate>Warning!</h3>\n    <div class="warning-message">\n      <p translate>\n        Your extended private keys are all that is needed to access your bastoji funds. Be sure to protect your private keys and store them only on secure devices. BitPay does not have access to your private keys, so you alone are responsible for your keys. If you share key access with external services, you take responsibility for the risk of theft or breach. Only advanced users should handle extended private keys directly.\n      </p>\n    </div>\n    <div *ngIf="wallet && !credentialsEncrypted">\n      <button ion-button class="button-standard" copy-to-clipboard="{{xPrivKey}}">\n        {{\'Copy to clipboard\' | translate}}\n      </button>\n    </div>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-information/wallet-extended-private-key/wallet-extended-private-key.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_wallet_wallet__["a" /* WalletProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */]])
], WalletExtendedPrivateKeyPage);

//# sourceMappingURL=wallet-extended-private-key.js.map

/***/ }),

/***/ 852:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletServiceUrlPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_splash_screen__ = __webpack_require__(330);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// native

// providers






let WalletServiceUrlPage = class WalletServiceUrlPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, app, logger, persistenceProvider, formBuilder, events, splashScreen, platformProvider, replaceParametersProvider, translate) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.app = app;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.formBuilder = formBuilder;
        this.events = events;
        this.splashScreen = splashScreen;
        this.platformProvider = platformProvider;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.success = false;
        this.walletServiceForm = this.formBuilder.group({
            bwsurl: [
                '',
                __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].compose([__WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].minLength(1), __WEBPACK_IMPORTED_MODULE_1__angular_forms__["g" /* Validators */].required])
            ]
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletServiceUrlPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.defaults = this.configProvider.getDefaults();
        this.config = this.configProvider.get();
        let appName = this.app.info.nameCase;
        this.comment = this.replaceParametersProvider.replace(this.translate.instant("{{appName}} depends on Bitcore Wallet Service (BWS) for blockchain information, networking and Sqoiner synchronization. The default configuration points to https://bws.bitpay.com (BitPay's public BWS instance)."), { appName });
        this.walletServiceForm.value.bwsurl =
            (this.config.bwsFor &&
                this.config.bwsFor[this.wallet.credentials.walletId]) ||
                this.defaults.bws.url;
    }
    resetDefaultUrl() {
        this.walletServiceForm.value.bwsurl = this.defaults.bws.url;
    }
    save() {
        let bws;
        switch (this.walletServiceForm.value.bwsurl) {
            case 'prod':
            case 'production':
                bws = 'https://bws.bitpay.com/bws/api';
                break;
            case 'sta':
            case 'staging':
                bws = 'https://bws-staging.b-pay.net/bws/api';
                break;
            case 'loc':
            case 'local':
                bws = 'http://localhost:3232/bws/api';
                break;
        }
        if (bws) {
            this.logger.info('Using BWS URL Alias to ' + bws);
            this.walletServiceForm.value.bwsurl = bws;
        }
        let opts = {
            bwsFor: {}
        };
        opts.bwsFor[this.wallet.credentials.walletId] = this.walletServiceForm.value.bwsurl;
        this.configProvider.set(opts);
        this.persistenceProvider.setCleanAndScanAddresses(this.wallet.credentials.walletId);
        this.events.publish('wallet:updated', this.wallet.credentials.walletId);
        this.navCtrl.popToRoot({ animate: false }).then(() => {
            this.navCtrl.parent.select(0);
            this.reload();
        });
    }
    reload() {
        window.location.reload();
        if (this.platformProvider.isCordova)
            this.splashScreen.show();
    }
};
WalletServiceUrlPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-service-url',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>Wallet Service URL</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <form [formGroup]="walletServiceForm">\n      <ion-item>\n        <ion-label stacked>Wallet Service URL</ion-label>\n        <ion-input type="text" formControlName="bwsurl" [value]="walletServiceForm.value.bwsurl" required></ion-input>\n      </ion-item>\n      <ion-item-divider>\n        <span>{{comment}}</span>\n        <a (click)="resetDefaultUrl()" translate>\n          Use default url\n        </a>\n      </ion-item-divider>\n      <button ion-button class="button-standard" (click)="save()" [disabled]="!walletServiceForm.valid">\n        {{\'Save\' | translate}}\n      </button>\n    </form>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-service-url/wallet-service-url.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_10__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_7__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_8__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_1__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_splash_screen__["a" /* SplashScreen */],
        __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_11__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ngx_translate_core__["c" /* TranslateService */]])
], WalletServiceUrlPage);

//# sourceMappingURL=wallet-service-url.js.map

/***/ }),

/***/ 853:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletTransactionHistoryPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_papaparse__ = __webpack_require__(1190);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_papaparse___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_papaparse__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__pages_wallet_details_wallet_details__ = __webpack_require__(146);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





// Providers





// Pages

let WalletTransactionHistoryPage = class WalletTransactionHistoryPage {
    constructor(profileProvider, navCtrl, navParams, configProvider, logger, platformProvider, appProvider, walletProvider) {
        this.profileProvider = profileProvider;
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.configProvider = configProvider;
        this.logger = logger;
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.walletProvider = walletProvider;
        this.csvReady = false;
        this.csvContent = [];
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletTransactionHistoryPage');
    }
    ionViewWillEnter() {
        this.wallet = this.profileProvider.getWallet(this.navParams.data.walletId);
        this.currency = this.wallet.coin.toUpperCase();
        this.isCordova = this.platformProvider.isCordova;
        this.appName = this.appProvider.info.nameCase;
        this.config = this.configProvider.get();
        this.unitToSatoshi = this.config.wallet.settings.unitToSatoshi;
        this.unitDecimals = this.config.wallet.settings.unitDecimals;
        this.satToUnit = 1 / this.unitToSatoshi;
        this.satToBtc = 1 / 100000000;
        this.csvHistory();
    }
    formatDate(date) {
        var dateObj = new Date(date);
        if (!dateObj) {
            this.logger.debug('Error formating a date');
            return 'DateError';
        }
        if (!dateObj.toJSON()) {
            return '';
        }
        return dateObj.toJSON();
    }
    // TODO : move this to walletService.
    csvHistory() {
        this.logger.debug('Generating CSV from History');
        this.walletProvider
            .getTxHistory(this.wallet, {})
            .then(txs => {
            if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](txs)) {
                this.logger.warn('Failed to generate CSV: no transactions');
                this.err = 'no transactions';
                return;
            }
            this.logger.debug('Wallet Transaction History Length:', txs.length);
            var data = txs;
            this.csvFilename = this.appName + '-' + this.wallet.name + '.csv';
            this.csvHeader = [
                'Date',
                'Destination',
                'Description',
                'Amount',
                'Currency',
                'Txid',
                'Creator',
                'Copayers',
                'Comment'
            ];
            var _amount, _note, _copayers, _creator, _comment;
            data.forEach(it => {
                var amount = it.amount;
                if (it.action == 'moved')
                    amount = 0;
                _copayers = '';
                _creator = '';
                if (it.actions && it.actions.length > 1) {
                    for (var i = 0; i < it.actions.length; i++) {
                        _copayers +=
                            it.actions[i].copayerName + ':' + it.actions[i].type + ' - ';
                    }
                    _creator =
                        it.creatorName && it.creatorName != 'undefined'
                            ? it.creatorName
                            : '';
                }
                _amount =
                    (it.action == 'sent' ? '-' : '') +
                        (amount * this.satToBtc).toFixed(8);
                _note = it.message || '';
                _comment = it.note ? it.note.body : '';
                if (it.action == 'moved')
                    _note += ' Moved:' + (it.amount * this.satToBtc).toFixed(8);
                this.csvContent.push({
                    Date: this.formatDate(it.time * 1000),
                    Destination: it.addressTo || '',
                    Description: _note,
                    Amount: _amount,
                    Currency: this.currency,
                    Txid: it.txid,
                    Creator: _creator,
                    Copayers: _copayers,
                    Comment: _comment
                });
                if (it.fees && (it.action == 'moved' || it.action == 'sent')) {
                    var _fee = (it.fees * this.satToBtc).toFixed(8);
                    this.csvContent.push({
                        Date: this.formatDate(it.time * 1000),
                        Destination: 'Bastoji Network Fees',
                        Description: '',
                        Amount: '-' + _fee,
                        Currency: this.currency,
                        Txid: '',
                        Creator: '',
                        Copayers: ''
                    });
                }
            });
            this.csvReady = true;
        })
            .catch(err => {
            this.logger.warn('Failed to generate CSV:', err);
            this.err = err;
        });
    }
    downloadCSV() {
        if (!this.csvReady)
            return;
        let csv = __WEBPACK_IMPORTED_MODULE_3_papaparse__["unparse"]({
            fields: this.csvHeader,
            data: this.csvContent
        });
        var blob = new Blob([csv]);
        var a = window.document.createElement('a');
        a.href = window.URL.createObjectURL(blob);
        a.download = this.csvFilename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }
    clearTransactionHistory() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info('Removing Transaction history ' + this.wallet.id);
            this.walletProvider.clearTxHistory(this.wallet);
            this.logger.info('Transaction history cleared for :' + this.wallet.id);
            yield this.navCtrl.popToRoot({ animate: false });
            yield this.navCtrl.parent.select(0);
            yield this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_10__pages_wallet_details_wallet_details__["a" /* WalletDetailsPage */], {
                walletId: this.wallet.credentials.walletId,
                clearCache: true
            });
        });
    }
};
WalletTransactionHistoryPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-transaction-history',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Transaction History\' | translate}}</ion-title>\n  </ion-navbar>\n</ion-header>\n<ion-content>\n  <page-wallet-item [wallet]="wallet"></page-wallet-item>\n\n  <ion-list>\n    <ion-item-divider></ion-item-divider>\n    <button ion-button class="button-standard" *ngIf="!isCordova" (click)="downloadCSV()" [disabled]="!csvReady">\n      <span *ngIf="csvReady" translate>Export to file</span>\n      <span *ngIf="!csvReady && !err">\n        {{\'preparing...\' | translate}}\n      </span>\n      <span *ngIf="!csvReady && err">\n        {{err}}\n      </span>\n    </button>\n\n    <ion-item-divider>\n      <span translate>\n        The transaction history and every new incoming transaction are cached in the app. This feature clean this up and synchronizes again from the server\n      </span>\n    </ion-item-divider>\n    <button ion-button class="button-standard" color="danger" (click)="clearTransactionHistory()">\n      <span translate>Clear cache</span>\n    </button>\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/settings/wallet-settings/wallet-settings-advanced/wallet-transaction-history/wallet-transaction-history.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_wallet_wallet__["a" /* WalletProvider */]])
], WalletTransactionHistoryPage);

//# sourceMappingURL=wallet-transaction-history.js.map

/***/ }),

/***/ 854:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SearchTxModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_time_time__ = __webpack_require__(88);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers


let SearchTxModalPage = class SearchTxModalPage {
    constructor(navParams, platformProvider, timeProvider, viewCtrl) {
        this.navParams = navParams;
        this.platformProvider = platformProvider;
        this.timeProvider = timeProvider;
        this.viewCtrl = viewCtrl;
        this.throttleSearch = __WEBPACK_IMPORTED_MODULE_2_lodash__["throttle"]((search) => {
            this.txHistorySearchResults = this.filter(search).slice(0, this.HISTORY_SHOW_LIMIT);
        }, 1000);
        this.HISTORY_SHOW_LIMIT = 10;
        this.currentTxHistoryPage = 0;
        this.txHistorySearchResults = [];
        this.isCordova = this.platformProvider.isCordova;
        this.addressbook = this.navParams.data.addressbook;
        this.completeTxHistory = this.navParams.data.completeHistory;
        this.wallet = this.navParams.data.wallet;
    }
    close(txid) {
        this.viewCtrl.dismiss({ txid });
    }
    updateSearchInput(search) {
        this.currentTxHistoryPage = 0;
        this.throttleSearch(search);
    }
    filter(search) {
        this.filteredTxHistory = [];
        if (__WEBPACK_IMPORTED_MODULE_2_lodash__["isEmpty"](search)) {
            this.txHistoryShowMore = false;
            return [];
        }
        this.filteredTxHistory = __WEBPACK_IMPORTED_MODULE_2_lodash__["filter"](this.completeTxHistory, tx => {
            if (!tx.searcheableString)
                tx.searcheableString = this.computeSearchableString(tx);
            return __WEBPACK_IMPORTED_MODULE_2_lodash__["includes"](tx.searcheableString, search.toLowerCase());
        });
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.HISTORY_SHOW_LIMIT ? true : false;
        return this.filteredTxHistory;
    }
    computeSearchableString(tx) {
        let addressBook = '';
        if (tx.addressTo && this.addressbook && this.addressbook[tx.addressTo])
            addressBook =
                this.addressbook[tx.addressTo].name ||
                    this.addressbook[tx.addressTo] ||
                    '';
        let searchableDate = this.computeSearchableDate(new Date(tx.time * 1000));
        let message = tx.message ? tx.message : '';
        let comment = tx.note ? tx.note.body : '';
        let addressTo = tx.addressTo ? tx.addressTo : '';
        let txid = tx.txid ? tx.txid : '';
        return (tx.amountStr +
            message +
            addressTo +
            addressBook +
            searchableDate +
            comment +
            txid)
            .toString()
            .toLowerCase();
    }
    computeSearchableDate(date) {
        let day = ('0' + date.getDate()).slice(-2).toString();
        let month = ('0' + (date.getMonth() + 1)).slice(-2).toString();
        let year = date.getFullYear();
        return [month, day, year].join('/');
    }
    moreSearchResults(loading) {
        setTimeout(() => {
            this.currentTxHistoryPage++;
            this.showHistory();
            loading.complete();
        }, 100);
    }
    showHistory() {
        this.txHistorySearchResults = this.filteredTxHistory
            ? this.filteredTxHistory.slice(0, (this.currentTxHistoryPage + 1) * this.HISTORY_SHOW_LIMIT)
            : [];
        this.txHistoryShowMore =
            this.filteredTxHistory.length > this.txHistorySearchResults.length;
    }
    trackByFn(index) {
        return index;
    }
    createdWithinPastDay(time) {
        return this.timeProvider.withinPastDay(time);
    }
};
SearchTxModalPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-search-tx-modal',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>{{\'Search Transactions\' | translate}}</ion-title>\n    <ion-buttons left>\n      <button (click)="close()" ion-button>\n        {{\'Close\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <div>\n    <ion-searchbar placeholder="{{\'Search Transactions\' | translate}}" [(ngModel)]="search" (ngModelChange)="updateSearchInput(search)"></ion-searchbar>\n  </div>\n\n  <ion-list *ngIf="txHistorySearchResults && txHistorySearchResults[0]" class="tx-history">\n    <div>\n      <div *ngFor="let tx of txHistorySearchResults; trackBy: trackByFn; let i = index;">\n        <button ion-item (click)="close(tx.txid)">\n          <ion-icon item-start>\n            <div *ngIf="tx.confirmations == 0">\n              <img src="assets/img/tx-action/icon-confirming.svg" width="40">\n            </div>\n            <div *ngIf="tx.confirmations > 0">\n              <span *ngIf="tx.customData && tx.customData.service">\n                <img class="icon-services" src="assets/img/shapeshift/icon-shapeshift.svg" *ngIf="tx.customData.service == \'shapeshift\'" width="40">\n                <img class="icon-services" src="assets/img/amazon/icon-amazon.svg" *ngIf="tx.customData.service == \'amazon\'" width="40">\n                <img class="icon-services" src="assets/img/mercado-libre/icon-ml.svg" *ngIf="tx.customData.service == \'mercadolibre\'" width="40">\n                <img class="icon-services" src="assets/img/bitpay-card/icon-bitpay.svg" *ngIf="tx.customData.service == \'debitcard\'" width="40">\n              </span>\n              <span *ngIf="!tx.customData || !tx.customData.service">\n                <img src="assets/img/tx-action/icon-received.svg" *ngIf="tx.action == \'received\'" width="40">\n                <img src="assets/img/tx-action/icon-sent.svg" *ngIf="tx.action == \'sent\'" width="40">\n                <img src="assets/img/tx-action/icon-moved.svg" *ngIf="tx.action == \'moved\'" width="40">\n              </span>\n            </div>\n          </ion-icon>\n\n          <div class="action" *ngIf="tx.confirmations == 0">\n            <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && !(addressbook && addressbook[tx.outputs[0].address])">{{\'Sending\' | translate}}</span>\n            <span *ngIf="(tx.action == \'sent\' || tx.action == \'moved\') && (addressbook && addressbook[tx.outputs[0].address])">{{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}</span>\n            <span *ngIf="tx.action == \'received\'">{{\'Receiving\' | translate}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'received\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Received\' | translate}}</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'sent\'">\n            <span *ngIf="!tx.message && (!tx.note || (tx.note && tx.note.body == \'\')) && (!addressbook || !addressbook[tx.outputs[0].address])">{{\'Sent\' | translate}}</span>\n            <span *ngIf="tx.message">{{tx.message}}</span>\n            <span *ngIf="!tx.message && tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n            <span *ngIf="!tx.message && addressbook && addressbook[tx.outputs[0].address]">\n              {{addressbook[tx.outputs[0].address].name || addressbook[tx.outputs[0].address]}}\n            </span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'moved\'">\n            <span *ngIf="(!tx.note || (tx.note && tx.note.body == \'\'))" translate>Moved</span>\n            <span *ngIf="tx.note && tx.note.body != \'\'">{{tx.note.body}}</span>\n          </div>\n\n          <div class="action" *ngIf="tx.confirmations > 0 && tx.action == \'invalid\'">\n            <span class="assertive" *ngIf="!tx.message && !tx.note" translate>Invalid</span>\n          </div>\n\n          <ion-note item-end text-end>\n            <div class="amount">\n              <span [ngClass]="{\'received\': tx.action == \'received\'}" *ngIf="tx.action != \'invalid\'">{{tx.amount | satToUnit: wallet.coin}}</span>\n              <span class="double-spend" *ngIf="tx.action == \'invalid\'" translate>(possible double spend)</span>\n            </div>\n            <div class="date">\n              <span *ngIf="tx.time && createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amTimeAgo}}</span>\n              <span *ngIf="tx.time && !createdWithinPastDay(tx.time * 1000)">{{tx.time * 1000 | amDateFormat:\'MMM D, YYYY\'}}</span>\n            </div>\n          </ion-note>\n        </button>\n      </div>\n    </div>\n    <div class="txs-count" *ngIf="txHistoryShowMore">\n      <span>{{filteredTxHistory.length - txHistorySearchResults.length}} more</span>\n      &nbsp;\n      <ion-icon name="arrow-down"></ion-icon>\n    </div>\n  </ion-list>\n\n  <ion-infinite-scroll *ngIf="txHistoryShowMore" (ionInfinite)="moreSearchResults($event)">\n    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n  </ion-infinite-scroll>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/wallet-details/search-tx-modal/search-tx-modal.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_3__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_time_time__["a" /* TimeProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["q" /* ViewController */]])
], SearchTxModalPage);

//# sourceMappingURL=search-tx-modal.js.map

/***/ }),

/***/ 855:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return WalletBalancePage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



let WalletBalancePage = class WalletBalancePage {
    constructor(logger, navParams) {
        this.logger = logger;
        this.navParams = navParams;
        this.status = this.navParams.data.status;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad WalletBalancePage');
    }
};
WalletBalancePage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-wallet-balance',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/'<ion-header>\n  <ion-navbar>\n    <ion-title>\n      {{\'Spendable balance\' | translate}}\n    </ion-title>\n  </ion-navbar>\n</ion-header>\n\n<ion-content>\n  <ion-list>\n\n    <ion-item>{{\'All of your bastoji wallet balance may not be available for immediate spending.\' | translate}}</ion-item>\n    <ion-item-divider></ion-item-divider>\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-sigma.svg" />\n          <div translate>Total</div>\n        </div>\n        <div class="balance">\n          <span class="total">\n            {{status.totalBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.totalBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n      <div translate text-wrap class="description">The total amount of bastoji stored in this wallet.</div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <ion-icon ios="ios-checkmark" md="md-checkmark"></ion-icon>\n          <div translate>Available</div>\n        </div>\n        <div class="balance">\n          <span class="available">\n            {{status.spendableBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.spendableBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n      <div translate text-wrap class="description">The amount of bastoji immediately spendable from this wallet.</div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-confirming-clear.svg" />\n          <div translate>Confirming</div>\n        </div>\n        <div class="balance">\n          <span class="confirming">\n            {{status.pendingBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.pendingBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n      <div translate text-wrap class="description">The amount of bastoji stored in this wallet with less than 1 blockchain confirmation.</div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n    <ion-item>\n      <div class="balance-container">\n        <div class="title">\n          <img src="assets/img/icon-lock.svg" />\n          <div translate>Locked</div>\n        </div>\n        <div class="balance">\n          <span class="locked">\n            {{status.lockedBalanceStr}}\n          </span>\n          <div>\n            <span class="fiat">\n              {{status.lockedBalanceAlternative}} {{status.alternativeIsoCode}}\n            </span>\n          </div>\n        </div>\n      </div>\n      <div translate text-wrap class="description">\n        The amount of bastoji stored in this wallet that is allocated as inputs to your pending transaction proposals. The amount is determined using unspent transaction outputs associated with this wallet and may be more than the actual amounts associated with your pending transaction proposals.\n      </div>\n    </ion-item>\n\n    <ion-item-divider></ion-item-divider>\n\n  </ion-list>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/wallet-details/wallet-balance/wallet-balance.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */], __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["l" /* NavParams */]])
], WalletBalancePage);

//# sourceMappingURL=wallet-balance.js.map

/***/ }),

/***/ 856:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FingerprintModalPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_touchid_touchid__ = __webpack_require__(114);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};


// Providers

let FingerprintModalPage = class FingerprintModalPage {
    constructor(touchid, platform, navCtrl) {
        this.touchid = touchid;
        this.platform = platform;
        this.navCtrl = navCtrl;
        this.unregister = this.platform.registerBackButtonAction(() => { });
        this.checkFingerprint();
    }
    checkFingerprint() {
        this.touchid.check().then(() => {
            this.unregister();
            this.navCtrl.pop({ animate: true });
        });
    }
};
FingerprintModalPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-fingerprint',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/fingerprint/fingerprint.html"*/'<ion-content no-bounce fullscreen>\n  <div class="fingerprint-header">\n    <div class="title">\n      <div>\n        {{\'Verify your identity\' | translate}}\n      </div>\n    </div>\n    <div class="icon-container">\n      <ion-icon class="app-icon">\n        <img src="assets/img/app/icon-flat.svg" />\n      </ion-icon>\n    </div>\n  </div>\n  <div class="fingerprint-bottom">\n    <button class="button-standard" ion-button (click)="checkFingerprint()">\n      <span>{{\'Scan again\' | translate}}</span>\n      <ion-icon name="finger-print" item-end></ion-icon>\n    </button>\n  </div>\n\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/fingerprint/fingerprint.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2__providers_touchid_touchid__["b" /* TouchIdProvider */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["n" /* Platform */],
        __WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */]])
], FingerprintModalPage);

//# sourceMappingURL=fingerprint.js.map

/***/ }),

/***/ 857:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return OnboardingPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__ = __webpack_require__(241);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__tour_tour__ = __webpack_require__(858);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// providers



let OnboardingPage = class OnboardingPage {
    constructor(navCtrl, logger, app) {
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.app = app;
        this.isCopay = this.app.info.nameCase == 'Copay' ? true : false;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad OnboardingPage');
    }
    getStarted() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__tour_tour__["a" /* TourPage */]);
    }
    restoreFromBackup() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__add_import_wallet_import_wallet__["a" /* ImportWalletPage */], { fromOnboarding: true });
    }
};
OnboardingPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-onboarding',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/onboarding/onboarding.html"*/'<ion-content no-bounce>\n  <div class="logo-tagline">\n    <img src=\'assets/img/app/logo-negative.svg\' />\n    <p padding [ngClass]="{\'primary-color\': !isCopay, \'comment-color\': isCopay}" translate>Take control of your money, get started with bastoji.</p>\n  </div>\n  <div class="bottom-absolute">\n    <button ion-button class="button-standard e2e-get-started" (click)="getStarted()">\n      {{\'Get started\' | translate}}\n    </button>\n    <button ion-button clear class="button-standard primary-color" (click)="restoreFromBackup()">\n      {{\'Restore from backup\' | translate}}\n    </button>\n  </div>\n</ion-content>\n'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/onboarding/onboarding.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_1_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_app_app__["a" /* AppProvider */]])
], OnboardingPage);

//# sourceMappingURL=onboarding.js.map

/***/ }),

/***/ 858:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TourPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__collect_email_collect_email__ = __webpack_require__(859);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__ = __webpack_require__(113);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__ = __webpack_require__(47);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// pages

// providers






let TourPage = class TourPage {
    constructor(navCtrl, loadingCtrl, logger, translate, profileProvider, rateProvider, txFormatProvider, onGoingProcessProvider, persistenceProvider, popupProvider) {
        this.navCtrl = navCtrl;
        this.loadingCtrl = loadingCtrl;
        this.logger = logger;
        this.translate = translate;
        this.profileProvider = profileProvider;
        this.rateProvider = rateProvider;
        this.txFormatProvider = txFormatProvider;
        this.onGoingProcessProvider = onGoingProcessProvider;
        this.persistenceProvider = persistenceProvider;
        this.popupProvider = popupProvider;
        this.retryCount = 0;
        this.currentIndex = 0;
        this.rateProvider.whenRatesAvailable('btc').then(() => {
            let btcAmount = 1;
            this.localCurrencySymbol = '$';
            this.localCurrencyPerBtc = this.txFormatProvider.formatAlternativeStr('btc', btcAmount * 1e8);
        });
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad TourPage');
    }
    ionViewWillEnter() {
        this.navBar.backButtonClick = () => {
            this.slidePrev();
        };
    }
    slideChanged() {
        this.currentIndex = this.slides.getActiveIndex();
    }
    slidePrev() {
        if (this.currentIndex == 0)
            this.navCtrl.pop();
        else {
            this.slides.slidePrev();
        }
    }
    slideNext() {
        this.slides.slideNext();
    }
    createDefaultWallet() {
        this.onGoingProcessProvider.set('creatingWallet');
        this.profileProvider
            .createDefaultWallet()
            .then(wallet => {
            this.onGoingProcessProvider.clear();
            this.persistenceProvider.setOnboardingCompleted();
            this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_4__collect_email_collect_email__["a" /* CollectEmailPage */], { walletId: wallet.id });
        })
            .catch(err => {
            setTimeout(() => {
                this.logger.warn('Retrying to create default wallet.....:' + ++this.retryCount);
                if (this.retryCount > 3) {
                    this.onGoingProcessProvider.clear();
                    let title = this.translate.instant('Cannot create wallet');
                    let okText = this.translate.instant('Retry');
                    this.popupProvider.ionicAlert(title, err, okText).then(() => {
                        this.retryCount = 0;
                        this.createDefaultWallet();
                    });
                }
                else {
                    this.createDefaultWallet();
                }
            }, 2000);
        });
    }
};
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* Slides */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["o" /* Slides */])
], TourPage.prototype, "slides", void 0);
__decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["ViewChild"])(__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* Navbar */]),
    __metadata("design:type", __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["m" /* Navbar */])
], TourPage.prototype, "navBar", void 0);
TourPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-tour',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/onboarding/tour/tour.html"*/'<ion-header no-border>\n  <ion-navbar>\n    <ion-buttons right>\n      <button ion-button class="primary-color" (click)="createDefaultWallet()" *ngIf="currentIndex == 0">\n        {{\'Skip\' | translate}}\n      </button>\n    </ion-buttons>\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <ion-slides pager="true" (ionSlideDidChange)="slideChanged()">\n    <ion-slide>\n      <h3 class="title" translate>Bastoji is secure, digital money.</h3>\n      <p translate class="top-description">You can spend bastoji at millions of websites and stores worldwide.</p>\n      <img src=\'assets/img/app/onboarding/tour-phone.svg\' />\n      <div class="bottom-absolute">\n        <p translate class="bottom-description">Just scan the code to pay.</p>\n        <button ion-button clear class="button-standard btn-transparent primary-color e2e-got-it" (click)="slideNext()">\n          {{\'Got it\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n\n    <ion-slide>\n      <h3 class="title" translate>Bastoji is a currency.</h3>\n      <p translate class="top-description">You can trade it for other currencies like US Dollars, Euros, or Pounds.</p>\n      <div class="ticker-container">\n        <div class="ticker">1 BTJ = {{localCurrencySymbol}}{{localCurrencyPerBtc}}</div>\n      </div>\n      <img class="ticker-img" src=\'assets/img/app/onboarding/tour-currency.svg\' />\n      <div class="bottom-absolute">\n        <p translate class="bottom-description">The exchange rate changes with the market.</p>\n        <button ion-button clear class="button-standard btn-transparent primary-color e2e-makes-sense" (click)="slideNext()">\n          {{\'Makes sense\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n\n    <ion-slide>\n      <h3 class="title" translate>You control your bastoji.</h3>\n      <p translate class="top-description">This app stores your bastoji with cutting-edge security.</p>\n      <img src=\'assets/img/app/onboarding/tour-control.svg\' />\n      <div class="bottom-absolute">\n        <p translate class="bottom-description">Not even BitPay can access it.</p>\n        <button ion-button class="button-standard e2e-create-wallet" (click)="createDefaultWallet()">\n          {{\'Create bastoji wallet\' | translate}}\n        </button>\n      </div>\n    </ion-slide>\n  </ion-slides>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/onboarding/tour/tour.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["i" /* LoadingController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_8__providers_profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_9__providers_rate_rate__["a" /* RateProvider */],
        __WEBPACK_IMPORTED_MODULE_10__providers_tx_format_tx_format__["a" /* TxFormatProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_on_going_process_on_going_process__["a" /* OnGoingProcessProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_7__providers_popup_popup__["a" /* PopupProvider */]])
], TourPage);

//# sourceMappingURL=tour.js.map

/***/ }),

/***/ 859:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return CollectEmailPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_forms__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_email_notifications_email_notifications__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__backup_request_backup_request__ = __webpack_require__(860);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// native

// providers

// pages


let CollectEmailPage = class CollectEmailPage {
    constructor(navCtrl, navParams, logger, fb, appProvider, http, emailProvider, device) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.logger = logger;
        this.fb = fb;
        this.appProvider = appProvider;
        this.http = http;
        this.emailProvider = emailProvider;
        this.device = device;
        this.walletId = this.navParams.data.walletId;
        let regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        this.emailForm = this.fb.group({
            email: [null, [__WEBPACK_IMPORTED_MODULE_2__angular_forms__["g" /* Validators */].required, __WEBPACK_IMPORTED_MODULE_2__angular_forms__["g" /* Validators */].pattern(regex)]],
            accept: [false]
        });
        this.showConfirmForm = false;
        // Get more info: https://mashe.hawksey.info/2014/07/google-sheets-as-a-database-insert-with-apps-script-using-postget-methods-with-ajax-example/
        this.URL =
            this.appProvider.servicesInfo &&
                this.appProvider.servicesInfo.emailSheetURL
                ? this.appProvider.servicesInfo.emailSheetURL
                : null;
    }
    ionViewDidLoad() {
        this.logger.info('ionViewDidLoad CollectEmailPage');
    }
    skip() {
        this.goToBackupRequestPage();
    }
    showConfirm() {
        this.showConfirmForm = !this.showConfirmForm;
    }
    save() {
        let opts = {
            enabled: true,
            email: this.emailForm.value.email
        };
        // Confirm for notifications
        this.emailProvider.updateEmail(opts);
        // Confirm to get news and updates from BitPay
        if (this.emailForm.value.accept)
            this.collectEmail();
        this.goToBackupRequestPage();
    }
    goToBackupRequestPage() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_8__backup_request_backup_request__["a" /* BackupRequestPage */], { walletId: this.walletId });
    }
    collectEmail() {
        if (!this.URL)
            return;
        let platform = this.device.platform || 'Unknown platform';
        let version = this.device.version || 'Unknown version';
        const headers = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["c" /* HttpHeaders */]({
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'
        });
        const urlSearchParams = new __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["d" /* HttpParams */]()
            .set('App', this.appProvider.info.nameCase)
            .set('Email', this.emailForm.value.email)
            .set('AppVersion', this.appProvider.info.version)
            .set('Platform', platform)
            .set('DeviceVersion', version);
        this.http
            .post(this.URL, null, {
            params: urlSearchParams,
            headers
        })
            .subscribe(() => {
            this.logger.info('SUCCESS: Email collected');
        }, () => {
            this.logger.error('ERROR: Could not collect email');
        });
    }
};
CollectEmailPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Component"])({
        selector: 'page-collect-email',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/onboarding/collect-email/collect-email.html"*/'<ion-header no-border>\n  <ion-navbar hideBackButton="true">\n  </ion-navbar>\n</ion-header>\n\n<ion-content no-bounce>\n  <div class="fixed">\n    <h3 class="title" translate>Notifications by email</h3>\n    <div *ngIf="!showConfirmForm">\n      <img src=\'assets/img/app/onboarding/push-notifications.svg\' width="200" />\n    </div>\n  </div>\n</ion-content>\n\n<ion-footer no-border>\n  <div class="email-form" *ngIf="!showConfirmForm">\n    <p class="description" translate>Where would you like to receive email notifications about payments?</p>\n    <form [formGroup]="emailForm" (ngSubmit)="showConfirm()">\n      <ion-item>\n        <ion-input type="email" formControlName="email" placeholder="{{\'Email\' | translate}}"></ion-input>\n      </ion-item>\n\n      <ion-item no-lines>\n        <ion-label>{{\'Get news and updates from BitPay\' | translate}}</ion-label>\n        <ion-checkbox formControlName="accept" checked="false"></ion-checkbox>\n      </ion-item>\n      <button ion-button class="button-standard" type="submit" [disabled]="!emailForm.valid">\n        {{\'Continue\' | translate}}\n      </button>\n    </form>\n    <button ion-button clear class="button-standard btn-transparent primary-color" (click)="skip()">\n      {{\'Skip\' | translate}}\n    </button>\n  </div>\n\n  <div class="email-form" *ngIf="showConfirmForm">\n    <div>\n      <p translate>Is this email address correct?</p>\n      <p>{{ emailForm.value.email }}</p>\n    </div>\n    <button ion-button class="button-standard" (click)="save()">\n      {{\'Confirm\' | translate}}\n    </button>\n    <button ion-button class="button-standard btn-transparent primary-color" (click)="showConfirm()">\n      {{\'Edit\' | translate}}\n    </button>\n  </div>\n</ion-footer>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/onboarding/collect-email/collect-email.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_2__angular_forms__["a" /* FormBuilder */],
        __WEBPACK_IMPORTED_MODULE_6__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_7__providers_email_notifications_email_notifications__["a" /* EmailNotificationsProvider */],
        __WEBPACK_IMPORTED_MODULE_5__ionic_native_device__["a" /* Device */]])
], CollectEmailPage);

//# sourceMappingURL=collect-email.js.map

/***/ }),

/***/ 860:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BackupRequestPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__backup_backup_warning_backup_warning__ = __webpack_require__(180);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__disclaimer_disclaimer__ = __webpack_require__(181);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};



// Providers


// Pages


let BackupRequestPage = class BackupRequestPage {
    constructor(navCtrl, navParams, alertCtrl, log, translate, popupProvider) {
        this.navCtrl = navCtrl;
        this.navParams = navParams;
        this.alertCtrl = alertCtrl;
        this.log = log;
        this.translate = translate;
        this.popupProvider = popupProvider;
        this.walletId = this.navParams.get('walletId');
    }
    ionViewDidLoad() {
        this.log.info('ionViewDidLoad BackupRequestPage');
    }
    initBackupFlow() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_5__backup_backup_warning_backup_warning__["a" /* BackupWarningPage */], {
            walletId: this.walletId,
            fromOnboarding: true
        });
    }
    doBackupLater() {
        let title = this.translate.instant('Watch Out!');
        let message = this.translate.instant('If this device is replaced or this app is deleted, neither you nor BitPay can recover your funds without a backup.');
        let okText = this.translate.instant('I understand');
        let cancelText = this.translate.instant('Go Back');
        this.popupProvider
            .ionicConfirm(title, message, okText, cancelText)
            .then(res => {
            if (!res)
                return;
            let title = this.translate.instant('Are you sure you want to skip it?');
            let message = this.translate.instant('You can create a backup later from your wallet settings.');
            let okText = this.translate.instant('Yes, skip');
            let cancelText = this.translate.instant('Go Back');
            this.popupProvider
                .ionicConfirm(title, message, okText, cancelText)
                .then(res => {
                if (!res)
                    return;
                this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_6__disclaimer_disclaimer__["a" /* DisclaimerPage */]);
            });
        });
    }
};
BackupRequestPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-backup-request',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/onboarding/backup-request/backup-request.html"*/'<ion-content no-bounce>\n  <img src="assets/img/app/onboarding/warning.svg" class="alert-icon" />\n  <h3 class="title" translate>No backup, no bastoji.</h3>\n  <p class="top-description" translate>Since only you control your money, youll need to save your backup phrase in case this app is deleted.</p>\n  <div class="bottom-absolute">\n    <ion-icon name="ios-arrow-round-down-outline" class="arrow-down"></ion-icon>\n    <p class="bottom-description" translate>Your wallet is never saved to cloud storage or standard device backups.</p>\n    <button class="primary" ion-button class="button-standard" (click)="initBackupFlow()">\n      {{\'Backup wallet\' | translate}}\n    </button>\n    <button class="secondary" ion-button clear class="button-standard btn-transparent primary-color" (click)="doBackupLater()">\n      {{\'Do it later\' | translate}}\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/onboarding/backup-request/backup-request.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["b" /* AlertController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */],
        __WEBPACK_IMPORTED_MODULE_4__providers_popup_popup__["a" /* PopupProvider */]])
], BackupRequestPage);

//# sourceMappingURL=backup-request.js.map

/***/ }),

/***/ 861:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeedbackPage; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__ = __webpack_require__(184);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__providers_app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__providers_config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__providers_feedback_feedback__ = __webpack_require__(245);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__providers_replace_parameters_replace_parameters__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__feedback_complete_feedback_complete__ = __webpack_require__(256);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__send_feedback_send_feedback__ = __webpack_require__(257);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_13_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};




// native

// providers






// pages



let FeedbackPage = class FeedbackPage {
    constructor(platformProvider, appProvider, configProvider, navParams, feedbackProvider, navCtrl, logger, externalLinkProvider, device, replaceParametersProvider, translate) {
        this.platformProvider = platformProvider;
        this.appProvider = appProvider;
        this.configProvider = configProvider;
        this.navParams = navParams;
        this.feedbackProvider = feedbackProvider;
        this.navCtrl = navCtrl;
        this.logger = logger;
        this.externalLinkProvider = externalLinkProvider;
        this.device = device;
        this.replaceParametersProvider = replaceParametersProvider;
        this.translate = translate;
        this.score = this.navParams.data.score;
        this.isAndroid = this.platformProvider.isAndroid;
        this.isIOS = this.platformProvider.isIOS;
        this.config = this.configProvider.get();
        this.appName = this.appProvider.info.nameCase;
        this.subtitle = this.replaceParametersProvider.replace(this.translate.instant('5-star ratings help us get {{appName}} into more hands, and more users means more resources can be committed to the app!'), { appName: this.appName });
        this.subsubtitle = this.replaceParametersProvider.replace(this.translate.instant('Would you be willing to rate {{appName}} in the app store?'), { appName: this.appName });
    }
    skip() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__feedback_complete_feedback_complete__["a" /* FeedbackCompletePage */], {
            score: this.score,
            skipped: true
        });
        let platform = this.device.platform || 'Unknown platform';
        let version = this.device.version || 'Unknown version';
        let dataSrc = {
            email: __WEBPACK_IMPORTED_MODULE_13_lodash__["values"](this.config.emailFor)[0] || ' ',
            feedback: ' ',
            score: this.score,
            appVersion: this.appProvider.info.version,
            platform,
            deviceVersion: version
        };
        this.feedbackProvider.send(dataSrc).catch(() => {
            this.logger.warn('Could not send feedback.');
        });
    }
    sendFeedback() {
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_12__send_feedback_send_feedback__["a" /* SendFeedbackPage */], { score: this.score });
    }
    goAppStore() {
        let defaults = this.configProvider.getDefaults();
        let url;
        if (this.isAndroid)
            url =
                this.appName == 'Sqoin'
                    ? defaults.rateApp.copay.android
                    : defaults.rateApp.bitpay.android;
        if (this.isIOS)
            url =
                this.appName == 'Sqoin'
                    ? defaults.rateApp.copay.ios
                    : defaults.rateApp.bitpay.ios;
        this.externalLinkProvider.open(url);
        this.navCtrl.push(__WEBPACK_IMPORTED_MODULE_11__feedback_complete_feedback_complete__["a" /* FeedbackCompletePage */], {
            score: this.score,
            skipped: true,
            rated: true
        });
    }
};
FeedbackPage = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Component"])({
        selector: 'page-feedback',template:/*ion-inline-start:"/home/dali/bastoji-mobile/src/pages/feedback/feedback/feedback.html"*/'<ion-content>\n  <div class="skip-rating">\n    <a (click)="skip()" translate>Not now</a>\n  </div>\n  <div class="feedback-title" translate>Thank you!</div>\n  <img src="assets/img/ico-positive-feedback.svg" class="share-the-love-illustration" />\n  <div class="subtitle">\n    <span>{{subtitle}}</span>\n  </div>\n  <div class="sub-subtitle">\n    <span>{{subsubtitle}}</span>\n  </div>\n  <div class="rate-buttons">\n    <button ion-button class="button-standard" (click)="goAppStore()">\n      <span translate>Rate on the app store</span>\n    </button>\n    <button ion-button clear class="button-standard" (click)="sendFeedback()">\n      <span translate>Send us feedback instead</span>\n    </button>\n  </div>\n</ion-content>'/*ion-inline-end:"/home/dali/bastoji-mobile/src/pages/feedback/feedback/feedback.html"*/
    }),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_9__providers_platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_5__providers_app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__providers_config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["l" /* NavParams */],
        __WEBPACK_IMPORTED_MODULE_8__providers_feedback_feedback__["a" /* FeedbackProvider */],
        __WEBPACK_IMPORTED_MODULE_2_ionic_angular__["k" /* NavController */],
        __WEBPACK_IMPORTED_MODULE_3__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_7__providers_external_link_external_link__["a" /* ExternalLinkProvider */],
        __WEBPACK_IMPORTED_MODULE_4__ionic_native_device__["a" /* Device */],
        __WEBPACK_IMPORTED_MODULE_10__providers_replace_parameters_replace_parameters__["a" /* ReplaceParametersProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], FeedbackPage);

//# sourceMappingURL=feedback.js.map

/***/ }),

/***/ 869:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__ = __webpack_require__(870);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__app_module__ = __webpack_require__(874);


Object(__WEBPACK_IMPORTED_MODULE_0__angular_platform_browser_dynamic__["a" /* platformBrowserDynamic */])().bootstrapModule(__WEBPACK_IMPORTED_MODULE_1__app_module__["a" /* AppModule */]);
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 87:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AddressBookProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__providers_persistence_persistence__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};






let AddressBookProvider = class AddressBookProvider {
    constructor(bwcProvider, logger, persistenceProvider, translate) {
        this.bwcProvider = bwcProvider;
        this.logger = logger;
        this.persistenceProvider = persistenceProvider;
        this.translate = translate;
        this.logger.info('AddressBookProvider initialized.');
    }
    getNetwork(address) {
        let network;
        try {
            network = this.bwcProvider.getBitcore().Address(address).network.name;
        }
        catch (e) {
            this.logger.warn('No valid bastoji address. Trying bastoji cash...');
            network = this.bwcProvider.getBitcoreCash().Address(address).network.name;
        }
        return network;
    }
    get(addr) {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                if (ab && ab[addr])
                    return resolve(ab[addr]);
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab => {
                    if (ab && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                        ab = JSON.parse(ab);
                    if (ab && ab[addr])
                        return resolve(ab[addr]);
                    return resolve();
                })
                    .catch(() => {
                    return reject();
                });
            })
                .catch(() => {
                return reject();
            });
        });
    }
    list() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .getAddressBook('testnet')
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                this.persistenceProvider
                    .getAddressBook('livenet')
                    .then(ab2 => {
                    if (ab2 && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                        ab2 = JSON.parse(ab2);
                    ab2 = ab2 || {};
                    return resolve(__WEBPACK_IMPORTED_MODULE_5_lodash__["defaults"](ab2, ab));
                })
                    .catch(err => {
                    return reject(err);
                });
            })
                .catch(() => {
                let msg = this.translate.instant('Could not get the Addressbook');
                return reject(msg);
            });
        });
    }
    add(entry) {
        return new Promise((resolve, reject) => {
            var network = this.getNetwork(entry.address);
            if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](network)) {
                let msg = this.translate.instant('Not valid bastoji address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isArray"](ab))
                    ab = {}; // No array
                if (ab[entry.address]) {
                    let msg = this.translate.instant('Entry already exist');
                    return reject(msg);
                }
                ab[entry.address] = entry;
                this.persistenceProvider
                    .setAddressBook(network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error adding new entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    remove(addr) {
        return new Promise((resolve, reject) => {
            var network = this.getNetwork(addr);
            if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](network)) {
                let msg = this.translate.instant('Not valid bastoji address');
                return reject(msg);
            }
            this.persistenceProvider
                .getAddressBook(network)
                .then(ab => {
                if (ab && __WEBPACK_IMPORTED_MODULE_5_lodash__["isString"](ab))
                    ab = JSON.parse(ab);
                ab = ab || {};
                if (__WEBPACK_IMPORTED_MODULE_5_lodash__["isEmpty"](ab)) {
                    let msg = this.translate.instant('Addressbook is empty');
                    return reject(msg);
                }
                if (!ab[addr]) {
                    let msg = this.translate.instant('Entry does not exist');
                    return reject(msg);
                }
                delete ab[addr];
                this.persistenceProvider
                    .setAddressBook(network, JSON.stringify(ab))
                    .then(() => {
                    this.list()
                        .then(ab => {
                        return resolve(ab);
                    })
                        .catch(err => {
                        return reject(err);
                    });
                })
                    .catch(() => {
                    let msg = this.translate.instant('Error deleting entry');
                    return reject(msg);
                });
            })
                .catch(err => {
                return reject(err);
            });
        });
    }
    removeAll() {
        return new Promise((resolve, reject) => {
            this.persistenceProvider
                .removeAddressbook('livenet')
                .then(() => {
                this.persistenceProvider.removeAddressbook('testnet').then(() => {
                    return resolve();
                });
            })
                .catch(() => {
                let msg = this.translate.instant('Error deleting addressbook');
                return reject(msg);
            })
                .catch(() => {
                let msg = this.translate.instant('Error deleting addressbook');
                return reject(msg);
            });
        });
    }
};
AddressBookProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_4__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_3__providers_persistence_persistence__["a" /* PersistenceProvider */],
        __WEBPACK_IMPORTED_MODULE_1__ngx_translate_core__["c" /* TranslateService */]])
], AddressBookProvider);

//# sourceMappingURL=address-book.js.map

/***/ }),

/***/ 874:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export createTranslateLoader */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AppModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__biesbjerg_ngx_translate_po_http_loader__ = __webpack_require__(910);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__biesbjerg_ngx_translate_po_http_loader___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__biesbjerg_ngx_translate_po_http_loader__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__zxing_ngx_scanner__ = __webpack_require__(949);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_angular2_moment__ = __webpack_require__(977);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_angular2_moment___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_angular2_moment__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_ngx_qrcode2__ = __webpack_require__(980);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__environments__ = __webpack_require__(328);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__app_component__ = __webpack_require__(1001);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__pages_pages__ = __webpack_require__(1191);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__pipes_fiatToUnit__ = __webpack_require__(1205);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__pipes_keys__ = __webpack_require__(1206);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__pipes_order_by__ = __webpack_require__(1207);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__pipes_satToFiat__ = __webpack_require__(1208);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__pipes_satToUnit__ = __webpack_require__(1209);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__directives_animate_animate__ = __webpack_require__(368);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__directives_copy_to_clipboard_copy_to_clipboard__ = __webpack_require__(1210);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_19__directives_ios_scroll_bg_color_ios_scroll_bg_color__ = __webpack_require__(1211);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_20__directives_long_press_long_press__ = __webpack_require__(1212);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_21__directives_navbar_bg_navbar_bg__ = __webpack_require__(1213);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_22__directives_no_low_fee_no_low_fee__ = __webpack_require__(1214);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_23__components_components__ = __webpack_require__(1215);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_24__providers_providers_module__ = __webpack_require__(1483);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};




/* Modules */





/* Copay App */



/* Pipes */





/* Directives */






/* Components */

/* Providers */

/* Read translation files */
function createTranslateLoader(http) {
    return new __WEBPACK_IMPORTED_MODULE_4__biesbjerg_ngx_translate_po_http_loader__["TranslatePoHttpLoader"](http, 'assets/i18n/po', '.po');
}
let AppModule = class AppModule {
};
AppModule = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["NgModule"])({
        declarations: [
            __WEBPACK_IMPORTED_MODULE_10__app_component__["a" /* CopayApp */],
            ...__WEBPACK_IMPORTED_MODULE_11__pages_pages__["a" /* PAGES */],
            ...__WEBPACK_IMPORTED_MODULE_23__components_components__["a" /* COMPONENTS */],
            /* Directives */
            __WEBPACK_IMPORTED_MODULE_18__directives_copy_to_clipboard_copy_to_clipboard__["a" /* CopyToClipboard */],
            __WEBPACK_IMPORTED_MODULE_19__directives_ios_scroll_bg_color_ios_scroll_bg_color__["a" /* IosScrollBgColor */],
            __WEBPACK_IMPORTED_MODULE_20__directives_long_press_long_press__["a" /* LongPress */],
            __WEBPACK_IMPORTED_MODULE_21__directives_navbar_bg_navbar_bg__["a" /* NavbarBg */],
            __WEBPACK_IMPORTED_MODULE_22__directives_no_low_fee_no_low_fee__["a" /* NoLowFee */],
            __WEBPACK_IMPORTED_MODULE_17__directives_animate_animate__["a" /* Animate */],
            /* Pipes */
            __WEBPACK_IMPORTED_MODULE_16__pipes_satToUnit__["a" /* SatToUnitPipe */],
            __WEBPACK_IMPORTED_MODULE_15__pipes_satToFiat__["a" /* SatToFiatPipe */],
            __WEBPACK_IMPORTED_MODULE_12__pipes_fiatToUnit__["a" /* FiatToUnitPipe */],
            __WEBPACK_IMPORTED_MODULE_13__pipes_keys__["a" /* KeysPipe */],
            __WEBPACK_IMPORTED_MODULE_14__pipes_order_by__["a" /* OrderByPipe */]
        ],
        imports: [
            __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["h" /* IonicModule */].forRoot(__WEBPACK_IMPORTED_MODULE_10__app_component__["a" /* CopayApp */], {
                animate: __WEBPACK_IMPORTED_MODULE_9__environments__["a" /* default */].enableAnimations,
                tabsHideOnSubPages: true,
                tabsPlacement: 'bottom',
                backButtonIcon: 'arrow-round-back',
                backButtonText: ''
            }, {
                links: []
            }),
            __WEBPACK_IMPORTED_MODULE_2__angular_platform_browser__["a" /* BrowserModule */],
            __WEBPACK_IMPORTED_MODULE_0__angular_common_http__["b" /* HttpClientModule */],
            __WEBPACK_IMPORTED_MODULE_7_angular2_moment__["MomentModule"],
            __WEBPACK_IMPORTED_MODULE_8_ngx_qrcode2__["a" /* NgxQRCodeModule */],
            __WEBPACK_IMPORTED_MODULE_24__providers_providers_module__["a" /* ProvidersModule */],
            __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__["b" /* TranslateModule */].forRoot({
                loader: {
                    provide: __WEBPACK_IMPORTED_MODULE_5__ngx_translate_core__["a" /* TranslateLoader */],
                    useFactory: createTranslateLoader,
                    deps: [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */]]
                }
            }),
            __WEBPACK_IMPORTED_MODULE_6__zxing_ngx_scanner__["a" /* ZXingScannerModule */].forRoot()
        ],
        bootstrap: [__WEBPACK_IMPORTED_MODULE_3_ionic_angular__["f" /* IonicApp */]],
        entryComponents: [__WEBPACK_IMPORTED_MODULE_10__app_component__["a" /* CopayApp */], ...__WEBPACK_IMPORTED_MODULE_11__pages_pages__["a" /* PAGES */], ...__WEBPACK_IMPORTED_MODULE_23__components_components__["a" /* COMPONENTS */]],
        providers: [
            {
                provide: __WEBPACK_IMPORTED_MODULE_1__angular_core__["ErrorHandler"],
                useClass: __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["g" /* IonicErrorHandler */]
            }
        ]
    })
], AppModule);

//# sourceMappingURL=app.module.js.map

/***/ }),

/***/ 88:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TimeProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_core__ = __webpack_require__(0);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};

let TimeProvider = class TimeProvider {
    constructor() { }
    withinSameMonth(time1, time2) {
        if (!time1 || !time2)
            return false;
        let date1 = new Date(time1);
        let date2 = new Date(time2);
        return this.getMonthYear(date1) === this.getMonthYear(date2);
    }
    withinPastDay(time) {
        let now = new Date();
        let date = new Date(time);
        return now.getTime() - date.getTime() < 1000 * 60 * 60 * 24;
    }
    isDateInCurrentMonth(date) {
        let now = new Date();
        return this.getMonthYear(now) === this.getMonthYear(date);
    }
    getMonthYear(date) {
        return `${date.getMonth()}-${date.getFullYear()}`;
    }
};
TimeProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_0__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [])
], TimeProvider);

//# sourceMappingURL=time.js.map

/***/ }),

/***/ 92:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return PushNotificationsProvider; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__angular_common_http__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__angular_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ionic_native_fcm__ = __webpack_require__(716);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_ionic_angular__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__app_app__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__bwc_bwc__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__config_config__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__platform_platform__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__profile_profile__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_10_lodash__);
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};





// providers






let PushNotificationsProvider = class PushNotificationsProvider {
    constructor(http, profileProvider, platformProvider, configProvider, logger, appProvider, bwcProvider, FCMPlugin, events) {
        this.http = http;
        this.profileProvider = profileProvider;
        this.platformProvider = platformProvider;
        this.configProvider = configProvider;
        this.logger = logger;
        this.appProvider = appProvider;
        this.bwcProvider = bwcProvider;
        this.FCMPlugin = FCMPlugin;
        this.events = events;
        this._token = null;
        this.logger.info('PushNotificationsProvider initialized.');
        this.isIOS = this.platformProvider.isIOS;
        this.isAndroid = this.platformProvider.isAndroid;
        this.usePushNotifications = this.platformProvider.isCordova;
    }
    init() {
        if (!this.usePushNotifications || this._token)
            return;
        this.configProvider.load().then(() => {
            if (!this.configProvider.get().pushNotificationsEnabled)
                return;
            this.logger.debug('Starting push notification registration...');
            // Keep in mind the function will return null if the token has not been established yet.
            this.FCMPlugin.getToken().then(token => {
                this.logger.debug('Get token for push notifications: ' + token);
                this._token = token;
                this.enable();
                this.handlePushNotifications();
            });
        });
    }
    handlePushNotifications() {
        if (this.usePushNotifications) {
            this.FCMPlugin.onTokenRefresh().subscribe(token => {
                if (!this._token)
                    return;
                this.logger.debug('Refresh and update token for push notifications...');
                this._token = token;
                this.enable();
            });
            this.FCMPlugin.onNotification().subscribe(data => {
                if (!this._token)
                    return;
                this.logger.debug('New Event Push onNotification: ' + JSON.stringify(data));
                if (data.wasTapped) {
                    // Notification was received on device tray and tapped by the user.
                    var walletIdHashed = data.walletId;
                    if (!walletIdHashed)
                        return;
                    this._openWallet(walletIdHashed);
                }
                else {
                    // TODO
                    // Notification was received in foreground. Maybe the user needs to be notified.
                }
            });
        }
    }
    updateSubscription(walletClient) {
        if (!this._token) {
            this.logger.warn('Push notifications disabled for this device. Nothing to do here.');
            return;
        }
        this._subscribe(walletClient);
    }
    enable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot set push notifications. Needs registration.');
            return;
        }
        var wallets = this.profileProvider.getWallets();
        __WEBPACK_IMPORTED_MODULE_10_lodash__["forEach"](wallets, walletClient => {
            this._subscribe(walletClient);
        });
    }
    disable() {
        if (!this._token) {
            this.logger.warn('No token available for this device. Cannot disable push notifications.');
            return;
        }
        var wallets = this.profileProvider.getWallets();
        __WEBPACK_IMPORTED_MODULE_10_lodash__["forEach"](wallets, walletClient => {
            this._unsubscribe(walletClient);
        });
        this._token = null;
    }
    unsubscribe(walletClient) {
        if (!this._token)
            return;
        this._unsubscribe(walletClient);
    }
    _subscribe(walletClient) {
        let opts = {
            token: this._token,
            platform: this.isIOS ? 'ios' : this.isAndroid ? 'android' : null,
            packageName: this.appProvider.info.packageNameId
        };
        walletClient.pushNotificationsSubscribe(opts, err => {
            if (err)
                this.logger.error(walletClient.name + ': Subscription Push Notifications error. ', JSON.stringify(err));
            else
                this.logger.debug(walletClient.name + ': Subscription Push Notifications success.');
        });
    }
    _unsubscribe(walletClient) {
        walletClient.pushNotificationsUnsubscribe(this._token, err => {
            if (err)
                this.logger.error(walletClient.name + ': Unsubscription Push Notifications error. ', JSON.stringify(err));
            else
                this.logger.debug(walletClient.name + ': Unsubscription Push Notifications Success.');
        });
    }
    _openWallet(walletIdHashed) {
        let walletIdHash;
        let sjcl = this.bwcProvider.getSJCL();
        let nextView = {};
        let wallets = this.profileProvider.getWallets();
        let wallet = __WEBPACK_IMPORTED_MODULE_10_lodash__["find"](wallets, w => {
            walletIdHash = sjcl.hash.sha256.hash(w.credentials.walletId);
            return __WEBPACK_IMPORTED_MODULE_10_lodash__["isEqual"](walletIdHashed, sjcl.codec.hex.fromBits(walletIdHash));
        });
        if (!wallet)
            return;
        if (!wallet.isComplete()) {
            nextView.name = 'CopayersPage';
            return;
        }
        else {
            nextView.name = 'WalletDetailsPage';
            nextView.params = { walletId: wallet.credentials.walletId };
        }
        this.events.publish('OpenWalletEvent', nextView);
    }
};
PushNotificationsProvider = __decorate([
    Object(__WEBPACK_IMPORTED_MODULE_1__angular_core__["Injectable"])(),
    __metadata("design:paramtypes", [__WEBPACK_IMPORTED_MODULE_0__angular_common_http__["a" /* HttpClient */],
        __WEBPACK_IMPORTED_MODULE_9__profile_profile__["a" /* ProfileProvider */],
        __WEBPACK_IMPORTED_MODULE_8__platform_platform__["a" /* PlatformProvider */],
        __WEBPACK_IMPORTED_MODULE_7__config_config__["a" /* ConfigProvider */],
        __WEBPACK_IMPORTED_MODULE_4__providers_logger_logger__["a" /* Logger */],
        __WEBPACK_IMPORTED_MODULE_5__app_app__["a" /* AppProvider */],
        __WEBPACK_IMPORTED_MODULE_6__bwc_bwc__["a" /* BwcProvider */],
        __WEBPACK_IMPORTED_MODULE_2__ionic_native_fcm__["a" /* FCM */],
        __WEBPACK_IMPORTED_MODULE_3_ionic_angular__["e" /* Events */]])
], PushNotificationsProvider);

//# sourceMappingURL=push-notifications.js.map

/***/ }),

/***/ 932:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 933:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 935:
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 935;

/***/ }),

/***/ 936:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 938:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 978:
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./af": 499,
	"./af.js": 499,
	"./ar": 500,
	"./ar-dz": 501,
	"./ar-dz.js": 501,
	"./ar-kw": 502,
	"./ar-kw.js": 502,
	"./ar-ly": 503,
	"./ar-ly.js": 503,
	"./ar-ma": 504,
	"./ar-ma.js": 504,
	"./ar-sa": 505,
	"./ar-sa.js": 505,
	"./ar-tn": 506,
	"./ar-tn.js": 506,
	"./ar.js": 500,
	"./az": 507,
	"./az.js": 507,
	"./be": 508,
	"./be.js": 508,
	"./bg": 509,
	"./bg.js": 509,
	"./bm": 510,
	"./bm.js": 510,
	"./bn": 511,
	"./bn.js": 511,
	"./bo": 512,
	"./bo.js": 512,
	"./br": 513,
	"./br.js": 513,
	"./bs": 514,
	"./bs.js": 514,
	"./ca": 515,
	"./ca.js": 515,
	"./cs": 516,
	"./cs.js": 516,
	"./cv": 517,
	"./cv.js": 517,
	"./cy": 518,
	"./cy.js": 518,
	"./da": 519,
	"./da.js": 519,
	"./de": 520,
	"./de-at": 521,
	"./de-at.js": 521,
	"./de-ch": 522,
	"./de-ch.js": 522,
	"./de.js": 520,
	"./dv": 523,
	"./dv.js": 523,
	"./el": 524,
	"./el.js": 524,
	"./en-au": 525,
	"./en-au.js": 525,
	"./en-ca": 526,
	"./en-ca.js": 526,
	"./en-gb": 527,
	"./en-gb.js": 527,
	"./en-ie": 528,
	"./en-ie.js": 528,
	"./en-il": 529,
	"./en-il.js": 529,
	"./en-nz": 530,
	"./en-nz.js": 530,
	"./eo": 531,
	"./eo.js": 531,
	"./es": 532,
	"./es-do": 533,
	"./es-do.js": 533,
	"./es-us": 534,
	"./es-us.js": 534,
	"./es.js": 532,
	"./et": 535,
	"./et.js": 535,
	"./eu": 536,
	"./eu.js": 536,
	"./fa": 537,
	"./fa.js": 537,
	"./fi": 538,
	"./fi.js": 538,
	"./fo": 539,
	"./fo.js": 539,
	"./fr": 540,
	"./fr-ca": 541,
	"./fr-ca.js": 541,
	"./fr-ch": 542,
	"./fr-ch.js": 542,
	"./fr.js": 540,
	"./fy": 543,
	"./fy.js": 543,
	"./gd": 544,
	"./gd.js": 544,
	"./gl": 545,
	"./gl.js": 545,
	"./gom-latn": 546,
	"./gom-latn.js": 546,
	"./gu": 547,
	"./gu.js": 547,
	"./he": 548,
	"./he.js": 548,
	"./hi": 549,
	"./hi.js": 549,
	"./hr": 550,
	"./hr.js": 550,
	"./hu": 551,
	"./hu.js": 551,
	"./hy-am": 552,
	"./hy-am.js": 552,
	"./id": 553,
	"./id.js": 553,
	"./is": 554,
	"./is.js": 554,
	"./it": 555,
	"./it.js": 555,
	"./ja": 556,
	"./ja.js": 556,
	"./jv": 557,
	"./jv.js": 557,
	"./ka": 558,
	"./ka.js": 558,
	"./kk": 559,
	"./kk.js": 559,
	"./km": 560,
	"./km.js": 560,
	"./kn": 561,
	"./kn.js": 561,
	"./ko": 562,
	"./ko.js": 562,
	"./ky": 563,
	"./ky.js": 563,
	"./lb": 564,
	"./lb.js": 564,
	"./lo": 565,
	"./lo.js": 565,
	"./lt": 566,
	"./lt.js": 566,
	"./lv": 567,
	"./lv.js": 567,
	"./me": 568,
	"./me.js": 568,
	"./mi": 569,
	"./mi.js": 569,
	"./mk": 570,
	"./mk.js": 570,
	"./ml": 571,
	"./ml.js": 571,
	"./mn": 572,
	"./mn.js": 572,
	"./mr": 573,
	"./mr.js": 573,
	"./ms": 574,
	"./ms-my": 575,
	"./ms-my.js": 575,
	"./ms.js": 574,
	"./mt": 576,
	"./mt.js": 576,
	"./my": 577,
	"./my.js": 577,
	"./nb": 578,
	"./nb.js": 578,
	"./ne": 579,
	"./ne.js": 579,
	"./nl": 580,
	"./nl-be": 581,
	"./nl-be.js": 581,
	"./nl.js": 580,
	"./nn": 582,
	"./nn.js": 582,
	"./pa-in": 583,
	"./pa-in.js": 583,
	"./pl": 584,
	"./pl.js": 584,
	"./pt": 585,
	"./pt-br": 586,
	"./pt-br.js": 586,
	"./pt.js": 585,
	"./ro": 587,
	"./ro.js": 587,
	"./ru": 588,
	"./ru.js": 588,
	"./sd": 589,
	"./sd.js": 589,
	"./se": 590,
	"./se.js": 590,
	"./si": 591,
	"./si.js": 591,
	"./sk": 592,
	"./sk.js": 592,
	"./sl": 593,
	"./sl.js": 593,
	"./sq": 594,
	"./sq.js": 594,
	"./sr": 595,
	"./sr-cyrl": 596,
	"./sr-cyrl.js": 596,
	"./sr.js": 595,
	"./ss": 597,
	"./ss.js": 597,
	"./sv": 598,
	"./sv.js": 598,
	"./sw": 599,
	"./sw.js": 599,
	"./ta": 600,
	"./ta.js": 600,
	"./te": 601,
	"./te.js": 601,
	"./tet": 602,
	"./tet.js": 602,
	"./tg": 603,
	"./tg.js": 603,
	"./th": 604,
	"./th.js": 604,
	"./tl-ph": 605,
	"./tl-ph.js": 605,
	"./tlh": 606,
	"./tlh.js": 606,
	"./tr": 607,
	"./tr.js": 607,
	"./tzl": 608,
	"./tzl.js": 608,
	"./tzm": 609,
	"./tzm-latn": 610,
	"./tzm-latn.js": 610,
	"./tzm.js": 609,
	"./ug-cn": 611,
	"./ug-cn.js": 611,
	"./uk": 612,
	"./uk.js": 612,
	"./ur": 613,
	"./ur.js": 613,
	"./uz": 614,
	"./uz-latn": 615,
	"./uz-latn.js": 615,
	"./uz.js": 614,
	"./vi": 616,
	"./vi.js": 616,
	"./x-pseudo": 617,
	"./x-pseudo.js": 617,
	"./yo": 618,
	"./yo.js": 618,
	"./zh-cn": 619,
	"./zh-cn.js": 619,
	"./zh-hk": 620,
	"./zh-hk.js": 620,
	"./zh-tw": 621,
	"./zh-tw.js": 621
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 978;

/***/ })

},[869]);
//# sourceMappingURL=main.js.map