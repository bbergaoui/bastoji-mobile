{
  "version": 3,
  "file": "zxing-ngx-scanner.umd.min.js",
  "sources": [
    "ng://@zxing/ngx-scanner/node_modules/tslib/tslib.es6.js",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/browser-qr-code-reader.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.component.ts",
    "ng://@zxing/ngx-scanner/out/app/modules/zxing-scanner/zxing-scanner.module.ts"
  ],
  "sourcesContent": [
    "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n",
    "/// <reference path=\"./image-capture.d.ts\" />\r\n\r\nimport {\r\n    Reader,\r\n    BinaryBitmap,\r\n    HybridBinarizer,\r\n    Result,\r\n    Exception,\r\n    HTMLCanvasElementLuminanceSource,\r\n} from '@zxing/library';\r\n\r\nimport { BehaviorSubject } from 'rxjs/BehaviorSubject';\r\nimport { Observable } from 'rxjs/Observable';\r\n\r\n/**\r\n * Based on zxing-typescript BrowserCodeReader\r\n */\r\nexport class BrowserCodeReader {\r\n\r\n    /**\r\n     * The HTML video element, used to display the camera stream.\r\n     */\r\n    private videoElement: HTMLVideoElement;\r\n    /**\r\n     * Should contain the actual registered listener for video play-ended,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoPlayEndedEventListener: EventListener;\r\n    /**\r\n     * Should contain the actual registered listener for video playing,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoPlayingEventListener: EventListener;\r\n    /**\r\n     * Should contain the actual registered listener for video loaded-metadata,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private videoLoadedMetadataEventListener: EventListener;\r\n\r\n    /**\r\n     * The HTML image element, used as a fallback for the video element when decoding.\r\n     */\r\n    private imageElement: HTMLImageElement;\r\n    /**\r\n     * Should contain the actual registered listener for image loading,\r\n     * used to unregister that listener when needed.\r\n     */\r\n    private imageLoadedEventListener: EventListener;\r\n\r\n    /**\r\n     * The HTML canvas element, used to draw the video or image's frame for decoding.\r\n     */\r\n    private canvasElement: HTMLCanvasElement;\r\n    /**\r\n     * The HTML canvas element context.\r\n     */\r\n    private canvasElementContext: CanvasRenderingContext2D;\r\n\r\n    /**\r\n     * The continuous scan timeout Id.\r\n     */\r\n    private timeoutHandler: number;\r\n\r\n    /**\r\n     * The stream output from camera.\r\n     */\r\n    private stream: MediaStream;\r\n    /**\r\n     * The track from camera.\r\n     */\r\n    private track: MediaStreamTrack;\r\n    /**\r\n     * Shows if torch is available on the camera.\r\n     */\r\n    private torchCompatible = new BehaviorSubject<boolean>(false);\r\n    /**\r\n     * The device id of the current media device.\r\n     */\r\n    private deviceId: string;\r\n\r\n    /**\r\n     * Constructor for dependency injection.\r\n     *\r\n     * @param reader The barcode reader to be used to decode the stream.\r\n     * @param timeBetweenScans The scan throttling in milliseconds.\r\n     */\r\n    public constructor(private reader: Reader, private timeBetweenScans: number = 500) { }\r\n\r\n    /**\r\n     * Starts the decoding from the actual or a new video element.\r\n     *\r\n     * @param callbackFn The callback to be executed after every scan attempt\r\n     * @param deviceId The device's to be used Id\r\n     * @param videoElement A new video element\r\n     */\r\n    public decodeFromInputVideoDevice(callbackFn?: (result: Result) => any, deviceId?: string, videoElement?: HTMLVideoElement): void {\r\n\r\n        if (deviceId !== undefined) {\r\n            this.deviceId = deviceId;\r\n        }\r\n\r\n        this.reset();\r\n\r\n        this.prepareVideoElement(videoElement);\r\n\r\n        const video = this.deviceId === undefined\r\n            ? { facingMode: { exact: 'environment' } }\r\n            : { deviceId: { exact: this.deviceId } };\r\n\r\n        const constraints: MediaStreamConstraints = {\r\n            audio: false,\r\n            video\r\n        };\r\n\r\n        if (typeof navigator !== 'undefined') {\r\n            navigator\r\n                .mediaDevices\r\n                .getUserMedia(constraints)\r\n                .then((stream: MediaStream) => this.startDecodeFromStream(stream, callbackFn))\r\n                .catch((err: any) => {\r\n                    /* handle the error, or not */\r\n                    console.error(err);\r\n                });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the new stream and request a new decoding-with-delay.\r\n     *\r\n     * @param stream The stream to be shown in the video element.\r\n     * @param callbackFn A callback for the decode method.\r\n     */\r\n    private startDecodeFromStream(stream: MediaStream, callbackFn?: (result: Result) => any): void {\r\n        this.stream = stream;\r\n        this.bindVideoSrc(this.videoElement, this.stream);\r\n        this.bindEvents(this.videoElement, callbackFn);\r\n        this.checkTorchCompatibility(this.stream);\r\n    }\r\n\r\n    /**\r\n     * Defines what the videoElement src will be.\r\n     *\r\n     * @param videoElement\r\n     * @param stream\r\n     */\r\n    public bindVideoSrc(videoElement: HTMLVideoElement, stream: MediaStream): void {\r\n        // Older browsers may not have `srcObject`\r\n        try {\r\n            // @NOTE Throws Exception if interrupted by a new loaded request\r\n            videoElement.srcObject = stream;\r\n        } catch (err) {\r\n            // @NOTE Avoid using this in new browsers, as it is going away.\r\n            videoElement.src = window.URL.createObjectURL(stream);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unbinds a HTML video src property.\r\n     *\r\n     * @param videoElement\r\n     */\r\n    public unbindVideoSrc(videoElement: HTMLVideoElement): void {\r\n        try {\r\n            videoElement.srcObject = null;\r\n        } catch (err) {\r\n            videoElement.src = '';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds listeners and callbacks to the videoElement.\r\n     *\r\n     * @param videoElement\r\n     * @param callbackFn\r\n     */\r\n    private bindEvents(videoElement: HTMLVideoElement, callbackFn?: (result: Result) => any): void {\r\n        if (callbackFn !== undefined) {\r\n            this.videoPlayingEventListener = () => {\r\n                this.decodeWithDelay(callbackFn);\r\n            };\r\n        }\r\n\r\n        videoElement.addEventListener('playing', this.videoPlayingEventListener);\r\n\r\n        this.videoLoadedMetadataEventListener = () => {\r\n            videoElement.play();\r\n        };\r\n\r\n        videoElement.addEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\r\n    }\r\n\r\n    /**\r\n     * Checks if the stream supports torch control.\r\n     *\r\n     * @param stream The media stream used to check.\r\n     */\r\n    private checkTorchCompatibility(stream: MediaStream): void {\r\n        try {\r\n            this.track = stream.getVideoTracks()[0];\r\n\r\n            const imageCapture = new ImageCapture(this.track);\r\n\r\n            const photoCapabilities = imageCapture.getPhotoCapabilities().then((capabilities) => {\r\n                const compatible = !!capabilities.torch || ('fillLightMode' in capabilities && capabilities.fillLightMode.length !== 0);\r\n                this.torchCompatible.next(compatible);\r\n            });\r\n        } catch (err) {\r\n            this.torchCompatible.next(false);\r\n        }\r\n    }\r\n\r\n    public setTorch(on: boolean): void {\r\n        if (this.torchCompatible.value) {\r\n            if (on) {\r\n                this.track.applyConstraints({\r\n                    advanced: [<any>{ torch: true }]\r\n                });\r\n            } else {\r\n                this.restart();\r\n            }\r\n        }\r\n    }\r\n\r\n    public get torchAvailable(): Observable<boolean> {\r\n        return this.torchCompatible.asObservable();\r\n    }\r\n\r\n    /**\r\n     * Sets a HTMLVideoElement for scanning or creates a new one.\r\n     *\r\n     * @param videoElement The HTMLVideoElement to be set.\r\n     */\r\n    private prepareVideoElement(videoElement?: HTMLVideoElement): void {\r\n\r\n        if (!videoElement && typeof document !== 'undefined') {\r\n            videoElement = document.createElement('video');\r\n            videoElement.width = 200;\r\n            videoElement.height = 200;\r\n        }\r\n\r\n        this.videoElement = videoElement;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param callbackFn\r\n     */\r\n    private decodeWithDelay(callbackFn: (result: Result) => any): void {\r\n        this.timeoutHandler = window.setTimeout(this.decode.bind(this, callbackFn), this.timeBetweenScans);\r\n    }\r\n\r\n    /**\r\n     * Does the real image decoding job.\r\n     *\r\n     * @param callbackFn\r\n     * @param retryIfNotFound\r\n     * @param retryIfChecksumOrFormatError\r\n     * @param once\r\n     */\r\n    private decode(\r\n        callbackFn: (result: Result) => any,\r\n        retryIfNotFound: boolean = true,\r\n        retryIfChecksumOrFormatError: boolean = true,\r\n        once = false\r\n    ): void {\r\n\r\n        if (undefined === this.canvasElementContext) {\r\n            this.prepareCaptureCanvas();\r\n        }\r\n\r\n        this.canvasElementContext.drawImage(this.videoElement || this.imageElement, 0, 0);\r\n\r\n        const luminanceSource = new HTMLCanvasElementLuminanceSource(this.canvasElement);\r\n        const binaryBitmap = new BinaryBitmap(new HybridBinarizer(luminanceSource));\r\n\r\n        try {\r\n\r\n            const result = this.reader.decode(binaryBitmap);\r\n\r\n            callbackFn(result);\r\n\r\n            if (!once && !!this.stream) {\r\n                this.decodeWithDelay(callbackFn);\r\n            }\r\n\r\n        } catch (re) {\r\n\r\n            // console.debug(retryIfChecksumOrFormatError, re);\r\n\r\n            if (retryIfNotFound && Exception.isOfType(re, Exception.NotFoundException)) {\r\n\r\n                // console.debug('zxing-scanner', 'QR-code not-found, trying again...');\r\n\r\n                this.decodeWithDelay(callbackFn);\r\n\r\n            } else if (\r\n                retryIfChecksumOrFormatError &&\r\n                (\r\n                    Exception.isOfType(re, Exception.ChecksumException) ||\r\n                    Exception.isOfType(re, Exception.FormatException)\r\n                )\r\n            ) {\r\n                console.warn('zxing-scanner', 'Checksum or format error, trying again...', re);\r\n\r\n                this.decodeWithDelay(callbackFn);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 🖌 Prepares the canvas for capture and scan frames.\r\n     */\r\n    private prepareCaptureCanvas(): void {\r\n\r\n        if (typeof document === 'undefined') {\r\n\r\n            this.canvasElement = undefined;\r\n            this.canvasElementContext = undefined;\r\n\r\n            return;\r\n        }\r\n\r\n        const canvasElement = document.createElement('canvas');\r\n\r\n        let width: number;\r\n        let height: number;\r\n\r\n        if (this.videoElement !== undefined) {\r\n            width = this.videoElement.videoWidth;\r\n            height = this.videoElement.videoHeight;\r\n        } else {\r\n            width = this.imageElement.naturalWidth || this.imageElement.width;\r\n            height = this.imageElement.naturalHeight || this.imageElement.height;\r\n        }\r\n\r\n        canvasElement.style.width = width + 'px';\r\n        canvasElement.style.height = height + 'px';\r\n        canvasElement.width = width;\r\n        canvasElement.height = height;\r\n\r\n        this.canvasElement = canvasElement;\r\n        this.canvasElementContext = canvasElement.getContext('2d');\r\n    }\r\n\r\n    /**\r\n     * Stops the continuous scan and cleans the stream.\r\n     */\r\n    private stop(): void {\r\n\r\n        if (this.timeoutHandler) {\r\n            window.clearTimeout(this.timeoutHandler);\r\n            this.timeoutHandler = null;\r\n        }\r\n\r\n        if (this.stream) {\r\n            this.stream.getTracks()[0].stop();\r\n            this.stream = null;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Resets the scanner and it's configurations.\r\n     */\r\n    public reset(): void {\r\n\r\n        // stops the camera, preview and scan 🔴\r\n\r\n        this.stop();\r\n\r\n        if (this.videoElement) {\r\n\r\n            // first gives freedon to the element 🕊\r\n\r\n            if (undefined !== this.videoPlayEndedEventListener) {\r\n                this.videoElement.removeEventListener('ended', this.videoPlayEndedEventListener);\r\n            }\r\n\r\n            if (undefined !== this.videoPlayingEventListener) {\r\n                this.videoElement.removeEventListener('playing', this.videoPlayingEventListener);\r\n            }\r\n\r\n            if (undefined !== this.videoLoadedMetadataEventListener) {\r\n                this.videoElement.removeEventListener('loadedmetadata', this.videoLoadedMetadataEventListener);\r\n            }\r\n\r\n            if (this.stream) {\r\n                try {\r\n                    this.stream.getVideoTracks().forEach(track => {\r\n                        track.stop();\r\n                    });\r\n                } catch (err) {\r\n\r\n                }\r\n            }\r\n\r\n            // then forgets about that element 😢\r\n\r\n            this.unbindVideoSrc(this.videoElement);\r\n\r\n            this.videoElement.removeAttribute('src');\r\n            this.videoElement = undefined;\r\n        }\r\n\r\n        if (this.imageElement) {\r\n\r\n            // first gives freedon to the element 🕊\r\n\r\n            if (undefined !== this.videoPlayEndedEventListener) {\r\n                this.imageElement.removeEventListener('load', this.imageLoadedEventListener);\r\n            }\r\n\r\n            // then forgets about that element 😢\r\n\r\n            this.imageElement.src = undefined;\r\n            this.imageElement.removeAttribute('src');\r\n            this.imageElement = undefined;\r\n        }\r\n\r\n        // cleans canvas references 🖌\r\n\r\n        this.canvasElementContext = undefined;\r\n        this.canvasElement = undefined;\r\n    }\r\n\r\n    private restart(): void {\r\n        // reset\r\n        // start\r\n        this.decodeFromInputVideoDevice(undefined, undefined, this.videoElement);\r\n    }\r\n}\r\n",
    "import { QRCodeReader } from '@zxing/library';\r\n\r\nimport { BrowserCodeReader } from './browser-code-reader';\r\n\r\nexport class BrowserQRCodeReader extends BrowserCodeReader {\r\n    public constructor(timeBetweenScansMillis: number = 500) {\r\n        super(new QRCodeReader(), timeBetweenScansMillis);\r\n    }\r\n}\r\n",
    "import {\r\n    AfterViewInit,\r\n    ChangeDetectionStrategy,\r\n    Component,\r\n    ElementRef,\r\n    EventEmitter,\r\n    Inject,\r\n    Input,\r\n    OnChanges,\r\n    OnDestroy,\r\n    Output,\r\n    PLATFORM_ID,\r\n    SimpleChanges,\r\n    ViewChild\r\n} from '@angular/core';\r\n\r\nimport { isPlatformBrowser } from '@angular/common';\r\n\r\nimport { Result } from '@zxing/library';\r\n\r\nimport { BrowserQRCodeReader } from './browser-qr-code-reader';\r\n\r\n@Component({\r\n    // tslint:disable-next-line:component-selector\r\n    selector: 'zxing-scanner',\r\n    template: `<video [ngClass]=\"cssClass\" #preview>\r\n    <p>\r\n        Your browser does not support this feature, please try to upgrade it.\r\n    </p>\r\n    <p>\r\n        Seu navegador não suporta este recurso, por favor tente atualizá-lo.\r\n    </p>\r\n</video>\r\n`,\r\n    styles: [`:host{display:block}video{width:100%;height:auto;-o-object-fit:contain;object-fit:contain}`],\r\n    changeDetection: ChangeDetectionStrategy.OnPush\r\n})\r\nexport class ZXingScannerComponent implements AfterViewInit, OnDestroy, OnChanges {\r\n\r\n    /**\r\n     * The ZXing code reader.\r\n     */\r\n    private codeReader: BrowserQRCodeReader;\r\n\r\n    /**\r\n     * Has `navigator` access.\r\n     */\r\n    private hasNavigator: boolean;\r\n\r\n\r\n    /**\r\n     * Says if some native API is supported.\r\n     */\r\n    private isMediaDevicesSuported: boolean;\r\n\r\n    /**\r\n     * Says if some native API is supported.\r\n     */\r\n    private isEnumerateDevicesSuported: boolean;\r\n\r\n    /**\r\n     * List of enable video-input devices.\r\n     */\r\n    private videoInputDevices: MediaDeviceInfo[];\r\n    /**\r\n     * The actual device used to scan things.\r\n     */\r\n    private videoInputDevice: MediaDeviceInfo;\r\n\r\n    /**\r\n     * Says if the user allowedthe use of the camera or not.\r\n     */\r\n    private hasPermission: boolean;\r\n\r\n    /**\r\n     * Reference to the preview element, should be the `video` tag.\r\n     */\r\n    @ViewChild('preview')\r\n    previewElemRef: ElementRef;\r\n\r\n    /**\r\n     * The scan throttling (time between scans) in milliseconds.\r\n     */\r\n    @Input()\r\n    scanThrottling = 1500;\r\n\r\n    /**\r\n     * Allow start scan or not.\r\n     */\r\n    @Input()\r\n    scannerEnabled = true;\r\n\r\n    /**\r\n     * The device that should be used to scan things.\r\n     */\r\n    @Input()\r\n    device: MediaDeviceInfo;\r\n\r\n    /**\r\n     * The value of the HTML video's class attribute.\r\n     */\r\n    @Input()\r\n    cssClass: string;\r\n\r\n    /**\r\n     * Enable or disable autofocus of the camera (might have an impact on performance)\r\n     */\r\n    @Input()\r\n    autofocusEnabled = true;\r\n\r\n    /**\r\n     * Allow start scan or not.\r\n     */\r\n    @Input()\r\n    set torch(on: boolean) {\r\n        this.codeReader.setTorch(on);\r\n    }\r\n\r\n    /**\r\n     * Emitts events when the torch compatibility is changed.\r\n     */\r\n    @Output()\r\n    torchCompatible = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * Emitts events when a scan is successful performed, will inject the string value of the QR-code to the callback.\r\n     */\r\n    @Output()\r\n    scanSuccess = new EventEmitter<string>();\r\n\r\n    /**\r\n     * Emitts events when a scan fails without errors, usefull to know how much scan tries where made.\r\n     */\r\n    @Output()\r\n    scanFailure = new EventEmitter<void>();\r\n\r\n    /**\r\n     * Emitts events when a scan throws some error, will inject the error to the callback.\r\n     */\r\n    @Output()\r\n    scanError = new EventEmitter<Error>();\r\n\r\n    /**\r\n     * Emitts events when a scan is performed, will inject the Result value of the QR-code scan (if available) to the callback.\r\n     */\r\n    @Output()\r\n    scanComplete = new EventEmitter<Result>();\r\n\r\n    /**\r\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\r\n     */\r\n    @Output()\r\n    camerasFound = new EventEmitter<MediaDeviceInfo[]>();\r\n\r\n    /**\r\n     * Emitts events when no cameras are found, will inject an exception (if available) to the callback.\r\n     */\r\n    @Output()\r\n    camerasNotFound = new EventEmitter<any>();\r\n\r\n    /**\r\n     * Emitts events when the users answers for permission.\r\n     */\r\n    @Output()\r\n    permissionResponse = new EventEmitter<boolean>();\r\n\r\n    /**\r\n     * Constructor to build the object and do some DI.\r\n     */\r\n    constructor() {\r\n        this.codeReader = new BrowserQRCodeReader(1500);\r\n        this.hasNavigator = typeof navigator !== 'undefined';\r\n        this.isMediaDevicesSuported = this.hasNavigator && !!navigator.mediaDevices;\r\n        this.isEnumerateDevicesSuported = !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);\r\n    }\r\n\r\n    /**\r\n     * Manages the bindinded property changes.\r\n     * @param changes\r\n     */\r\n    ngOnChanges(changes: SimpleChanges): void {\r\n\r\n        if (changes.scannerEnabled) {\r\n            if (!this.scannerEnabled) {\r\n                this.resetScan();\r\n            } else if (this.videoInputDevice) {\r\n                this.scan(this.videoInputDevice.deviceId);\r\n            }\r\n        }\r\n\r\n        if (changes.device) {\r\n            if (this.device) {\r\n                this.changeDevice(this.device);\r\n            } else {\r\n                console.warn('zxing-scanner', 'device', 'Unselected device.');\r\n                this.resetScan();\r\n            }\r\n        }\r\n\r\n        if (changes.scanThrottling) {\r\n            this.setCodeReaderThrottling(this.scanThrottling);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Executed after the view initialization.\r\n     */\r\n    ngAfterViewInit(): void {\r\n\r\n        // Chrome 63 fix\r\n        if (!this.previewElemRef) {\r\n            console.warn('zxing-scanner', 'Preview element not found!');\r\n            return;\r\n        }\r\n\r\n        // iOS 11 Fix\r\n        this.previewElemRef.nativeElement.setAttribute('autoplay', false);\r\n        this.previewElemRef.nativeElement.setAttribute('muted', true);\r\n        this.previewElemRef.nativeElement.setAttribute('playsinline', true);\r\n        this.previewElemRef.nativeElement.setAttribute('autofocus', this.autofocusEnabled);\r\n\r\n        this.askForPermission().subscribe((hasPermission: boolean) => {\r\n\r\n            if (hasPermission) {\r\n\r\n                // gets and enumerates all video devices\r\n                this.enumarateVideoDevices((videoInputDevices: MediaDeviceInfo[]) => {\r\n\r\n                    if (videoInputDevices && videoInputDevices.length > 0) {\r\n                        this.camerasFound.next(videoInputDevices);\r\n                    } else {\r\n                        this.camerasNotFound.next();\r\n                    }\r\n\r\n                });\r\n\r\n                this.startScan(this.videoInputDevice);\r\n\r\n                this.codeReader.torchAvailable.subscribe((value: boolean) => {\r\n                    this.torchCompatible.emit(value);\r\n                });\r\n\r\n            } else {\r\n\r\n                if (hasPermission === false) {\r\n                    console.warn('zxing-scanner', 'ngAfterViewInit', 'User has denied permission.');\r\n                } else {\r\n                    console.warn('zxing-scanner', 'ngAfterViewInit', 'It was not possible to check for permissions.');\r\n                }\r\n            }\r\n\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes some actions before destroy the component.\r\n     */\r\n    ngOnDestroy(): void {\r\n        this.resetScan();\r\n    }\r\n\r\n    /**\r\n     * Starts a new QR-scanner to set a new scan throttling.\r\n     *\r\n     * @param throttling The scan speed in milliseconds.\r\n     */\r\n    setCodeReaderThrottling(throttling: number): void {\r\n        this.codeReader = new BrowserQRCodeReader(throttling);\r\n        this.restartScan();\r\n    }\r\n\r\n    /**\r\n     * Properly changes the actual target device.\r\n     *\r\n     * @param device\r\n     */\r\n    changeDevice(device: MediaDeviceInfo): void {\r\n        this.videoInputDevice = device;\r\n        this.startScan(device);\r\n    }\r\n\r\n    /**\r\n     * Properly changes the actual target device using it's deviceId.\r\n     *\r\n     * @param deviceId\r\n     */\r\n    changeDeviceById(deviceId: string): void {\r\n        this.changeDevice(this.getDeviceById(deviceId));\r\n    }\r\n\r\n    /**\r\n     * Properly returns the target device using it's deviceId.\r\n     *\r\n     * @param deviceId\r\n     */\r\n    getDeviceById(deviceId: string): MediaDeviceInfo {\r\n        return this.videoInputDevices.find(device => device.deviceId === deviceId);\r\n    }\r\n\r\n    /**\r\n     * Sets the permission value and emmits the event.\r\n     */\r\n    private setPermission(hasPermission: boolean | undefined): EventEmitter<boolean> {\r\n        this.hasPermission = hasPermission;\r\n        this.permissionResponse.next(hasPermission);\r\n        return this.permissionResponse;\r\n    }\r\n\r\n    /**\r\n     * Gets and registers all cammeras.\r\n     */\r\n    askForPermission(): EventEmitter<boolean> {\r\n\r\n        if (!this.hasNavigator) {\r\n            console.error('zxing-scanner', 'askForPermission', 'Can\\'t ask permission, navigator is not present.');\r\n            return this.setPermission(undefined);\r\n        }\r\n\r\n        if (!this.isMediaDevicesSuported) {\r\n            console.error('zxing-scanner', 'askForPermission', 'Can\\'t get user media, this is not supported.');\r\n            return this.setPermission(undefined);\r\n        }\r\n\r\n        // Will try to ask for permission\r\n        navigator\r\n            .mediaDevices\r\n            .getUserMedia({ audio: false, video: true })\r\n            .then((stream: MediaStream) => {\r\n\r\n                try {\r\n\r\n                    // Start stream so Browser can display its permission-dialog\r\n                    this.codeReader.bindVideoSrc(this.previewElemRef.nativeElement, stream);\r\n\r\n                    // After permission was granted, we can stop it again\r\n                    stream.getVideoTracks().forEach(track => {\r\n                        track.stop();\r\n                    });\r\n\r\n                    // should stop the opened stream\r\n                    this.codeReader.unbindVideoSrc(this.previewElemRef.nativeElement);\r\n\r\n                    // if the scripts lives until here, that's only one mean:\r\n\r\n                    // permission granted\r\n                    this.setPermission(true);\r\n\r\n                } catch (err) {\r\n\r\n                    console.error('zxing-scanner', 'askForPermission', err);\r\n\r\n                    // permission aborted\r\n                    this.setPermission(undefined);\r\n                }\r\n\r\n            })\r\n            .catch((err: DOMException) => {\r\n\r\n                // failed to grant permission to video input\r\n\r\n                console.warn('zxing-scanner', 'askForPermission', err);\r\n\r\n                switch (err.name) {\r\n\r\n                    case 'NotAllowedError':\r\n                        // permission denied\r\n                        this.setPermission(false);\r\n                        break;\r\n\r\n                    case 'NotFoundError':\r\n                        this.camerasNotFound.next(err);\r\n                        break;\r\n\r\n                    default:\r\n                        this.setPermission(undefined);\r\n                        break;\r\n\r\n                }\r\n\r\n            });\r\n\r\n        // Returns the event emitter, so the dev can subscribe to it\r\n        return this.permissionResponse;\r\n    }\r\n\r\n    /**\r\n     * Starts the continuous scanning for the given device.\r\n     *\r\n     * @param deviceId The deviceId from the device.\r\n     */\r\n    scan(deviceId: string): void {\r\n        try {\r\n\r\n            this.codeReader.decodeFromInputVideoDevice((result: any) => {\r\n\r\n                if (result) {\r\n                    this.dispatchScanSuccess(result);\r\n                } else {\r\n                    this.dispatchScanFailure();\r\n                }\r\n\r\n                this.dispatchScanComplete(result);\r\n\r\n            }, deviceId, this.previewElemRef.nativeElement);\r\n\r\n        } catch (err) {\r\n            this.dispatchScanError(err);\r\n            this.dispatchScanComplete(undefined);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the scanning if allowed.\r\n     *\r\n     * @param device The device to be used in the scan.\r\n     */\r\n    startScan(device: MediaDeviceInfo): void {\r\n        if (this.scannerEnabled && device) {\r\n            this.scan(device.deviceId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops the scan service.\r\n     */\r\n    resetScan(): void {\r\n        this.codeReader.reset();\r\n    }\r\n\r\n    /**\r\n     * Stops and starts back the scan.\r\n     */\r\n    restartScan(): void {\r\n        this.restartScan();\r\n        this.startScan(this.device);\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan success event.\r\n     *\r\n     * @param result the scan result.\r\n     */\r\n    private dispatchScanSuccess(result: Result): void {\r\n        this.scanSuccess.next(result.getText());\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan failure event.\r\n     */\r\n    private dispatchScanFailure(): void {\r\n        this.scanFailure.next();\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan error event.\r\n     *\r\n     * @param err the error thing.\r\n     */\r\n    private dispatchScanError(error: any): void {\r\n        this.scanError.next(error);\r\n    }\r\n\r\n    /**\r\n     * Dispatches the scan event.\r\n     *\r\n     * @param result the scan result.\r\n     */\r\n    private dispatchScanComplete(result: Result): void {\r\n        this.scanComplete.next(result);\r\n    }\r\n\r\n    /**\r\n     * Enumerates all the available devices.\r\n     *\r\n     * @param successCallback\r\n     */\r\n    enumarateVideoDevices(successCallback: any): void {\r\n\r\n        if (!this.hasNavigator) {\r\n            console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, navigator is not present.');\r\n            return;\r\n        }\r\n\r\n        if (!this.isEnumerateDevicesSuported) {\r\n            console.error('zxing-scanner', 'enumarateVideoDevices', 'Can\\'t enumerate devices, method not supported.');\r\n            return;\r\n        }\r\n\r\n        navigator.mediaDevices.enumerateDevices().then((devices: MediaDeviceInfo[]) => {\r\n\r\n            this.videoInputDevices = [];\r\n\r\n            for (const deviceI of devices) {\r\n\r\n                // @todo type this as `MediaDeviceInfo`\r\n                const device: any = {};\r\n\r\n                // tslint:disable-next-line:forin\r\n                for (const key in deviceI) {\r\n                    device[key] = deviceI[key];\r\n                }\r\n\r\n                if (device.kind === 'video') {\r\n                    device.kind = 'videoinput';\r\n                }\r\n\r\n                if (!device.deviceId) {\r\n                    device.deviceId = (<any>device).id;\r\n                }\r\n\r\n                if (!device.label) {\r\n                    device.label = 'Camera (no-permission)';\r\n                }\r\n\r\n                if (device.kind === 'videoinput') {\r\n                    this.videoInputDevices.push(device);\r\n                }\r\n            }\r\n\r\n            successCallback(this.videoInputDevices);\r\n        });\r\n    }\r\n}\r\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { FormsModule } from '@angular/forms';\r\n\r\nimport { ZXingScannerComponent } from './zxing-scanner.component';\r\n\r\nexport type ZXingScannerComponent = ZXingScannerComponent;\r\n\r\n@NgModule({\r\n    imports: [\r\n        CommonModule,\r\n        FormsModule\r\n    ],\r\n    declarations: [ZXingScannerComponent],\r\n    exports: [ZXingScannerComponent],\r\n})\r\nexport class ZXingScannerModule {\r\n    static forRoot(): ModuleWithProviders {\r\n        return {\r\n            ngModule: ZXingScannerModule\r\n        };\r\n    }\r\n}\r\n"
  ],
  "names": [
    "extendStatics",
    "Object",
    "setPrototypeOf",
    "__proto__",
    "Array",
    "d",
    "b",
    "p",
    "hasOwnProperty",
    "BrowserQRCodeReader",
    "_super",
    "timeBetweenScansMillis",
    "call",
    "this",
    "QRCodeReader",
    "__",
    "constructor",
    "prototype",
    "create",
    "tslib_1.__extends",
    "BrowserCodeReader",
    "reader",
    "timeBetweenScans",
    "torchCompatible",
    "BehaviorSubject",
    "decodeFromInputVideoDevice",
    "callbackFn",
    "deviceId",
    "videoElement",
    "_this",
    "undefined",
    "reset",
    "prepareVideoElement",
    "constraints",
    "audio",
    "video",
    "facingMode",
    "exact",
    "navigator",
    "mediaDevices",
    "getUserMedia",
    "then",
    "stream",
    "startDecodeFromStream",
    "catch",
    "err",
    "console",
    "error",
    "bindVideoSrc",
    "bindEvents",
    "checkTorchCompatibility",
    "srcObject",
    "src",
    "window",
    "URL",
    "createObjectURL",
    "unbindVideoSrc",
    "videoPlayingEventListener",
    "decodeWithDelay",
    "addEventListener",
    "videoLoadedMetadataEventListener",
    "play",
    "track",
    "getVideoTracks",
    "ImageCapture",
    "getPhotoCapabilities",
    "capabilities",
    "compatible",
    "torch",
    "fillLightMode",
    "length",
    "next",
    "setTorch",
    "on",
    "value",
    "applyConstraints",
    "advanced",
    "restart",
    "defineProperty",
    "get",
    "asObservable",
    "document",
    "createElement",
    "width",
    "height",
    "timeoutHandler",
    "setTimeout",
    "decode",
    "bind",
    "retryIfNotFound",
    "retryIfChecksumOrFormatError",
    "once",
    "canvasElementContext",
    "prepareCaptureCanvas",
    "drawImage",
    "imageElement",
    "luminanceSource",
    "HTMLCanvasElementLuminanceSource",
    "canvasElement",
    "binaryBitmap",
    "BinaryBitmap",
    "HybridBinarizer",
    "re",
    "Exception",
    "isOfType",
    "NotFoundException",
    "ChecksumException",
    "FormatException",
    "warn",
    "videoWidth",
    "videoHeight",
    "naturalWidth",
    "naturalHeight",
    "style",
    "getContext",
    "stop",
    "clearTimeout",
    "getTracks",
    "videoPlayEndedEventListener",
    "removeEventListener",
    "forEach",
    "removeAttribute",
    "imageLoadedEventListener",
    "ZXingScannerComponent",
    "scanThrottling",
    "scannerEnabled",
    "autofocusEnabled",
    "EventEmitter",
    "scanSuccess",
    "scanFailure",
    "scanError",
    "scanComplete",
    "camerasFound",
    "camerasNotFound",
    "permissionResponse",
    "codeReader",
    "hasNavigator",
    "isMediaDevicesSuported",
    "isEnumerateDevicesSuported",
    "enumerateDevices",
    "set",
    "ngOnChanges",
    "changes",
    "videoInputDevice",
    "scan",
    "resetScan",
    "device",
    "changeDevice",
    "setCodeReaderThrottling",
    "ngAfterViewInit",
    "previewElemRef",
    "nativeElement",
    "setAttribute",
    "askForPermission",
    "subscribe",
    "hasPermission",
    "enumarateVideoDevices",
    "videoInputDevices",
    "startScan",
    "torchAvailable",
    "emit",
    "ngOnDestroy",
    "throttling",
    "restartScan",
    "changeDeviceById",
    "getDeviceById",
    "find",
    "setPermission",
    "name",
    "result",
    "dispatchScanSuccess",
    "dispatchScanFailure",
    "dispatchScanComplete",
    "dispatchScanError",
    "getText",
    "successCallback",
    "devices",
    "devices_1",
    "o",
    "m",
    "Symbol",
    "iterator",
    "i",
    "done",
    "tslib_1.__values",
    "devices_1_1",
    "deviceI",
    "key",
    "kind",
    "id",
    "label",
    "push",
    "type",
    "Component",
    "args",
    "selector",
    "template",
    "styles",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "ViewChild",
    "Input",
    "cssClass",
    "Output",
    "ZXingScannerModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "declarations",
    "exports"
  ],
  "mappings": "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"
}
